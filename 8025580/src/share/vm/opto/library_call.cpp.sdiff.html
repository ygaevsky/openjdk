<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/share/vm/opto </title>
</head><body id="SUNWwebrev">
<h2>src/share/vm/opto/library_call.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 403     if (!InlineObjectHash)  return NULL;
 404     does_virtual_dispatch = true;
 405     break;
 406   case vmIntrinsics::_clone:
 407     does_virtual_dispatch = true;
 408   case vmIntrinsics::_copyOf:
 409   case vmIntrinsics::_copyOfRange:
 410     if (!InlineObjectCopy)  return NULL;
 411     // These also use the arraycopy intrinsic mechanism:
 412     if (!InlineArrayCopy)  return NULL;
 413     break;
 414   case vmIntrinsics::_encodeISOArray:
 415     if (!SpecialEncodeISOArray)  return NULL;
 416     if (!Matcher::match_rule_supported(Op_EncodeISOArray))  return NULL;
 417     break;
 418   case vmIntrinsics::_checkIndex:
 419     // We do not intrinsify this.  The optimizer does fine with it.
 420     return NULL;
 421 
 422   case vmIntrinsics::_getCallerClass:
<span class="removed"> 423     if (!UseNewReflection)  return NULL;</span>
 424     if (!InlineReflectionGetCallerClass)  return NULL;
 425     if (SystemDictionary::reflect_CallerSensitive_klass() == NULL)  return NULL;
 426     break;
 427 
 428   case vmIntrinsics::_bitCount_i:
 429     if (!Matcher::match_rule_supported(Op_PopCountI)) return NULL;
 430     break;
 431 
 432   case vmIntrinsics::_bitCount_l:
 433     if (!Matcher::match_rule_supported(Op_PopCountL)) return NULL;
 434     break;
 435 
 436   case vmIntrinsics::_numberOfLeadingZeros_i:
 437     if (!Matcher::match_rule_supported(Op_CountLeadingZerosI)) return NULL;
 438     break;
 439 
 440   case vmIntrinsics::_numberOfLeadingZeros_l:
 441     if (!Matcher::match_rule_supported(Op_CountLeadingZerosL)) return NULL;
 442     break;
 443 

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
 403     if (!InlineObjectHash)  return NULL;
 404     does_virtual_dispatch = true;
 405     break;
 406   case vmIntrinsics::_clone:
 407     does_virtual_dispatch = true;
 408   case vmIntrinsics::_copyOf:
 409   case vmIntrinsics::_copyOfRange:
 410     if (!InlineObjectCopy)  return NULL;
 411     // These also use the arraycopy intrinsic mechanism:
 412     if (!InlineArrayCopy)  return NULL;
 413     break;
 414   case vmIntrinsics::_encodeISOArray:
 415     if (!SpecialEncodeISOArray)  return NULL;
 416     if (!Matcher::match_rule_supported(Op_EncodeISOArray))  return NULL;
 417     break;
 418   case vmIntrinsics::_checkIndex:
 419     // We do not intrinsify this.  The optimizer does fine with it.
 420     return NULL;
 421 
 422   case vmIntrinsics::_getCallerClass:

 423     if (!InlineReflectionGetCallerClass)  return NULL;
 424     if (SystemDictionary::reflect_CallerSensitive_klass() == NULL)  return NULL;
 425     break;
 426 
 427   case vmIntrinsics::_bitCount_i:
 428     if (!Matcher::match_rule_supported(Op_PopCountI)) return NULL;
 429     break;
 430 
 431   case vmIntrinsics::_bitCount_l:
 432     if (!Matcher::match_rule_supported(Op_PopCountL)) return NULL;
 433     break;
 434 
 435   case vmIntrinsics::_numberOfLeadingZeros_i:
 436     if (!Matcher::match_rule_supported(Op_CountLeadingZerosI)) return NULL;
 437     break;
 438 
 439   case vmIntrinsics::_numberOfLeadingZeros_l:
 440     if (!Matcher::match_rule_supported(Op_CountLeadingZerosL)) return NULL;
 441     break;
 442 

</pre><hr></hr>
</pre></td>
</tr></table>
</body></html>
