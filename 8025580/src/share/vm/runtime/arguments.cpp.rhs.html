<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 #include "classfile/javaAssertions.hpp"
  27 #include "classfile/symbolTable.hpp"
  28 #include "compiler/compilerOracle.hpp"
  29 #include "memory/allocation.inline.hpp"
  30 #include "memory/cardTableRS.hpp"
  31 #include "memory/genCollectedHeap.hpp"
  32 #include "memory/referenceProcessor.hpp"
  33 #include "memory/universe.inline.hpp"
  34 #include "oops/oop.inline.hpp"
  35 #include "prims/jvmtiExport.hpp"
  36 #include "runtime/arguments.hpp"
  37 #include "runtime/globals_extension.hpp"
  38 #include "runtime/java.hpp"
  39 #include "services/management.hpp"
  40 #include "services/memTracker.hpp"
  41 #include "utilities/defaultStream.hpp"
  42 #include "utilities/macros.hpp"
  43 #include "utilities/taskqueue.hpp"
  44 #ifdef TARGET_OS_FAMILY_linux
  45 # include "os_linux.inline.hpp"
  46 #endif
  47 #ifdef TARGET_OS_FAMILY_solaris
  48 # include "os_solaris.inline.hpp"
  49 #endif
  50 #ifdef TARGET_OS_FAMILY_windows
  51 # include "os_windows.inline.hpp"
  52 #endif
  53 #ifdef TARGET_OS_FAMILY_aix
  54 # include "os_aix.inline.hpp"
  55 #endif
  56 #ifdef TARGET_OS_FAMILY_bsd
  57 # include "os_bsd.inline.hpp"
  58 #endif
  59 #if INCLUDE_ALL_GCS
  60 #include "gc_implementation/concurrentMarkSweep/compactibleFreeListSpace.hpp"
  61 #include "gc_implementation/g1/g1CollectedHeap.inline.hpp"
  62 #include "gc_implementation/parallelScavenge/parallelScavengeHeap.hpp"
  63 #endif // INCLUDE_ALL_GCS
  64 
  65 // Note: This is a special bug reporting site for the JVM
  66 #define DEFAULT_VENDOR_URL_BUG "http://bugreport.sun.com/bugreport/crash.jsp"
  67 #define DEFAULT_JAVA_LAUNCHER  "generic"
  68 
  69 // Disable options not supported in this release, with a warning if they
  70 // were explicitly requested on the command-line
  71 #define UNSUPPORTED_OPTION(opt, description)                    \
  72 do {                                                            \
  73   if (opt) {                                                    \
  74     if (FLAG_IS_CMDLINE(opt)) {                                 \
  75       warning(description " is disabled in this release.");     \
  76     }                                                           \
  77     FLAG_SET_DEFAULT(opt, false);                               \
  78   }                                                             \
  79 } while(0)
  80 
  81 #define UNSUPPORTED_GC_OPTION(gc)                                     \
  82 do {                                                                  \
  83   if (gc) {                                                           \
  84     if (FLAG_IS_CMDLINE(gc)) {                                        \
  85       warning(#gc " is not supported in this VM.  Using Serial GC."); \
  86     }                                                                 \
  87     FLAG_SET_DEFAULT(gc, false);                                      \
  88   }                                                                   \
  89 } while(0)
  90 
  91 char**  Arguments::_jvm_flags_array             = NULL;
  92 int     Arguments::_num_jvm_flags               = 0;
  93 char**  Arguments::_jvm_args_array              = NULL;
  94 int     Arguments::_num_jvm_args                = 0;
  95 char*  Arguments::_java_command                 = NULL;
  96 SystemProperty* Arguments::_system_properties   = NULL;
  97 const char*  Arguments::_gc_log_filename        = NULL;
  98 bool   Arguments::_has_profile                  = false;
  99 size_t Arguments::_conservative_max_heap_alignment = 0;
 100 uintx  Arguments::_min_heap_size                = 0;
 101 Arguments::Mode Arguments::_mode                = _mixed;
 102 bool   Arguments::_java_compiler                = false;
 103 bool   Arguments::_xdebug_mode                  = false;
 104 const char*  Arguments::_java_vendor_url_bug    = DEFAULT_VENDOR_URL_BUG;
 105 const char*  Arguments::_sun_java_launcher      = DEFAULT_JAVA_LAUNCHER;
 106 int    Arguments::_sun_java_launcher_pid        = -1;
 107 bool   Arguments::_sun_java_launcher_is_altjvm  = false;
 108 
 109 // These parameters are reset in method parse_vm_init_args(JavaVMInitArgs*)
 110 bool   Arguments::_AlwaysCompileLoopMethods     = AlwaysCompileLoopMethods;
 111 bool   Arguments::_UseOnStackReplacement        = UseOnStackReplacement;
 112 bool   Arguments::_BackgroundCompilation        = BackgroundCompilation;
 113 bool   Arguments::_ClipInlining                 = ClipInlining;
 114 
 115 char*  Arguments::SharedArchivePath             = NULL;
 116 
 117 AgentLibraryList Arguments::_libraryList;
 118 AgentLibraryList Arguments::_agentList;
 119 
 120 abort_hook_t     Arguments::_abort_hook         = NULL;
 121 exit_hook_t      Arguments::_exit_hook          = NULL;
 122 vfprintf_hook_t  Arguments::_vfprintf_hook      = NULL;
 123 
 124 
 125 SystemProperty *Arguments::_java_ext_dirs = NULL;
 126 SystemProperty *Arguments::_java_endorsed_dirs = NULL;
 127 SystemProperty *Arguments::_sun_boot_library_path = NULL;
 128 SystemProperty *Arguments::_java_library_path = NULL;
 129 SystemProperty *Arguments::_java_home = NULL;
 130 SystemProperty *Arguments::_java_class_path = NULL;
 131 SystemProperty *Arguments::_sun_boot_class_path = NULL;
 132 
 133 char* Arguments::_meta_index_path = NULL;
 134 char* Arguments::_meta_index_dir = NULL;
 135 
 136 // Check if head of 'option' matches 'name', and sets 'tail' remaining part of option string
 137 
 138 static bool match_option(const JavaVMOption *option, const char* name,
 139                          const char** tail) {
 140   int len = (int)strlen(name);
 141   if (strncmp(option-&gt;optionString, name, len) == 0) {
 142     *tail = option-&gt;optionString + len;
 143     return true;
 144   } else {
 145     return false;
 146   }
 147 }
 148 
 149 static void logOption(const char* opt) {
 150   if (PrintVMOptions) {
 151     jio_fprintf(defaultStream::output_stream(), "VM option '%s'\n", opt);
 152   }
 153 }
 154 
 155 // Process java launcher properties.
 156 void Arguments::process_sun_java_launcher_properties(JavaVMInitArgs* args) {
 157   // See if sun.java.launcher, sun.java.launcher.is_altjvm or
 158   // sun.java.launcher.pid is defined.
 159   // Must do this before setting up other system properties,
 160   // as some of them may depend on launcher type.
 161   for (int index = 0; index &lt; args-&gt;nOptions; index++) {
 162     const JavaVMOption* option = args-&gt;options + index;
 163     const char* tail;
 164 
 165     if (match_option(option, "-Dsun.java.launcher=", &amp;tail)) {
 166       process_java_launcher_argument(tail, option-&gt;extraInfo);
 167       continue;
 168     }
 169     if (match_option(option, "-Dsun.java.launcher.is_altjvm=", &amp;tail)) {
 170       if (strcmp(tail, "true") == 0) {
 171         _sun_java_launcher_is_altjvm = true;
 172       }
 173       continue;
 174     }
 175     if (match_option(option, "-Dsun.java.launcher.pid=", &amp;tail)) {
 176       _sun_java_launcher_pid = atoi(tail);
 177       continue;
 178     }
 179   }
 180 }
 181 
 182 // Initialize system properties key and value.
 183 void Arguments::init_system_properties() {
 184 
 185   PropertyList_add(&amp;_system_properties, new SystemProperty("java.vm.specification.name",
 186                                                                  "Java Virtual Machine Specification",  false));
 187   PropertyList_add(&amp;_system_properties, new SystemProperty("java.vm.version", VM_Version::vm_release(),  false));
 188   PropertyList_add(&amp;_system_properties, new SystemProperty("java.vm.name", VM_Version::vm_name(),  false));
 189   PropertyList_add(&amp;_system_properties, new SystemProperty("java.vm.info", VM_Version::vm_info_string(),  true));
 190 
 191   // Following are JVMTI agent writable properties.
 192   // Properties values are set to NULL and they are
 193   // os specific they are initialized in os::init_system_properties_values().
 194   _java_ext_dirs = new SystemProperty("java.ext.dirs", NULL,  true);
 195   _java_endorsed_dirs = new SystemProperty("java.endorsed.dirs", NULL,  true);
 196   _sun_boot_library_path = new SystemProperty("sun.boot.library.path", NULL,  true);
 197   _java_library_path = new SystemProperty("java.library.path", NULL,  true);
 198   _java_home =  new SystemProperty("java.home", NULL,  true);
 199   _sun_boot_class_path = new SystemProperty("sun.boot.class.path", NULL,  true);
 200 
 201   _java_class_path = new SystemProperty("java.class.path", "",  true);
 202 
 203   // Add to System Property list.
 204   PropertyList_add(&amp;_system_properties, _java_ext_dirs);
 205   PropertyList_add(&amp;_system_properties, _java_endorsed_dirs);
 206   PropertyList_add(&amp;_system_properties, _sun_boot_library_path);
 207   PropertyList_add(&amp;_system_properties, _java_library_path);
 208   PropertyList_add(&amp;_system_properties, _java_home);
 209   PropertyList_add(&amp;_system_properties, _java_class_path);
 210   PropertyList_add(&amp;_system_properties, _sun_boot_class_path);
 211 
 212   // Set OS specific system properties values
 213   os::init_system_properties_values();
 214 }
 215 
 216 
 217   // Update/Initialize System properties after JDK version number is known
 218 void Arguments::init_version_specific_system_properties() {
 219   enum { bufsz = 16 };
 220   char buffer[bufsz];
 221   const char* spec_vendor = "Sun Microsystems Inc.";
 222   uint32_t spec_version = 0;
 223 
 224   if (JDK_Version::is_gte_jdk17x_version()) {
 225     spec_vendor = "Oracle Corporation";
 226     spec_version = JDK_Version::current().major_version();
 227   }
 228   jio_snprintf(buffer, bufsz, "1." UINT32_FORMAT, spec_version);
 229 
 230   PropertyList_add(&amp;_system_properties,
 231       new SystemProperty("java.vm.specification.vendor",  spec_vendor, false));
 232   PropertyList_add(&amp;_system_properties,
 233       new SystemProperty("java.vm.specification.version", buffer, false));
 234   PropertyList_add(&amp;_system_properties,
 235       new SystemProperty("java.vm.vendor", VM_Version::vm_vendor(),  false));
 236 }
 237 
 238 /**
 239  * Provide a slightly more user-friendly way of eliminating -XX flags.
 240  * When a flag is eliminated, it can be added to this list in order to
 241  * continue accepting this flag on the command-line, while issuing a warning
 242  * and ignoring the value.  Once the JDK version reaches the 'accept_until'
 243  * limit, we flatly refuse to admit the existence of the flag.  This allows
 244  * a flag to die correctly over JDK releases using HSX.
 245  */
 246 typedef struct {
 247   const char* name;
 248   JDK_Version obsoleted_in; // when the flag went away
 249   JDK_Version accept_until; // which version to start denying the existence
 250 } ObsoleteFlag;
 251 
 252 static ObsoleteFlag obsolete_jvm_flags[] = {
 253   { "UseTrainGC",                    JDK_Version::jdk(5), JDK_Version::jdk(7) },
 254   { "UseSpecialLargeObjectHandling", JDK_Version::jdk(5), JDK_Version::jdk(7) },
 255   { "UseOversizedCarHandling",       JDK_Version::jdk(5), JDK_Version::jdk(7) },
 256   { "TraceCarAllocation",            JDK_Version::jdk(5), JDK_Version::jdk(7) },
 257   { "PrintTrainGCProcessingStats",   JDK_Version::jdk(5), JDK_Version::jdk(7) },
 258   { "LogOfCarSpaceSize",             JDK_Version::jdk(5), JDK_Version::jdk(7) },
 259   { "OversizedCarThreshold",         JDK_Version::jdk(5), JDK_Version::jdk(7) },
 260   { "MinTickInterval",               JDK_Version::jdk(5), JDK_Version::jdk(7) },
 261   { "DefaultTickInterval",           JDK_Version::jdk(5), JDK_Version::jdk(7) },
 262   { "MaxTickInterval",               JDK_Version::jdk(5), JDK_Version::jdk(7) },
 263   { "DelayTickAdjustment",           JDK_Version::jdk(5), JDK_Version::jdk(7) },
 264   { "ProcessingToTenuringRatio",     JDK_Version::jdk(5), JDK_Version::jdk(7) },
 265   { "MinTrainLength",                JDK_Version::jdk(5), JDK_Version::jdk(7) },
 266   { "AppendRatio",         JDK_Version::jdk_update(6,10), JDK_Version::jdk(7) },
 267   { "DefaultMaxRAM",       JDK_Version::jdk_update(6,18), JDK_Version::jdk(7) },
 268   { "DefaultInitialRAMFraction",
 269                            JDK_Version::jdk_update(6,18), JDK_Version::jdk(7) },
 270   { "UseDepthFirstScavengeOrder",
 271                            JDK_Version::jdk_update(6,22), JDK_Version::jdk(7) },
 272   { "HandlePromotionFailure",
 273                            JDK_Version::jdk_update(6,24), JDK_Version::jdk(8) },
 274   { "MaxLiveObjectEvacuationRatio",
 275                            JDK_Version::jdk_update(6,24), JDK_Version::jdk(8) },
 276   { "ForceSharedSpaces",   JDK_Version::jdk_update(6,25), JDK_Version::jdk(8) },
 277   { "UseParallelOldGCCompacting",
 278                            JDK_Version::jdk_update(6,27), JDK_Version::jdk(8) },
 279   { "UseParallelDensePrefixUpdate",
 280                            JDK_Version::jdk_update(6,27), JDK_Version::jdk(8) },
 281   { "UseParallelOldGCDensePrefix",
 282                            JDK_Version::jdk_update(6,27), JDK_Version::jdk(8) },
 283   { "AllowTransitionalJSR292",       JDK_Version::jdk(7), JDK_Version::jdk(8) },
 284   { "UseCompressedStrings",          JDK_Version::jdk(7), JDK_Version::jdk(8) },
 285   { "CMSPermGenPrecleaningEnabled", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 286   { "CMSTriggerPermRatio", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 287   { "CMSInitiatingPermOccupancyFraction", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 288   { "AdaptivePermSizeWeight", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 289   { "PermGenPadding", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 290   { "PermMarkSweepDeadRatio", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 291   { "PermSize", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 292   { "MaxPermSize", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 293   { "MinPermHeapExpansion", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 294   { "MaxPermHeapExpansion", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 295   { "CMSRevisitStackSize",           JDK_Version::jdk(8), JDK_Version::jdk(9) },
 296   { "PrintRevisitStats",             JDK_Version::jdk(8), JDK_Version::jdk(9) },
 297   { "UseVectoredExceptions",         JDK_Version::jdk(8), JDK_Version::jdk(9) },
 298   { "UseSplitVerifier",              JDK_Version::jdk(8), JDK_Version::jdk(9) },
 299   { "UseISM",                        JDK_Version::jdk(8), JDK_Version::jdk(9) },
 300   { "UsePermISM",                    JDK_Version::jdk(8), JDK_Version::jdk(9) },
 301   { "UseMPSS",                       JDK_Version::jdk(8), JDK_Version::jdk(9) },
 302   { "UseStringCache",                JDK_Version::jdk(8), JDK_Version::jdk(9) },
 303   { "UseOldInlining",                JDK_Version::jdk(9), JDK_Version::jdk(10) },
 304   { "SafepointPollOffset",           JDK_Version::jdk(9), JDK_Version::jdk(10) },
 305 #ifdef PRODUCT
 306   { "DesiredMethodLimit",
 307                            JDK_Version::jdk_update(7, 2), JDK_Version::jdk(8) },
 308 #endif // PRODUCT
 309   { "UseVMInterruptibleIO",          JDK_Version::jdk(8), JDK_Version::jdk(9) },
 310   { "UseBoundThreads",               JDK_Version::jdk(9), JDK_Version::jdk(10) },
 311   { "DefaultThreadPriority",         JDK_Version::jdk(9), JDK_Version::jdk(10) },
 312   { "NoYieldsInMicrolock",           JDK_Version::jdk(9), JDK_Version::jdk(10) },
<a name="1" id="anc1"></a><span class="new"> 313   { "UseNewReflection",              JDK_Version::jdk(9), JDK_Version::jdk(10) },</span>
<span class="new"> 314   { "ReflectionWrapResolutionErrors",JDK_Version::jdk(9), JDK_Version::jdk(10) },</span>
 315   { NULL, JDK_Version(0), JDK_Version(0) }
 316 };
 317 
 318 // Returns true if the flag is obsolete and fits into the range specified
 319 // for being ignored.  In the case that the flag is ignored, the 'version'
 320 // value is filled in with the version number when the flag became
 321 // obsolete so that that value can be displayed to the user.
 322 bool Arguments::is_newly_obsolete(const char *s, JDK_Version* version) {
 323   int i = 0;
 324   assert(version != NULL, "Must provide a version buffer");
 325   while (obsolete_jvm_flags[i].name != NULL) {
 326     const ObsoleteFlag&amp; flag_status = obsolete_jvm_flags[i];
 327     // &lt;flag&gt;=xxx form
 328     // [-|+]&lt;flag&gt; form
 329     if ((strncmp(flag_status.name, s, strlen(flag_status.name)) == 0) ||
 330         ((s[0] == '+' || s[0] == '-') &amp;&amp;
 331         (strncmp(flag_status.name, &amp;s[1], strlen(flag_status.name)) == 0))) {
 332       if (JDK_Version::current().compare(flag_status.accept_until) == -1) {
 333           *version = flag_status.obsoleted_in;
 334           return true;
 335       }
 336     }
 337     i++;
 338   }
 339   return false;
 340 }
 341 
 342 // Constructs the system class path (aka boot class path) from the following
 343 // components, in order:
 344 //
 345 //     prefix           // from -Xbootclasspath/p:...
 346 //     endorsed         // the expansion of -Djava.endorsed.dirs=...
 347 //     base             // from os::get_system_properties() or -Xbootclasspath=
 348 //     suffix           // from -Xbootclasspath/a:...
 349 //
 350 // java.endorsed.dirs is a list of directories; any jar or zip files in the
 351 // directories are added to the sysclasspath just before the base.
 352 //
 353 // This could be AllStatic, but it isn't needed after argument processing is
 354 // complete.
 355 class SysClassPath: public StackObj {
 356 public:
 357   SysClassPath(const char* base);
 358   ~SysClassPath();
 359 
 360   inline void set_base(const char* base);
 361   inline void add_prefix(const char* prefix);
 362   inline void add_suffix_to_prefix(const char* suffix);
 363   inline void add_suffix(const char* suffix);
 364   inline void reset_path(const char* base);
 365 
 366   // Expand the jar/zip files in each directory listed by the java.endorsed.dirs
 367   // property.  Must be called after all command-line arguments have been
 368   // processed (in particular, -Djava.endorsed.dirs=...) and before calling
 369   // combined_path().
 370   void expand_endorsed();
 371 
 372   inline const char* get_base()     const { return _items[_scp_base]; }
 373   inline const char* get_prefix()   const { return _items[_scp_prefix]; }
 374   inline const char* get_suffix()   const { return _items[_scp_suffix]; }
 375   inline const char* get_endorsed() const { return _items[_scp_endorsed]; }
 376 
 377   // Combine all the components into a single c-heap-allocated string; caller
 378   // must free the string if/when no longer needed.
 379   char* combined_path();
 380 
 381 private:
 382   // Utility routines.
 383   static char* add_to_path(const char* path, const char* str, bool prepend);
 384   static char* add_jars_to_path(char* path, const char* directory);
 385 
 386   inline void reset_item_at(int index);
 387 
 388   // Array indices for the items that make up the sysclasspath.  All except the
 389   // base are allocated in the C heap and freed by this class.
 390   enum {
 391     _scp_prefix,        // from -Xbootclasspath/p:...
 392     _scp_endorsed,      // the expansion of -Djava.endorsed.dirs=...
 393     _scp_base,          // the default sysclasspath
 394     _scp_suffix,        // from -Xbootclasspath/a:...
 395     _scp_nitems         // the number of items, must be last.
 396   };
 397 
 398   const char* _items[_scp_nitems];
 399   DEBUG_ONLY(bool _expansion_done;)
 400 };
 401 
 402 SysClassPath::SysClassPath(const char* base) {
 403   memset(_items, 0, sizeof(_items));
 404   _items[_scp_base] = base;
 405   DEBUG_ONLY(_expansion_done = false;)
 406 }
 407 
 408 SysClassPath::~SysClassPath() {
 409   // Free everything except the base.
 410   for (int i = 0; i &lt; _scp_nitems; ++i) {
 411     if (i != _scp_base) reset_item_at(i);
 412   }
 413   DEBUG_ONLY(_expansion_done = false;)
 414 }
 415 
 416 inline void SysClassPath::set_base(const char* base) {
 417   _items[_scp_base] = base;
 418 }
 419 
 420 inline void SysClassPath::add_prefix(const char* prefix) {
 421   _items[_scp_prefix] = add_to_path(_items[_scp_prefix], prefix, true);
 422 }
 423 
 424 inline void SysClassPath::add_suffix_to_prefix(const char* suffix) {
 425   _items[_scp_prefix] = add_to_path(_items[_scp_prefix], suffix, false);
 426 }
 427 
 428 inline void SysClassPath::add_suffix(const char* suffix) {
 429   _items[_scp_suffix] = add_to_path(_items[_scp_suffix], suffix, false);
 430 }
 431 
 432 inline void SysClassPath::reset_item_at(int index) {
 433   assert(index &lt; _scp_nitems &amp;&amp; index != _scp_base, "just checking");
 434   if (_items[index] != NULL) {
 435     FREE_C_HEAP_ARRAY(char, _items[index], mtInternal);
 436     _items[index] = NULL;
 437   }
 438 }
 439 
 440 inline void SysClassPath::reset_path(const char* base) {
 441   // Clear the prefix and suffix.
 442   reset_item_at(_scp_prefix);
 443   reset_item_at(_scp_suffix);
 444   set_base(base);
 445 }
 446 
 447 //------------------------------------------------------------------------------
 448 
 449 void SysClassPath::expand_endorsed() {
 450   assert(_items[_scp_endorsed] == NULL, "can only be called once.");
 451 
 452   const char* path = Arguments::get_property("java.endorsed.dirs");
 453   if (path == NULL) {
 454     path = Arguments::get_endorsed_dir();
 455     assert(path != NULL, "no default for java.endorsed.dirs");
 456   }
 457 
 458   char* expanded_path = NULL;
 459   const char separator = *os::path_separator();
 460   const char* const end = path + strlen(path);
 461   while (path &lt; end) {
 462     const char* tmp_end = strchr(path, separator);
 463     if (tmp_end == NULL) {
 464       expanded_path = add_jars_to_path(expanded_path, path);
 465       path = end;
 466     } else {
 467       char* dirpath = NEW_C_HEAP_ARRAY(char, tmp_end - path + 1, mtInternal);
 468       memcpy(dirpath, path, tmp_end - path);
 469       dirpath[tmp_end - path] = '\0';
 470       expanded_path = add_jars_to_path(expanded_path, dirpath);
 471       FREE_C_HEAP_ARRAY(char, dirpath, mtInternal);
 472       path = tmp_end + 1;
 473     }
 474   }
 475   _items[_scp_endorsed] = expanded_path;
 476   DEBUG_ONLY(_expansion_done = true;)
 477 }
 478 
 479 // Combine the bootclasspath elements, some of which may be null, into a single
 480 // c-heap-allocated string.
 481 char* SysClassPath::combined_path() {
 482   assert(_items[_scp_base] != NULL, "empty default sysclasspath");
 483   assert(_expansion_done, "must call expand_endorsed() first.");
 484 
 485   size_t lengths[_scp_nitems];
 486   size_t total_len = 0;
 487 
 488   const char separator = *os::path_separator();
 489 
 490   // Get the lengths.
 491   int i;
 492   for (i = 0; i &lt; _scp_nitems; ++i) {
 493     if (_items[i] != NULL) {
 494       lengths[i] = strlen(_items[i]);
 495       // Include space for the separator char (or a NULL for the last item).
 496       total_len += lengths[i] + 1;
 497     }
 498   }
 499   assert(total_len &gt; 0, "empty sysclasspath not allowed");
 500 
 501   // Copy the _items to a single string.
 502   char* cp = NEW_C_HEAP_ARRAY(char, total_len, mtInternal);
 503   char* cp_tmp = cp;
 504   for (i = 0; i &lt; _scp_nitems; ++i) {
 505     if (_items[i] != NULL) {
 506       memcpy(cp_tmp, _items[i], lengths[i]);
 507       cp_tmp += lengths[i];
 508       *cp_tmp++ = separator;
 509     }
 510   }
 511   *--cp_tmp = '\0';     // Replace the extra separator.
 512   return cp;
 513 }
 514 
 515 // Note:  path must be c-heap-allocated (or NULL); it is freed if non-null.
 516 char*
 517 SysClassPath::add_to_path(const char* path, const char* str, bool prepend) {
 518   char *cp;
 519 
 520   assert(str != NULL, "just checking");
 521   if (path == NULL) {
 522     size_t len = strlen(str) + 1;
 523     cp = NEW_C_HEAP_ARRAY(char, len, mtInternal);
 524     memcpy(cp, str, len);                       // copy the trailing null
 525   } else {
 526     const char separator = *os::path_separator();
 527     size_t old_len = strlen(path);
 528     size_t str_len = strlen(str);
 529     size_t len = old_len + str_len + 2;
 530 
 531     if (prepend) {
 532       cp = NEW_C_HEAP_ARRAY(char, len, mtInternal);
 533       char* cp_tmp = cp;
 534       memcpy(cp_tmp, str, str_len);
 535       cp_tmp += str_len;
 536       *cp_tmp = separator;
 537       memcpy(++cp_tmp, path, old_len + 1);      // copy the trailing null
 538       FREE_C_HEAP_ARRAY(char, path, mtInternal);
 539     } else {
 540       cp = REALLOC_C_HEAP_ARRAY(char, path, len, mtInternal);
 541       char* cp_tmp = cp + old_len;
 542       *cp_tmp = separator;
 543       memcpy(++cp_tmp, str, str_len + 1);       // copy the trailing null
 544     }
 545   }
 546   return cp;
 547 }
 548 
 549 // Scan the directory and append any jar or zip files found to path.
 550 // Note:  path must be c-heap-allocated (or NULL); it is freed if non-null.
 551 char* SysClassPath::add_jars_to_path(char* path, const char* directory) {
 552   DIR* dir = os::opendir(directory);
 553   if (dir == NULL) return path;
 554 
 555   char dir_sep[2] = { '\0', '\0' };
 556   size_t directory_len = strlen(directory);
 557   const char fileSep = *os::file_separator();
 558   if (directory[directory_len - 1] != fileSep) dir_sep[0] = fileSep;
 559 
 560   /* Scan the directory for jars/zips, appending them to path. */
 561   struct dirent *entry;
 562   char *dbuf = NEW_C_HEAP_ARRAY(char, os::readdir_buf_size(directory), mtInternal);
 563   while ((entry = os::readdir(dir, (dirent *) dbuf)) != NULL) {
 564     const char* name = entry-&gt;d_name;
 565     const char* ext = name + strlen(name) - 4;
 566     bool isJarOrZip = ext &gt; name &amp;&amp;
 567       (os::file_name_strcmp(ext, ".jar") == 0 ||
 568        os::file_name_strcmp(ext, ".zip") == 0);
 569     if (isJarOrZip) {
 570       char* jarpath = NEW_C_HEAP_ARRAY(char, directory_len + 2 + strlen(name), mtInternal);
 571       sprintf(jarpath, "%s%s%s", directory, dir_sep, name);
 572       path = add_to_path(path, jarpath, false);
 573       FREE_C_HEAP_ARRAY(char, jarpath, mtInternal);
 574     }
 575   }
 576   FREE_C_HEAP_ARRAY(char, dbuf, mtInternal);
 577   os::closedir(dir);
 578   return path;
 579 }
 580 
 581 // Parses a memory size specification string.
 582 static bool atomull(const char *s, julong* result) {
 583   julong n = 0;
 584   int args_read = sscanf(s, JULONG_FORMAT, &amp;n);
 585   if (args_read != 1) {
 586     return false;
 587   }
 588   while (*s != '\0' &amp;&amp; isdigit(*s)) {
 589     s++;
 590   }
 591   // 4705540: illegal if more characters are found after the first non-digit
 592   if (strlen(s) &gt; 1) {
 593     return false;
 594   }
 595   switch (*s) {
 596     case 'T': case 't':
 597       *result = n * G * K;
 598       // Check for overflow.
 599       if (*result/((julong)G * K) != n) return false;
 600       return true;
 601     case 'G': case 'g':
 602       *result = n * G;
 603       if (*result/G != n) return false;
 604       return true;
 605     case 'M': case 'm':
 606       *result = n * M;
 607       if (*result/M != n) return false;
 608       return true;
 609     case 'K': case 'k':
 610       *result = n * K;
 611       if (*result/K != n) return false;
 612       return true;
 613     case '\0':
 614       *result = n;
 615       return true;
 616     default:
 617       return false;
 618   }
 619 }
 620 
 621 Arguments::ArgsRange Arguments::check_memory_size(julong size, julong min_size) {
 622   if (size &lt; min_size) return arg_too_small;
 623   // Check that size will fit in a size_t (only relevant on 32-bit)
 624   if (size &gt; max_uintx) return arg_too_big;
 625   return arg_in_range;
 626 }
 627 
 628 // Describe an argument out of range error
 629 void Arguments::describe_range_error(ArgsRange errcode) {
 630   switch(errcode) {
 631   case arg_too_big:
 632     jio_fprintf(defaultStream::error_stream(),
 633                 "The specified size exceeds the maximum "
 634                 "representable size.\n");
 635     break;
 636   case arg_too_small:
 637   case arg_unreadable:
 638   case arg_in_range:
 639     // do nothing for now
 640     break;
 641   default:
 642     ShouldNotReachHere();
 643   }
 644 }
 645 
 646 static bool set_bool_flag(char* name, bool value, Flag::Flags origin) {
 647   return CommandLineFlags::boolAtPut(name, &amp;value, origin);
 648 }
 649 
 650 static bool set_fp_numeric_flag(char* name, char* value, Flag::Flags origin) {
 651   double v;
 652   if (sscanf(value, "%lf", &amp;v) != 1) {
 653     return false;
 654   }
 655 
 656   if (CommandLineFlags::doubleAtPut(name, &amp;v, origin)) {
 657     return true;
 658   }
 659   return false;
 660 }
 661 
 662 static bool set_numeric_flag(char* name, char* value, Flag::Flags origin) {
 663   julong v;
 664   intx intx_v;
 665   bool is_neg = false;
 666   // Check the sign first since atomull() parses only unsigned values.
 667   if (*value == '-') {
 668     if (!CommandLineFlags::intxAt(name, &amp;intx_v)) {
 669       return false;
 670     }
 671     value++;
 672     is_neg = true;
 673   }
 674   if (!atomull(value, &amp;v)) {
 675     return false;
 676   }
 677   intx_v = (intx) v;
 678   if (is_neg) {
 679     intx_v = -intx_v;
 680   }
 681   if (CommandLineFlags::intxAtPut(name, &amp;intx_v, origin)) {
 682     return true;
 683   }
 684   uintx uintx_v = (uintx) v;
 685   if (!is_neg &amp;&amp; CommandLineFlags::uintxAtPut(name, &amp;uintx_v, origin)) {
 686     return true;
 687   }
 688   uint64_t uint64_t_v = (uint64_t) v;
 689   if (!is_neg &amp;&amp; CommandLineFlags::uint64_tAtPut(name, &amp;uint64_t_v, origin)) {
 690     return true;
 691   }
 692   return false;
 693 }
 694 
 695 static bool set_string_flag(char* name, const char* value, Flag::Flags origin) {
 696   if (!CommandLineFlags::ccstrAtPut(name, &amp;value, origin))  return false;
 697   // Contract:  CommandLineFlags always returns a pointer that needs freeing.
 698   FREE_C_HEAP_ARRAY(char, value, mtInternal);
 699   return true;
 700 }
 701 
 702 static bool append_to_string_flag(char* name, const char* new_value, Flag::Flags origin) {
 703   const char* old_value = "";
 704   if (!CommandLineFlags::ccstrAt(name, &amp;old_value))  return false;
 705   size_t old_len = old_value != NULL ? strlen(old_value) : 0;
 706   size_t new_len = strlen(new_value);
 707   const char* value;
 708   char* free_this_too = NULL;
 709   if (old_len == 0) {
 710     value = new_value;
 711   } else if (new_len == 0) {
 712     value = old_value;
 713   } else {
 714     char* buf = NEW_C_HEAP_ARRAY(char, old_len + 1 + new_len + 1, mtInternal);
 715     // each new setting adds another LINE to the switch:
 716     sprintf(buf, "%s\n%s", old_value, new_value);
 717     value = buf;
 718     free_this_too = buf;
 719   }
 720   (void) CommandLineFlags::ccstrAtPut(name, &amp;value, origin);
 721   // CommandLineFlags always returns a pointer that needs freeing.
 722   FREE_C_HEAP_ARRAY(char, value, mtInternal);
 723   if (free_this_too != NULL) {
 724     // CommandLineFlags made its own copy, so I must delete my own temp. buffer.
 725     FREE_C_HEAP_ARRAY(char, free_this_too, mtInternal);
 726   }
 727   return true;
 728 }
 729 
 730 bool Arguments::parse_argument(const char* arg, Flag::Flags origin) {
 731 
 732   // range of acceptable characters spelled out for portability reasons
 733 #define NAME_RANGE  "[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]"
 734 #define BUFLEN 255
 735   char name[BUFLEN+1];
 736   char dummy;
 737 
 738   if (sscanf(arg, "-%" XSTR(BUFLEN) NAME_RANGE "%c", name, &amp;dummy) == 1) {
 739     return set_bool_flag(name, false, origin);
 740   }
 741   if (sscanf(arg, "+%" XSTR(BUFLEN) NAME_RANGE "%c", name, &amp;dummy) == 1) {
 742     return set_bool_flag(name, true, origin);
 743   }
 744 
 745   char punct;
 746   if (sscanf(arg, "%" XSTR(BUFLEN) NAME_RANGE "%c", name, &amp;punct) == 2 &amp;&amp; punct == '=') {
 747     const char* value = strchr(arg, '=') + 1;
 748     Flag* flag = Flag::find_flag(name, strlen(name));
 749     if (flag != NULL &amp;&amp; flag-&gt;is_ccstr()) {
 750       if (flag-&gt;ccstr_accumulates()) {
 751         return append_to_string_flag(name, value, origin);
 752       } else {
 753         if (value[0] == '\0') {
 754           value = NULL;
 755         }
 756         return set_string_flag(name, value, origin);
 757       }
 758     }
 759   }
 760 
 761   if (sscanf(arg, "%" XSTR(BUFLEN) NAME_RANGE ":%c", name, &amp;punct) == 2 &amp;&amp; punct == '=') {
 762     const char* value = strchr(arg, '=') + 1;
 763     // -XX:Foo:=xxx will reset the string flag to the given value.
 764     if (value[0] == '\0') {
 765       value = NULL;
 766     }
 767     return set_string_flag(name, value, origin);
 768   }
 769 
 770 #define SIGNED_FP_NUMBER_RANGE "[-0123456789.]"
 771 #define SIGNED_NUMBER_RANGE    "[-0123456789]"
 772 #define        NUMBER_RANGE    "[0123456789]"
 773   char value[BUFLEN + 1];
 774   char value2[BUFLEN + 1];
 775   if (sscanf(arg, "%" XSTR(BUFLEN) NAME_RANGE "=" "%" XSTR(BUFLEN) SIGNED_NUMBER_RANGE "." "%" XSTR(BUFLEN) NUMBER_RANGE "%c", name, value, value2, &amp;dummy) == 3) {
 776     // Looks like a floating-point number -- try again with more lenient format string
 777     if (sscanf(arg, "%" XSTR(BUFLEN) NAME_RANGE "=" "%" XSTR(BUFLEN) SIGNED_FP_NUMBER_RANGE "%c", name, value, &amp;dummy) == 2) {
 778       return set_fp_numeric_flag(name, value, origin);
 779     }
 780   }
 781 
 782 #define VALUE_RANGE "[-kmgtKMGT0123456789]"
 783   if (sscanf(arg, "%" XSTR(BUFLEN) NAME_RANGE "=" "%" XSTR(BUFLEN) VALUE_RANGE "%c", name, value, &amp;dummy) == 2) {
 784     return set_numeric_flag(name, value, origin);
 785   }
 786 
 787   return false;
 788 }
 789 
 790 void Arguments::add_string(char*** bldarray, int* count, const char* arg) {
 791   assert(bldarray != NULL, "illegal argument");
 792 
 793   if (arg == NULL) {
 794     return;
 795   }
 796 
 797   int new_count = *count + 1;
 798 
 799   // expand the array and add arg to the last element
 800   if (*bldarray == NULL) {
 801     *bldarray = NEW_C_HEAP_ARRAY(char*, new_count, mtInternal);
 802   } else {
 803     *bldarray = REALLOC_C_HEAP_ARRAY(char*, *bldarray, new_count, mtInternal);
 804   }
 805   (*bldarray)[*count] = strdup(arg);
 806   *count = new_count;
 807 }
 808 
 809 void Arguments::build_jvm_args(const char* arg) {
 810   add_string(&amp;_jvm_args_array, &amp;_num_jvm_args, arg);
 811 }
 812 
 813 void Arguments::build_jvm_flags(const char* arg) {
 814   add_string(&amp;_jvm_flags_array, &amp;_num_jvm_flags, arg);
 815 }
 816 
 817 // utility function to return a string that concatenates all
 818 // strings in a given char** array
 819 const char* Arguments::build_resource_string(char** args, int count) {
 820   if (args == NULL || count == 0) {
 821     return NULL;
 822   }
 823   size_t length = strlen(args[0]) + 1; // add 1 for the null terminator
 824   for (int i = 1; i &lt; count; i++) {
 825     length += strlen(args[i]) + 1; // add 1 for a space
 826   }
 827   char* s = NEW_RESOURCE_ARRAY(char, length);
 828   strcpy(s, args[0]);
 829   for (int j = 1; j &lt; count; j++) {
 830     strcat(s, " ");
 831     strcat(s, args[j]);
 832   }
 833   return (const char*) s;
 834 }
 835 
 836 void Arguments::print_on(outputStream* st) {
 837   st-&gt;print_cr("VM Arguments:");
 838   if (num_jvm_flags() &gt; 0) {
 839     st-&gt;print("jvm_flags: "); print_jvm_flags_on(st);
 840   }
 841   if (num_jvm_args() &gt; 0) {
 842     st-&gt;print("jvm_args: "); print_jvm_args_on(st);
 843   }
 844   st-&gt;print_cr("java_command: %s", java_command() ? java_command() : "&lt;unknown&gt;");
 845   if (_java_class_path != NULL) {
 846     char* path = _java_class_path-&gt;value();
 847     st-&gt;print_cr("java_class_path (initial): %s", strlen(path) == 0 ? "&lt;not set&gt;" : path );
 848   }
 849   st-&gt;print_cr("Launcher Type: %s", _sun_java_launcher);
 850 }
 851 
 852 void Arguments::print_jvm_flags_on(outputStream* st) {
 853   if (_num_jvm_flags &gt; 0) {
 854     for (int i=0; i &lt; _num_jvm_flags; i++) {
 855       st-&gt;print("%s ", _jvm_flags_array[i]);
 856     }
 857     st-&gt;print_cr("");
 858   }
 859 }
 860 
 861 void Arguments::print_jvm_args_on(outputStream* st) {
 862   if (_num_jvm_args &gt; 0) {
 863     for (int i=0; i &lt; _num_jvm_args; i++) {
 864       st-&gt;print("%s ", _jvm_args_array[i]);
 865     }
 866     st-&gt;print_cr("");
 867   }
 868 }
 869 
 870 bool Arguments::process_argument(const char* arg,
 871     jboolean ignore_unrecognized, Flag::Flags origin) {
 872 
 873   JDK_Version since = JDK_Version();
 874 
 875   if (parse_argument(arg, origin) || ignore_unrecognized) {
 876     return true;
 877   }
 878 
 879   bool has_plus_minus = (*arg == '+' || *arg == '-');
 880   const char* const argname = has_plus_minus ? arg + 1 : arg;
 881   if (is_newly_obsolete(arg, &amp;since)) {
 882     char version[256];
 883     since.to_string(version, sizeof(version));
 884     warning("ignoring option %s; support was removed in %s", argname, version);
 885     return true;
 886   }
 887 
 888   // For locked flags, report a custom error message if available.
 889   // Otherwise, report the standard unrecognized VM option.
 890 
 891   size_t arg_len;
 892   const char* equal_sign = strchr(argname, '=');
 893   if (equal_sign == NULL) {
 894     arg_len = strlen(argname);
 895   } else {
 896     arg_len = equal_sign - argname;
 897   }
 898 
 899   Flag* found_flag = Flag::find_flag((const char*)argname, arg_len, true, true);
 900   if (found_flag != NULL) {
 901     char locked_message_buf[BUFLEN];
 902     found_flag-&gt;get_locked_message(locked_message_buf, BUFLEN);
 903     if (strlen(locked_message_buf) == 0) {
 904       if (found_flag-&gt;is_bool() &amp;&amp; !has_plus_minus) {
 905         jio_fprintf(defaultStream::error_stream(),
 906           "Missing +/- setting for VM option '%s'\n", argname);
 907       } else if (!found_flag-&gt;is_bool() &amp;&amp; has_plus_minus) {
 908         jio_fprintf(defaultStream::error_stream(),
 909           "Unexpected +/- setting in VM option '%s'\n", argname);
 910       } else {
 911         jio_fprintf(defaultStream::error_stream(),
 912           "Improperly specified VM option '%s'\n", argname);
 913       }
 914     } else {
 915       jio_fprintf(defaultStream::error_stream(), "%s", locked_message_buf);
 916     }
 917   } else {
 918     jio_fprintf(defaultStream::error_stream(),
 919                 "Unrecognized VM option '%s'\n", argname);
 920     Flag* fuzzy_matched = Flag::fuzzy_match((const char*)argname, arg_len, true);
 921     if (fuzzy_matched != NULL) {
 922       jio_fprintf(defaultStream::error_stream(),
 923                   "Did you mean '%s%s%s'?\n",
 924                   (fuzzy_matched-&gt;is_bool()) ? "(+/-)" : "",
 925                   fuzzy_matched-&gt;_name,
 926                   (fuzzy_matched-&gt;is_bool()) ? "" : "=&lt;value&gt;");
 927     }
 928   }
 929 
 930   // allow for commandline "commenting out" options like -XX:#+Verbose
 931   return arg[0] == '#';
 932 }
 933 
 934 bool Arguments::process_settings_file(const char* file_name, bool should_exist, jboolean ignore_unrecognized) {
 935   FILE* stream = fopen(file_name, "rb");
 936   if (stream == NULL) {
 937     if (should_exist) {
 938       jio_fprintf(defaultStream::error_stream(),
 939                   "Could not open settings file %s\n", file_name);
 940       return false;
 941     } else {
 942       return true;
 943     }
 944   }
 945 
 946   char token[1024];
 947   int  pos = 0;
 948 
 949   bool in_white_space = true;
 950   bool in_comment     = false;
 951   bool in_quote       = false;
 952   char quote_c        = 0;
 953   bool result         = true;
 954 
 955   int c = getc(stream);
 956   while(c != EOF &amp;&amp; pos &lt; (int)(sizeof(token)-1)) {
 957     if (in_white_space) {
 958       if (in_comment) {
 959         if (c == '\n') in_comment = false;
 960       } else {
 961         if (c == '#') in_comment = true;
 962         else if (!isspace(c)) {
 963           in_white_space = false;
 964           token[pos++] = c;
 965         }
 966       }
 967     } else {
 968       if (c == '\n' || (!in_quote &amp;&amp; isspace(c))) {
 969         // token ends at newline, or at unquoted whitespace
 970         // this allows a way to include spaces in string-valued options
 971         token[pos] = '\0';
 972         logOption(token);
 973         result &amp;= process_argument(token, ignore_unrecognized, Flag::CONFIG_FILE);
 974         build_jvm_flags(token);
 975         pos = 0;
 976         in_white_space = true;
 977         in_quote = false;
 978       } else if (!in_quote &amp;&amp; (c == '\'' || c == '"')) {
 979         in_quote = true;
 980         quote_c = c;
 981       } else if (in_quote &amp;&amp; (c == quote_c)) {
 982         in_quote = false;
 983       } else {
 984         token[pos++] = c;
 985       }
 986     }
 987     c = getc(stream);
 988   }
 989   if (pos &gt; 0) {
 990     token[pos] = '\0';
 991     result &amp;= process_argument(token, ignore_unrecognized, Flag::CONFIG_FILE);
 992     build_jvm_flags(token);
 993   }
 994   fclose(stream);
 995   return result;
 996 }
 997 
 998 //=============================================================================================================
 999 // Parsing of properties (-D)
1000 
1001 const char* Arguments::get_property(const char* key) {
1002   return PropertyList_get_value(system_properties(), key);
1003 }
1004 
1005 bool Arguments::add_property(const char* prop) {
1006   const char* eq = strchr(prop, '=');
1007   char* key;
1008   // ns must be static--its address may be stored in a SystemProperty object.
1009   const static char ns[1] = {0};
1010   char* value = (char *)ns;
1011 
1012   size_t key_len = (eq == NULL) ? strlen(prop) : (eq - prop);
1013   key = AllocateHeap(key_len + 1, mtInternal);
1014   strncpy(key, prop, key_len);
1015   key[key_len] = '\0';
1016 
1017   if (eq != NULL) {
1018     size_t value_len = strlen(prop) - key_len - 1;
1019     value = AllocateHeap(value_len + 1, mtInternal);
1020     strncpy(value, &amp;prop[key_len + 1], value_len + 1);
1021   }
1022 
1023   if (strcmp(key, "java.compiler") == 0) {
1024     process_java_compiler_argument(value);
1025     FreeHeap(key);
1026     if (eq != NULL) {
1027       FreeHeap(value);
1028     }
1029     return true;
1030   } else if (strcmp(key, "sun.java.command") == 0) {
1031     _java_command = value;
1032 
1033     // Record value in Arguments, but let it get passed to Java.
1034   } else if (strcmp(key, "sun.java.launcher.is_altjvm") == 0 ||
1035              strcmp(key, "sun.java.launcher.pid") == 0) {
1036     // sun.java.launcher.is_altjvm and sun.java.launcher.pid property are
1037     // private and are processed in process_sun_java_launcher_properties();
1038     // the sun.java.launcher property is passed on to the java application
1039     FreeHeap(key);
1040     if (eq != NULL) {
1041       FreeHeap(value);
1042     }
1043     return true;
1044   } else if (strcmp(key, "java.vendor.url.bug") == 0) {
1045     // save it in _java_vendor_url_bug, so JVM fatal error handler can access
1046     // its value without going through the property list or making a Java call.
1047     _java_vendor_url_bug = value;
1048   } else if (strcmp(key, "sun.boot.library.path") == 0) {
1049     PropertyList_unique_add(&amp;_system_properties, key, value, true);
1050     return true;
1051   }
1052   // Create new property and add at the end of the list
1053   PropertyList_unique_add(&amp;_system_properties, key, value);
1054   return true;
1055 }
1056 
1057 //===========================================================================================================
1058 // Setting int/mixed/comp mode flags
1059 
1060 void Arguments::set_mode_flags(Mode mode) {
1061   // Set up default values for all flags.
1062   // If you add a flag to any of the branches below,
1063   // add a default value for it here.
1064   set_java_compiler(false);
1065   _mode                      = mode;
1066 
1067   // Ensure Agent_OnLoad has the correct initial values.
1068   // This may not be the final mode; mode may change later in onload phase.
1069   PropertyList_unique_add(&amp;_system_properties, "java.vm.info",
1070                           (char*)VM_Version::vm_info_string(), false);
1071 
1072   UseInterpreter             = true;
1073   UseCompiler                = true;
1074   UseLoopCounter             = true;
1075 
1076 #ifndef ZERO
1077   // Turn these off for mixed and comp.  Leave them on for Zero.
1078   if (FLAG_IS_DEFAULT(UseFastAccessorMethods)) {
1079     UseFastAccessorMethods = (mode == _int);
1080   }
1081   if (FLAG_IS_DEFAULT(UseFastEmptyMethods)) {
1082     UseFastEmptyMethods = (mode == _int);
1083   }
1084 #endif
1085 
1086   // Default values may be platform/compiler dependent -
1087   // use the saved values
1088   ClipInlining               = Arguments::_ClipInlining;
1089   AlwaysCompileLoopMethods   = Arguments::_AlwaysCompileLoopMethods;
1090   UseOnStackReplacement      = Arguments::_UseOnStackReplacement;
1091   BackgroundCompilation      = Arguments::_BackgroundCompilation;
1092 
1093   // Change from defaults based on mode
1094   switch (mode) {
1095   default:
1096     ShouldNotReachHere();
1097     break;
1098   case _int:
1099     UseCompiler              = false;
1100     UseLoopCounter           = false;
1101     AlwaysCompileLoopMethods = false;
1102     UseOnStackReplacement    = false;
1103     break;
1104   case _mixed:
1105     // same as default
1106     break;
1107   case _comp:
1108     UseInterpreter           = false;
1109     BackgroundCompilation    = false;
1110     ClipInlining             = false;
1111     // Be much more aggressive in tiered mode with -Xcomp and exercise C2 more.
1112     // We will first compile a level 3 version (C1 with full profiling), then do one invocation of it and
1113     // compile a level 4 (C2) and then continue executing it.
1114     if (TieredCompilation) {
1115       Tier3InvokeNotifyFreqLog = 0;
1116       Tier4InvocationThreshold = 0;
1117     }
1118     break;
1119   }
1120 }
1121 
1122 #if defined(COMPILER2) || defined(_LP64) || !INCLUDE_CDS
1123 // Conflict: required to use shared spaces (-Xshare:on), but
1124 // incompatible command line options were chosen.
1125 
1126 static void no_shared_spaces() {
1127   if (RequireSharedSpaces) {
1128     jio_fprintf(defaultStream::error_stream(),
1129       "Class data sharing is inconsistent with other specified options.\n");
1130     vm_exit_during_initialization("Unable to use shared archive.", NULL);
1131   } else {
1132     FLAG_SET_DEFAULT(UseSharedSpaces, false);
1133   }
1134 }
1135 #endif
1136 
1137 void Arguments::set_tiered_flags() {
1138   // With tiered, set default policy to AdvancedThresholdPolicy, which is 3.
1139   if (FLAG_IS_DEFAULT(CompilationPolicyChoice)) {
1140     FLAG_SET_DEFAULT(CompilationPolicyChoice, 3);
1141   }
1142   if (CompilationPolicyChoice &lt; 2) {
1143     vm_exit_during_initialization(
1144       "Incompatible compilation policy selected", NULL);
1145   }
1146   // Increase the code cache size - tiered compiles a lot more.
1147   if (FLAG_IS_DEFAULT(ReservedCodeCacheSize)) {
1148     FLAG_SET_DEFAULT(ReservedCodeCacheSize, ReservedCodeCacheSize * 5);
1149   }
1150   if (!UseInterpreter) { // -Xcomp
1151     Tier3InvokeNotifyFreqLog = 0;
1152     Tier4InvocationThreshold = 0;
1153   }
1154 }
1155 
1156 #if INCLUDE_ALL_GCS
1157 static void disable_adaptive_size_policy(const char* collector_name) {
1158   if (UseAdaptiveSizePolicy) {
1159     if (FLAG_IS_CMDLINE(UseAdaptiveSizePolicy)) {
1160       warning("disabling UseAdaptiveSizePolicy; it is incompatible with %s.",
1161               collector_name);
1162     }
1163     FLAG_SET_DEFAULT(UseAdaptiveSizePolicy, false);
1164   }
1165 }
1166 
1167 void Arguments::set_parnew_gc_flags() {
1168   assert(!UseSerialGC &amp;&amp; !UseParallelOldGC &amp;&amp; !UseParallelGC &amp;&amp; !UseG1GC,
1169          "control point invariant");
1170   assert(UseParNewGC, "Error");
1171 
1172   // Turn off AdaptiveSizePolicy for parnew until it is complete.
1173   disable_adaptive_size_policy("UseParNewGC");
1174 
1175   if (FLAG_IS_DEFAULT(ParallelGCThreads)) {
1176     FLAG_SET_DEFAULT(ParallelGCThreads, Abstract_VM_Version::parallel_worker_threads());
1177     assert(ParallelGCThreads &gt; 0, "We should always have at least one thread by default");
1178   } else if (ParallelGCThreads == 0) {
1179     jio_fprintf(defaultStream::error_stream(),
1180         "The ParNew GC can not be combined with -XX:ParallelGCThreads=0\n");
1181     vm_exit(1);
1182   }
1183 
1184   // By default YoungPLABSize and OldPLABSize are set to 4096 and 1024 respectively,
1185   // these settings are default for Parallel Scavenger. For ParNew+Tenured configuration
1186   // we set them to 1024 and 1024.
1187   // See CR 6362902.
1188   if (FLAG_IS_DEFAULT(YoungPLABSize)) {
1189     FLAG_SET_DEFAULT(YoungPLABSize, (intx)1024);
1190   }
1191   if (FLAG_IS_DEFAULT(OldPLABSize)) {
1192     FLAG_SET_DEFAULT(OldPLABSize, (intx)1024);
1193   }
1194 
1195   // When using compressed oops, we use local overflow stacks,
1196   // rather than using a global overflow list chained through
1197   // the klass word of the object's pre-image.
1198   if (UseCompressedOops &amp;&amp; !ParGCUseLocalOverflow) {
1199     if (!FLAG_IS_DEFAULT(ParGCUseLocalOverflow)) {
1200       warning("Forcing +ParGCUseLocalOverflow: needed if using compressed references");
1201     }
1202     FLAG_SET_DEFAULT(ParGCUseLocalOverflow, true);
1203   }
1204   assert(ParGCUseLocalOverflow || !UseCompressedOops, "Error");
1205 }
1206 
1207 // Adjust some sizes to suit CMS and/or ParNew needs; these work well on
1208 // sparc/solaris for certain applications, but would gain from
1209 // further optimization and tuning efforts, and would almost
1210 // certainly gain from analysis of platform and environment.
1211 void Arguments::set_cms_and_parnew_gc_flags() {
1212   assert(!UseSerialGC &amp;&amp; !UseParallelOldGC &amp;&amp; !UseParallelGC, "Error");
1213   assert(UseConcMarkSweepGC, "CMS is expected to be on here");
1214 
1215   // If we are using CMS, we prefer to UseParNewGC,
1216   // unless explicitly forbidden.
1217   if (FLAG_IS_DEFAULT(UseParNewGC)) {
1218     FLAG_SET_ERGO(bool, UseParNewGC, true);
1219   }
1220 
1221   // Turn off AdaptiveSizePolicy by default for cms until it is complete.
1222   disable_adaptive_size_policy("UseConcMarkSweepGC");
1223 
1224   // In either case, adjust ParallelGCThreads and/or UseParNewGC
1225   // as needed.
1226   if (UseParNewGC) {
1227     set_parnew_gc_flags();
1228   }
1229 
1230   size_t max_heap = align_size_down(MaxHeapSize,
1231                                     CardTableRS::ct_max_alignment_constraint());
1232 
1233   // Now make adjustments for CMS
1234   intx   tenuring_default = (intx)6;
1235   size_t young_gen_per_worker = CMSYoungGenPerWorker;
1236 
1237   // Preferred young gen size for "short" pauses:
1238   // upper bound depends on # of threads and NewRatio.
1239   const uintx parallel_gc_threads =
1240     (ParallelGCThreads == 0 ? 1 : ParallelGCThreads);
1241   const size_t preferred_max_new_size_unaligned =
1242     MIN2(max_heap/(NewRatio+1), ScaleForWordSize(young_gen_per_worker * parallel_gc_threads));
1243   size_t preferred_max_new_size =
1244     align_size_up(preferred_max_new_size_unaligned, os::vm_page_size());
1245 
1246   // Unless explicitly requested otherwise, size young gen
1247   // for "short" pauses ~ CMSYoungGenPerWorker*ParallelGCThreads
1248 
1249   // If either MaxNewSize or NewRatio is set on the command line,
1250   // assume the user is trying to set the size of the young gen.
1251   if (FLAG_IS_DEFAULT(MaxNewSize) &amp;&amp; FLAG_IS_DEFAULT(NewRatio)) {
1252 
1253     // Set MaxNewSize to our calculated preferred_max_new_size unless
1254     // NewSize was set on the command line and it is larger than
1255     // preferred_max_new_size.
1256     if (!FLAG_IS_DEFAULT(NewSize)) {   // NewSize explicitly set at command-line
1257       FLAG_SET_ERGO(uintx, MaxNewSize, MAX2(NewSize, preferred_max_new_size));
1258     } else {
1259       FLAG_SET_ERGO(uintx, MaxNewSize, preferred_max_new_size);
1260     }
1261     if (PrintGCDetails &amp;&amp; Verbose) {
1262       // Too early to use gclog_or_tty
1263       tty-&gt;print_cr("CMS ergo set MaxNewSize: " SIZE_FORMAT, MaxNewSize);
1264     }
1265 
1266     // Code along this path potentially sets NewSize and OldSize
1267     if (PrintGCDetails &amp;&amp; Verbose) {
1268       // Too early to use gclog_or_tty
1269       tty-&gt;print_cr("CMS set min_heap_size: " SIZE_FORMAT
1270            " initial_heap_size:  " SIZE_FORMAT
1271            " max_heap: " SIZE_FORMAT,
1272            min_heap_size(), InitialHeapSize, max_heap);
1273     }
1274     size_t min_new = preferred_max_new_size;
1275     if (FLAG_IS_CMDLINE(NewSize)) {
1276       min_new = NewSize;
1277     }
1278     if (max_heap &gt; min_new &amp;&amp; min_heap_size() &gt; min_new) {
1279       // Unless explicitly requested otherwise, make young gen
1280       // at least min_new, and at most preferred_max_new_size.
1281       if (FLAG_IS_DEFAULT(NewSize)) {
1282         FLAG_SET_ERGO(uintx, NewSize, MAX2(NewSize, min_new));
1283         FLAG_SET_ERGO(uintx, NewSize, MIN2(preferred_max_new_size, NewSize));
1284         if (PrintGCDetails &amp;&amp; Verbose) {
1285           // Too early to use gclog_or_tty
1286           tty-&gt;print_cr("CMS ergo set NewSize: " SIZE_FORMAT, NewSize);
1287         }
1288       }
1289       // Unless explicitly requested otherwise, size old gen
1290       // so it's NewRatio x of NewSize.
1291       if (FLAG_IS_DEFAULT(OldSize)) {
1292         if (max_heap &gt; NewSize) {
1293           FLAG_SET_ERGO(uintx, OldSize, MIN2(NewRatio*NewSize, max_heap - NewSize));
1294           if (PrintGCDetails &amp;&amp; Verbose) {
1295             // Too early to use gclog_or_tty
1296             tty-&gt;print_cr("CMS ergo set OldSize: " SIZE_FORMAT, OldSize);
1297           }
1298         }
1299       }
1300     }
1301   }
1302   // Unless explicitly requested otherwise, definitely
1303   // promote all objects surviving "tenuring_default" scavenges.
1304   if (FLAG_IS_DEFAULT(MaxTenuringThreshold) &amp;&amp;
1305       FLAG_IS_DEFAULT(SurvivorRatio)) {
1306     FLAG_SET_ERGO(uintx, MaxTenuringThreshold, tenuring_default);
1307   }
1308   // If we decided above (or user explicitly requested)
1309   // `promote all' (via MaxTenuringThreshold := 0),
1310   // prefer minuscule survivor spaces so as not to waste
1311   // space for (non-existent) survivors
1312   if (FLAG_IS_DEFAULT(SurvivorRatio) &amp;&amp; MaxTenuringThreshold == 0) {
1313     FLAG_SET_ERGO(uintx, SurvivorRatio, MAX2((uintx)1024, SurvivorRatio));
1314   }
1315   // If OldPLABSize is set and CMSParPromoteBlocksToClaim is not,
1316   // set CMSParPromoteBlocksToClaim equal to OldPLABSize.
1317   // This is done in order to make ParNew+CMS configuration to work
1318   // with YoungPLABSize and OldPLABSize options.
1319   // See CR 6362902.
1320   if (!FLAG_IS_DEFAULT(OldPLABSize)) {
1321     if (FLAG_IS_DEFAULT(CMSParPromoteBlocksToClaim)) {
1322       // OldPLABSize is not the default value but CMSParPromoteBlocksToClaim
1323       // is.  In this situation let CMSParPromoteBlocksToClaim follow
1324       // the value (either from the command line or ergonomics) of
1325       // OldPLABSize.  Following OldPLABSize is an ergonomics decision.
1326       FLAG_SET_ERGO(uintx, CMSParPromoteBlocksToClaim, OldPLABSize);
1327     } else {
1328       // OldPLABSize and CMSParPromoteBlocksToClaim are both set.
1329       // CMSParPromoteBlocksToClaim is a collector-specific flag, so
1330       // we'll let it to take precedence.
1331       jio_fprintf(defaultStream::error_stream(),
1332                   "Both OldPLABSize and CMSParPromoteBlocksToClaim"
1333                   " options are specified for the CMS collector."
1334                   " CMSParPromoteBlocksToClaim will take precedence.\n");
1335     }
1336   }
1337   if (!FLAG_IS_DEFAULT(ResizeOldPLAB) &amp;&amp; !ResizeOldPLAB) {
1338     // OldPLAB sizing manually turned off: Use a larger default setting,
1339     // unless it was manually specified. This is because a too-low value
1340     // will slow down scavenges.
1341     if (FLAG_IS_DEFAULT(CMSParPromoteBlocksToClaim)) {
1342       FLAG_SET_ERGO(uintx, CMSParPromoteBlocksToClaim, 50); // default value before 6631166
1343     }
1344   }
1345   // Overwrite OldPLABSize which is the variable we will internally use everywhere.
1346   FLAG_SET_ERGO(uintx, OldPLABSize, CMSParPromoteBlocksToClaim);
1347   // If either of the static initialization defaults have changed, note this
1348   // modification.
1349   if (!FLAG_IS_DEFAULT(CMSParPromoteBlocksToClaim) || !FLAG_IS_DEFAULT(OldPLABWeight)) {
1350     CFLS_LAB::modify_initialization(OldPLABSize, OldPLABWeight);
1351   }
1352   if (PrintGCDetails &amp;&amp; Verbose) {
1353     tty-&gt;print_cr("MarkStackSize: %uk  MarkStackSizeMax: %uk",
1354       MarkStackSize / K, MarkStackSizeMax / K);
1355     tty-&gt;print_cr("ConcGCThreads: %u", ConcGCThreads);
1356   }
1357 }
1358 #endif // INCLUDE_ALL_GCS
1359 
1360 void set_object_alignment() {
1361   // Object alignment.
1362   assert(is_power_of_2(ObjectAlignmentInBytes), "ObjectAlignmentInBytes must be power of 2");
1363   MinObjAlignmentInBytes     = ObjectAlignmentInBytes;
1364   assert(MinObjAlignmentInBytes &gt;= HeapWordsPerLong * HeapWordSize, "ObjectAlignmentInBytes value is too small");
1365   MinObjAlignment            = MinObjAlignmentInBytes / HeapWordSize;
1366   assert(MinObjAlignmentInBytes == MinObjAlignment * HeapWordSize, "ObjectAlignmentInBytes value is incorrect");
1367   MinObjAlignmentInBytesMask = MinObjAlignmentInBytes - 1;
1368 
1369   LogMinObjAlignmentInBytes  = exact_log2(ObjectAlignmentInBytes);
1370   LogMinObjAlignment         = LogMinObjAlignmentInBytes - LogHeapWordSize;
1371 
1372   // Oop encoding heap max
1373   OopEncodingHeapMax = (uint64_t(max_juint) + 1) &lt;&lt; LogMinObjAlignmentInBytes;
1374 
1375 #if INCLUDE_ALL_GCS
1376   // Set CMS global values
1377   CompactibleFreeListSpace::set_cms_values();
1378 #endif // INCLUDE_ALL_GCS
1379 }
1380 
1381 bool verify_object_alignment() {
1382   // Object alignment.
1383   if (!is_power_of_2(ObjectAlignmentInBytes)) {
1384     jio_fprintf(defaultStream::error_stream(),
1385                 "error: ObjectAlignmentInBytes=%d must be power of 2\n",
1386                 (int)ObjectAlignmentInBytes);
1387     return false;
1388   }
1389   if ((int)ObjectAlignmentInBytes &lt; BytesPerLong) {
1390     jio_fprintf(defaultStream::error_stream(),
1391                 "error: ObjectAlignmentInBytes=%d must be greater or equal %d\n",
1392                 (int)ObjectAlignmentInBytes, BytesPerLong);
1393     return false;
1394   }
1395   // It does not make sense to have big object alignment
1396   // since a space lost due to alignment will be greater
1397   // then a saved space from compressed oops.
1398   if ((int)ObjectAlignmentInBytes &gt; 256) {
1399     jio_fprintf(defaultStream::error_stream(),
1400                 "error: ObjectAlignmentInBytes=%d must not be greater than 256\n",
1401                 (int)ObjectAlignmentInBytes);
1402     return false;
1403   }
1404   // In case page size is very small.
1405   if ((int)ObjectAlignmentInBytes &gt;= os::vm_page_size()) {
1406     jio_fprintf(defaultStream::error_stream(),
1407                 "error: ObjectAlignmentInBytes=%d must be less than page size %d\n",
1408                 (int)ObjectAlignmentInBytes, os::vm_page_size());
1409     return false;
1410   }
1411   return true;
1412 }
1413 
1414 uintx Arguments::max_heap_for_compressed_oops() {
1415   // Avoid sign flip.
1416   assert(OopEncodingHeapMax &gt; (uint64_t)os::vm_page_size(), "Unusual page size");
1417   // We need to fit both the NULL page and the heap into the memory budget, while
1418   // keeping alignment constraints of the heap. To guarantee the latter, as the
1419   // NULL page is located before the heap, we pad the NULL page to the conservative
1420   // maximum alignment that the GC may ever impose upon the heap.
1421   size_t displacement_due_to_null_page = align_size_up_(os::vm_page_size(),
1422                                                         _conservative_max_heap_alignment);
1423 
1424   LP64_ONLY(return OopEncodingHeapMax - displacement_due_to_null_page);
1425   NOT_LP64(ShouldNotReachHere(); return 0);
1426 }
1427 
1428 bool Arguments::should_auto_select_low_pause_collector() {
1429   if (UseAutoGCSelectPolicy &amp;&amp;
1430       !FLAG_IS_DEFAULT(MaxGCPauseMillis) &amp;&amp;
1431       (MaxGCPauseMillis &lt;= AutoGCSelectPauseMillis)) {
1432     if (PrintGCDetails) {
1433       // Cannot use gclog_or_tty yet.
1434       tty-&gt;print_cr("Automatic selection of the low pause collector"
1435        " based on pause goal of %d (ms)", MaxGCPauseMillis);
1436     }
1437     return true;
1438   }
1439   return false;
1440 }
1441 
1442 void Arguments::set_use_compressed_oops() {
1443 #ifndef ZERO
1444 #ifdef _LP64
1445   // MaxHeapSize is not set up properly at this point, but
1446   // the only value that can override MaxHeapSize if we are
1447   // to use UseCompressedOops is InitialHeapSize.
1448   size_t max_heap_size = MAX2(MaxHeapSize, InitialHeapSize);
1449 
1450   if (max_heap_size &lt;= max_heap_for_compressed_oops()) {
1451 #if !defined(COMPILER1) || defined(TIERED)
1452     if (FLAG_IS_DEFAULT(UseCompressedOops)) {
1453       FLAG_SET_ERGO(bool, UseCompressedOops, true);
1454     }
1455 #endif
1456 #ifdef _WIN64
1457     if (UseLargePages &amp;&amp; UseCompressedOops) {
1458       // Cannot allocate guard pages for implicit checks in indexed addressing
1459       // mode, when large pages are specified on windows.
1460       // This flag could be switched ON if narrow oop base address is set to 0,
1461       // see code in Universe::initialize_heap().
1462       Universe::set_narrow_oop_use_implicit_null_checks(false);
1463     }
1464 #endif //  _WIN64
1465   } else {
1466     if (UseCompressedOops &amp;&amp; !FLAG_IS_DEFAULT(UseCompressedOops)) {
1467       warning("Max heap size too large for Compressed Oops");
1468       FLAG_SET_DEFAULT(UseCompressedOops, false);
1469       FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1470     }
1471   }
1472 #endif // _LP64
1473 #endif // ZERO
1474 }
1475 
1476 
1477 // NOTE: set_use_compressed_klass_ptrs() must be called after calling
1478 // set_use_compressed_oops().
1479 void Arguments::set_use_compressed_klass_ptrs() {
1480 #ifndef ZERO
1481 #ifdef _LP64
1482   // UseCompressedOops must be on for UseCompressedClassPointers to be on.
1483   if (!UseCompressedOops) {
1484     if (UseCompressedClassPointers) {
1485       warning("UseCompressedClassPointers requires UseCompressedOops");
1486     }
1487     FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1488   } else {
1489     // Turn on UseCompressedClassPointers too
1490     if (FLAG_IS_DEFAULT(UseCompressedClassPointers)) {
1491       FLAG_SET_ERGO(bool, UseCompressedClassPointers, true);
1492     }
1493     // Check the CompressedClassSpaceSize to make sure we use compressed klass ptrs.
1494     if (UseCompressedClassPointers) {
1495       if (CompressedClassSpaceSize &gt; KlassEncodingMetaspaceMax) {
1496         warning("CompressedClassSpaceSize is too large for UseCompressedClassPointers");
1497         FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1498       }
1499     }
1500   }
1501 #endif // _LP64
1502 #endif // !ZERO
1503 }
1504 
1505 void Arguments::set_conservative_max_heap_alignment() {
1506   // The conservative maximum required alignment for the heap is the maximum of
1507   // the alignments imposed by several sources: any requirements from the heap
1508   // itself, the collector policy and the maximum page size we may run the VM
1509   // with.
1510   size_t heap_alignment = GenCollectedHeap::conservative_max_heap_alignment();
1511 #if INCLUDE_ALL_GCS
1512   if (UseParallelGC) {
1513     heap_alignment = ParallelScavengeHeap::conservative_max_heap_alignment();
1514   } else if (UseG1GC) {
1515     heap_alignment = G1CollectedHeap::conservative_max_heap_alignment();
1516   }
1517 #endif // INCLUDE_ALL_GCS
1518   _conservative_max_heap_alignment = MAX3(heap_alignment, os::max_page_size(),
1519     CollectorPolicy::compute_heap_alignment());
1520 }
1521 
1522 void Arguments::set_ergonomics_flags() {
1523 
1524   if (os::is_server_class_machine()) {
1525     // If no other collector is requested explicitly,
1526     // let the VM select the collector based on
1527     // machine class and automatic selection policy.
1528     if (!UseSerialGC &amp;&amp;
1529         !UseConcMarkSweepGC &amp;&amp;
1530         !UseG1GC &amp;&amp;
1531         !UseParNewGC &amp;&amp;
1532         FLAG_IS_DEFAULT(UseParallelGC)) {
1533       if (should_auto_select_low_pause_collector()) {
1534         FLAG_SET_ERGO(bool, UseConcMarkSweepGC, true);
1535       } else {
1536         FLAG_SET_ERGO(bool, UseParallelGC, true);
1537       }
1538     }
1539   }
1540 #ifdef COMPILER2
1541   // Shared spaces work fine with other GCs but causes bytecode rewriting
1542   // to be disabled, which hurts interpreter performance and decreases
1543   // server performance.  When -server is specified, keep the default off
1544   // unless it is asked for.  Future work: either add bytecode rewriting
1545   // at link time, or rewrite bytecodes in non-shared methods.
1546   if (!DumpSharedSpaces &amp;&amp; !RequireSharedSpaces &amp;&amp;
1547       (FLAG_IS_DEFAULT(UseSharedSpaces) || !UseSharedSpaces)) {
1548     no_shared_spaces();
1549   }
1550 #endif
1551 
1552   set_conservative_max_heap_alignment();
1553 
1554 #ifndef ZERO
1555 #ifdef _LP64
1556   set_use_compressed_oops();
1557 
1558   // set_use_compressed_klass_ptrs() must be called after calling
1559   // set_use_compressed_oops().
1560   set_use_compressed_klass_ptrs();
1561 
1562   // Also checks that certain machines are slower with compressed oops
1563   // in vm_version initialization code.
1564 #endif // _LP64
1565 #endif // !ZERO
1566 }
1567 
1568 void Arguments::set_parallel_gc_flags() {
1569   assert(UseParallelGC || UseParallelOldGC, "Error");
1570   // Enable ParallelOld unless it was explicitly disabled (cmd line or rc file).
1571   if (FLAG_IS_DEFAULT(UseParallelOldGC)) {
1572     FLAG_SET_DEFAULT(UseParallelOldGC, true);
1573   }
1574   FLAG_SET_DEFAULT(UseParallelGC, true);
1575 
1576   // If no heap maximum was requested explicitly, use some reasonable fraction
1577   // of the physical memory, up to a maximum of 1GB.
1578   FLAG_SET_DEFAULT(ParallelGCThreads,
1579                    Abstract_VM_Version::parallel_worker_threads());
1580   if (ParallelGCThreads == 0) {
1581     jio_fprintf(defaultStream::error_stream(),
1582         "The Parallel GC can not be combined with -XX:ParallelGCThreads=0\n");
1583     vm_exit(1);
1584   }
1585 
1586   if (UseAdaptiveSizePolicy) {
1587     // We don't want to limit adaptive heap sizing's freedom to adjust the heap
1588     // unless the user actually sets these flags.
1589     if (FLAG_IS_DEFAULT(MinHeapFreeRatio)) {
1590       FLAG_SET_DEFAULT(MinHeapFreeRatio, 0);
1591     }
1592     if (FLAG_IS_DEFAULT(MaxHeapFreeRatio)) {
1593       FLAG_SET_DEFAULT(MaxHeapFreeRatio, 100);
1594     }
1595   }
1596 
1597   // If InitialSurvivorRatio or MinSurvivorRatio were not specified, but the
1598   // SurvivorRatio has been set, reset their default values to SurvivorRatio +
1599   // 2.  By doing this we make SurvivorRatio also work for Parallel Scavenger.
1600   // See CR 6362902 for details.
1601   if (!FLAG_IS_DEFAULT(SurvivorRatio)) {
1602     if (FLAG_IS_DEFAULT(InitialSurvivorRatio)) {
1603        FLAG_SET_DEFAULT(InitialSurvivorRatio, SurvivorRatio + 2);
1604     }
1605     if (FLAG_IS_DEFAULT(MinSurvivorRatio)) {
1606       FLAG_SET_DEFAULT(MinSurvivorRatio, SurvivorRatio + 2);
1607     }
1608   }
1609 
1610   if (UseParallelOldGC) {
1611     // Par compact uses lower default values since they are treated as
1612     // minimums.  These are different defaults because of the different
1613     // interpretation and are not ergonomically set.
1614     if (FLAG_IS_DEFAULT(MarkSweepDeadRatio)) {
1615       FLAG_SET_DEFAULT(MarkSweepDeadRatio, 1);
1616     }
1617   }
1618 }
1619 
1620 void Arguments::set_g1_gc_flags() {
1621   assert(UseG1GC, "Error");
1622 #ifdef COMPILER1
1623   FastTLABRefill = false;
1624 #endif
1625   FLAG_SET_DEFAULT(ParallelGCThreads,
1626                      Abstract_VM_Version::parallel_worker_threads());
1627   if (ParallelGCThreads == 0) {
1628     FLAG_SET_DEFAULT(ParallelGCThreads,
1629                      Abstract_VM_Version::parallel_worker_threads());
1630   }
1631 
1632   // MarkStackSize will be set (if it hasn't been set by the user)
1633   // when concurrent marking is initialized.
1634   // Its value will be based upon the number of parallel marking threads.
1635   // But we do set the maximum mark stack size here.
1636   if (FLAG_IS_DEFAULT(MarkStackSizeMax)) {
1637     FLAG_SET_DEFAULT(MarkStackSizeMax, 128 * TASKQUEUE_SIZE);
1638   }
1639 
1640   if (FLAG_IS_DEFAULT(GCTimeRatio) || GCTimeRatio == 0) {
1641     // In G1, we want the default GC overhead goal to be higher than
1642     // say in PS. So we set it here to 10%. Otherwise the heap might
1643     // be expanded more aggressively than we would like it to. In
1644     // fact, even 10% seems to not be high enough in some cases
1645     // (especially small GC stress tests that the main thing they do
1646     // is allocation). We might consider increase it further.
1647     FLAG_SET_DEFAULT(GCTimeRatio, 9);
1648   }
1649 
1650   if (PrintGCDetails &amp;&amp; Verbose) {
1651     tty-&gt;print_cr("MarkStackSize: %uk  MarkStackSizeMax: %uk",
1652       MarkStackSize / K, MarkStackSizeMax / K);
1653     tty-&gt;print_cr("ConcGCThreads: %u", ConcGCThreads);
1654   }
1655 }
1656 
1657 julong Arguments::limit_by_allocatable_memory(julong limit) {
1658   julong max_allocatable;
1659   julong result = limit;
1660   if (os::has_allocatable_memory_limit(&amp;max_allocatable)) {
1661     result = MIN2(result, max_allocatable / MaxVirtMemFraction);
1662   }
1663   return result;
1664 }
1665 
1666 // Use static initialization to get the default before parsing
1667 static const uintx DefaultHeapBaseMinAddress = HeapBaseMinAddress;
1668 
1669 void Arguments::set_heap_size() {
1670   if (!FLAG_IS_DEFAULT(DefaultMaxRAMFraction)) {
1671     // Deprecated flag
1672     FLAG_SET_CMDLINE(uintx, MaxRAMFraction, DefaultMaxRAMFraction);
1673   }
1674 
1675   const julong phys_mem =
1676     FLAG_IS_DEFAULT(MaxRAM) ? MIN2(os::physical_memory(), (julong)MaxRAM)
1677                             : (julong)MaxRAM;
1678 
1679   // If the maximum heap size has not been set with -Xmx,
1680   // then set it as fraction of the size of physical memory,
1681   // respecting the maximum and minimum sizes of the heap.
1682   if (FLAG_IS_DEFAULT(MaxHeapSize)) {
1683     julong reasonable_max = phys_mem / MaxRAMFraction;
1684 
1685     if (phys_mem &lt;= MaxHeapSize * MinRAMFraction) {
1686       // Small physical memory, so use a minimum fraction of it for the heap
1687       reasonable_max = phys_mem / MinRAMFraction;
1688     } else {
1689       // Not-small physical memory, so require a heap at least
1690       // as large as MaxHeapSize
1691       reasonable_max = MAX2(reasonable_max, (julong)MaxHeapSize);
1692     }
1693     if (!FLAG_IS_DEFAULT(ErgoHeapSizeLimit) &amp;&amp; ErgoHeapSizeLimit != 0) {
1694       // Limit the heap size to ErgoHeapSizeLimit
1695       reasonable_max = MIN2(reasonable_max, (julong)ErgoHeapSizeLimit);
1696     }
1697     if (UseCompressedOops) {
1698       // Limit the heap size to the maximum possible when using compressed oops
1699       julong max_coop_heap = (julong)max_heap_for_compressed_oops();
1700 
1701       // HeapBaseMinAddress can be greater than default but not less than.
1702       if (!FLAG_IS_DEFAULT(HeapBaseMinAddress)) {
1703         if (HeapBaseMinAddress &lt; DefaultHeapBaseMinAddress) {
1704           // matches compressed oops printing flags
1705           if (PrintCompressedOopsMode || (PrintMiscellaneous &amp;&amp; Verbose)) {
1706             jio_fprintf(defaultStream::error_stream(),
1707                         "HeapBaseMinAddress must be at least " UINTX_FORMAT
1708                         " (" UINTX_FORMAT "G) which is greater than value given "
1709                         UINTX_FORMAT "\n",
1710                         DefaultHeapBaseMinAddress,
1711                         DefaultHeapBaseMinAddress/G,
1712                         HeapBaseMinAddress);
1713           }
1714           FLAG_SET_ERGO(uintx, HeapBaseMinAddress, DefaultHeapBaseMinAddress);
1715         }
1716       }
1717 
1718       if (HeapBaseMinAddress + MaxHeapSize &lt; max_coop_heap) {
1719         // Heap should be above HeapBaseMinAddress to get zero based compressed oops
1720         // but it should be not less than default MaxHeapSize.
1721         max_coop_heap -= HeapBaseMinAddress;
1722       }
1723       reasonable_max = MIN2(reasonable_max, max_coop_heap);
1724     }
1725     reasonable_max = limit_by_allocatable_memory(reasonable_max);
1726 
1727     if (!FLAG_IS_DEFAULT(InitialHeapSize)) {
1728       // An initial heap size was specified on the command line,
1729       // so be sure that the maximum size is consistent.  Done
1730       // after call to limit_by_allocatable_memory because that
1731       // method might reduce the allocation size.
1732       reasonable_max = MAX2(reasonable_max, (julong)InitialHeapSize);
1733     }
1734 
1735     if (PrintGCDetails &amp;&amp; Verbose) {
1736       // Cannot use gclog_or_tty yet.
1737       tty-&gt;print_cr("  Maximum heap size " SIZE_FORMAT, reasonable_max);
1738     }
1739     FLAG_SET_ERGO(uintx, MaxHeapSize, (uintx)reasonable_max);
1740   }
1741 
1742   // If the minimum or initial heap_size have not been set or requested to be set
1743   // ergonomically, set them accordingly.
1744   if (InitialHeapSize == 0 || min_heap_size() == 0) {
1745     julong reasonable_minimum = (julong)(OldSize + NewSize);
1746 
1747     reasonable_minimum = MIN2(reasonable_minimum, (julong)MaxHeapSize);
1748 
1749     reasonable_minimum = limit_by_allocatable_memory(reasonable_minimum);
1750 
1751     if (InitialHeapSize == 0) {
1752       julong reasonable_initial = phys_mem / InitialRAMFraction;
1753 
1754       reasonable_initial = MAX3(reasonable_initial, reasonable_minimum, (julong)min_heap_size());
1755       reasonable_initial = MIN2(reasonable_initial, (julong)MaxHeapSize);
1756 
1757       reasonable_initial = limit_by_allocatable_memory(reasonable_initial);
1758 
1759       if (PrintGCDetails &amp;&amp; Verbose) {
1760         // Cannot use gclog_or_tty yet.
1761         tty-&gt;print_cr("  Initial heap size " SIZE_FORMAT, (uintx)reasonable_initial);
1762       }
1763       FLAG_SET_ERGO(uintx, InitialHeapSize, (uintx)reasonable_initial);
1764     }
1765     // If the minimum heap size has not been set (via -Xms),
1766     // synchronize with InitialHeapSize to avoid errors with the default value.
1767     if (min_heap_size() == 0) {
1768       set_min_heap_size(MIN2((uintx)reasonable_minimum, InitialHeapSize));
1769       if (PrintGCDetails &amp;&amp; Verbose) {
1770         // Cannot use gclog_or_tty yet.
1771         tty-&gt;print_cr("  Minimum heap size " SIZE_FORMAT, min_heap_size());
1772       }
1773     }
1774   }
1775 }
1776 
1777 // This must be called after ergonomics because we want bytecode rewriting
1778 // if the server compiler is used, or if UseSharedSpaces is disabled.
1779 void Arguments::set_bytecode_flags() {
1780   // Better not attempt to store into a read-only space.
1781   if (UseSharedSpaces) {
1782     FLAG_SET_DEFAULT(RewriteBytecodes, false);
1783     FLAG_SET_DEFAULT(RewriteFrequentPairs, false);
1784   }
1785 
1786   if (!RewriteBytecodes) {
1787     FLAG_SET_DEFAULT(RewriteFrequentPairs, false);
1788   }
1789 }
1790 
1791 // Aggressive optimization flags  -XX:+AggressiveOpts
1792 void Arguments::set_aggressive_opts_flags() {
1793 #ifdef COMPILER2
1794   if (AggressiveUnboxing) {
1795     if (FLAG_IS_DEFAULT(EliminateAutoBox)) {
1796       FLAG_SET_DEFAULT(EliminateAutoBox, true);
1797     } else if (!EliminateAutoBox) {
1798       // warning("AggressiveUnboxing is disabled because EliminateAutoBox is disabled");
1799       AggressiveUnboxing = false;
1800     }
1801     if (FLAG_IS_DEFAULT(DoEscapeAnalysis)) {
1802       FLAG_SET_DEFAULT(DoEscapeAnalysis, true);
1803     } else if (!DoEscapeAnalysis) {
1804       // warning("AggressiveUnboxing is disabled because DoEscapeAnalysis is disabled");
1805       AggressiveUnboxing = false;
1806     }
1807   }
1808   if (AggressiveOpts || !FLAG_IS_DEFAULT(AutoBoxCacheMax)) {
1809     if (FLAG_IS_DEFAULT(EliminateAutoBox)) {
1810       FLAG_SET_DEFAULT(EliminateAutoBox, true);
1811     }
1812     if (FLAG_IS_DEFAULT(AutoBoxCacheMax)) {
1813       FLAG_SET_DEFAULT(AutoBoxCacheMax, 20000);
1814     }
1815 
1816     // Feed the cache size setting into the JDK
1817     char buffer[1024];
1818     sprintf(buffer, "java.lang.Integer.IntegerCache.high=" INTX_FORMAT, AutoBoxCacheMax);
1819     add_property(buffer);
1820   }
1821   if (AggressiveOpts &amp;&amp; FLAG_IS_DEFAULT(BiasedLockingStartupDelay)) {
1822     FLAG_SET_DEFAULT(BiasedLockingStartupDelay, 500);
1823   }
1824 #endif
1825 
1826   if (AggressiveOpts) {
1827 // Sample flag setting code
1828 //    if (FLAG_IS_DEFAULT(EliminateZeroing)) {
1829 //      FLAG_SET_DEFAULT(EliminateZeroing, true);
1830 //    }
1831   }
1832 }
1833 
1834 //===========================================================================================================
1835 // Parsing of java.compiler property
1836 
1837 void Arguments::process_java_compiler_argument(char* arg) {
1838   // For backwards compatibility, Djava.compiler=NONE or ""
1839   // causes us to switch to -Xint mode UNLESS -Xdebug
1840   // is also specified.
1841   if (strlen(arg) == 0 || strcasecmp(arg, "NONE") == 0) {
1842     set_java_compiler(true);    // "-Djava.compiler[=...]" most recently seen.
1843   }
1844 }
1845 
1846 void Arguments::process_java_launcher_argument(const char* launcher, void* extra_info) {
1847   _sun_java_launcher = strdup(launcher);
1848 }
1849 
1850 bool Arguments::created_by_java_launcher() {
1851   assert(_sun_java_launcher != NULL, "property must have value");
1852   return strcmp(DEFAULT_JAVA_LAUNCHER, _sun_java_launcher) != 0;
1853 }
1854 
1855 bool Arguments::sun_java_launcher_is_altjvm() {
1856   return _sun_java_launcher_is_altjvm;
1857 }
1858 
1859 //===========================================================================================================
1860 // Parsing of main arguments
1861 
1862 bool Arguments::verify_interval(uintx val, uintx min,
1863                                 uintx max, const char* name) {
1864   // Returns true iff value is in the inclusive interval [min..max]
1865   // false, otherwise.
1866   if (val &gt;= min &amp;&amp; val &lt;= max) {
1867     return true;
1868   }
1869   jio_fprintf(defaultStream::error_stream(),
1870               "%s of " UINTX_FORMAT " is invalid; must be between " UINTX_FORMAT
1871               " and " UINTX_FORMAT "\n",
1872               name, val, min, max);
1873   return false;
1874 }
1875 
1876 bool Arguments::verify_min_value(intx val, intx min, const char* name) {
1877   // Returns true if given value is at least specified min threshold
1878   // false, otherwise.
1879   if (val &gt;= min ) {
1880       return true;
1881   }
1882   jio_fprintf(defaultStream::error_stream(),
1883               "%s of " INTX_FORMAT " is invalid; must be at least " INTX_FORMAT "\n",
1884               name, val, min);
1885   return false;
1886 }
1887 
1888 bool Arguments::verify_percentage(uintx value, const char* name) {
1889   if (is_percentage(value)) {
1890     return true;
1891   }
1892   jio_fprintf(defaultStream::error_stream(),
1893               "%s of " UINTX_FORMAT " is invalid; must be between 0 and 100\n",
1894               name, value);
1895   return false;
1896 }
1897 
1898 #if !INCLUDE_ALL_GCS
1899 #ifdef ASSERT
1900 static bool verify_serial_gc_flags() {
1901   return (UseSerialGC &amp;&amp;
1902         !(UseParNewGC || (UseConcMarkSweepGC || CMSIncrementalMode) || UseG1GC ||
1903           UseParallelGC || UseParallelOldGC));
1904 }
1905 #endif // ASSERT
1906 #endif // INCLUDE_ALL_GCS
1907 
1908 // check if do gclog rotation
1909 // +UseGCLogFileRotation is a must,
1910 // no gc log rotation when log file not supplied or
1911 // NumberOfGCLogFiles is 0
1912 void check_gclog_consistency() {
1913   if (UseGCLogFileRotation) {
1914     if ((Arguments::gc_log_filename() == NULL) || (NumberOfGCLogFiles == 0)) {
1915       jio_fprintf(defaultStream::output_stream(),
1916                   "To enable GC log rotation, use -Xloggc:&lt;filename&gt; -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=&lt;num_of_files&gt;\n"
1917                   "where num_of_file &gt; 0\n"
1918                   "GC log rotation is turned off\n");
1919       UseGCLogFileRotation = false;
1920     }
1921   }
1922 
1923   if (UseGCLogFileRotation &amp;&amp; (GCLogFileSize != 0) &amp;&amp; (GCLogFileSize &lt; 8*K)) {
1924     FLAG_SET_CMDLINE(uintx, GCLogFileSize, 8*K);
1925     jio_fprintf(defaultStream::output_stream(),
1926                 "GCLogFileSize changed to minimum 8K\n");
1927   }
1928 }
1929 
1930 // This function is called for -Xloggc:&lt;filename&gt;, it can be used
1931 // to check if a given file name(or string) conforms to the following
1932 // specification:
1933 // A valid string only contains "[A-Z][a-z][0-9].-_%[p|t]"
1934 // %p and %t only allowed once. We only limit usage of filename not path
1935 bool is_filename_valid(const char *file_name) {
1936   const char* p = file_name;
1937   char file_sep = os::file_separator()[0];
1938   const char* cp;
1939   // skip prefix path
1940   for (cp = file_name; *cp != '\0'; cp++) {
1941     if (*cp == '/' || *cp == file_sep) {
1942       p = cp + 1;
1943     }
1944   }
1945 
1946   int count_p = 0;
1947   int count_t = 0;
1948   while (*p != '\0') {
1949     if ((*p &gt;= '0' &amp;&amp; *p &lt;= '9') ||
1950         (*p &gt;= 'A' &amp;&amp; *p &lt;= 'Z') ||
1951         (*p &gt;= 'a' &amp;&amp; *p &lt;= 'z') ||
1952          *p == '-'               ||
1953          *p == '_'               ||
1954          *p == '.') {
1955        p++;
1956        continue;
1957     }
1958     if (*p == '%') {
1959       if(*(p + 1) == 'p') {
1960         p += 2;
1961         count_p ++;
1962         continue;
1963       }
1964       if (*(p + 1) == 't') {
1965         p += 2;
1966         count_t ++;
1967         continue;
1968       }
1969     }
1970     return false;
1971   }
1972   return count_p &lt; 2 &amp;&amp; count_t &lt; 2;
1973 }
1974 
1975 bool Arguments::verify_MinHeapFreeRatio(FormatBuffer&lt;80&gt;&amp; err_msg, uintx min_heap_free_ratio) {
1976   if (!is_percentage(min_heap_free_ratio)) {
1977     err_msg.print("MinHeapFreeRatio must have a value between 0 and 100");
1978     return false;
1979   }
1980   if (min_heap_free_ratio &gt; MaxHeapFreeRatio) {
1981     err_msg.print("MinHeapFreeRatio (" UINTX_FORMAT ") must be less than or "
1982                   "equal to MaxHeapFreeRatio (" UINTX_FORMAT ")", min_heap_free_ratio,
1983                   MaxHeapFreeRatio);
1984     return false;
1985   }
1986   return true;
1987 }
1988 
1989 bool Arguments::verify_MaxHeapFreeRatio(FormatBuffer&lt;80&gt;&amp; err_msg, uintx max_heap_free_ratio) {
1990   if (!is_percentage(max_heap_free_ratio)) {
1991     err_msg.print("MaxHeapFreeRatio must have a value between 0 and 100");
1992     return false;
1993   }
1994   if (max_heap_free_ratio &lt; MinHeapFreeRatio) {
1995     err_msg.print("MaxHeapFreeRatio (" UINTX_FORMAT ") must be greater than or "
1996                   "equal to MinHeapFreeRatio (" UINTX_FORMAT ")", max_heap_free_ratio,
1997                   MinHeapFreeRatio);
1998     return false;
1999   }
2000   return true;
2001 }
2002 
2003 // Check consistency of GC selection
2004 bool Arguments::check_gc_consistency() {
2005   check_gclog_consistency();
2006   bool status = true;
2007   // Ensure that the user has not selected conflicting sets
2008   // of collectors. [Note: this check is merely a user convenience;
2009   // collectors over-ride each other so that only a non-conflicting
2010   // set is selected; however what the user gets is not what they
2011   // may have expected from the combination they asked for. It's
2012   // better to reduce user confusion by not allowing them to
2013   // select conflicting combinations.
2014   uint i = 0;
2015   if (UseSerialGC)                       i++;
2016   if (UseConcMarkSweepGC || UseParNewGC) i++;
2017   if (UseParallelGC || UseParallelOldGC) i++;
2018   if (UseG1GC)                           i++;
2019   if (i &gt; 1) {
2020     jio_fprintf(defaultStream::error_stream(),
2021                 "Conflicting collector combinations in option list; "
2022                 "please refer to the release notes for the combinations "
2023                 "allowed\n");
2024     status = false;
2025   }
2026   return status;
2027 }
2028 
2029 void Arguments::check_deprecated_gcs() {
2030   if (UseConcMarkSweepGC &amp;&amp; !UseParNewGC) {
2031     warning("Using the DefNew young collector with the CMS collector is deprecated "
2032         "and will likely be removed in a future release");
2033   }
2034 
2035   if (UseParNewGC &amp;&amp; !UseConcMarkSweepGC) {
2036     // !UseConcMarkSweepGC means that we are using serial old gc. Unfortunately we don't
2037     // set up UseSerialGC properly, so that can't be used in the check here.
2038     warning("Using the ParNew young collector with the Serial old collector is deprecated "
2039         "and will likely be removed in a future release");
2040   }
2041 
2042   if (CMSIncrementalMode) {
2043     warning("Using incremental CMS is deprecated and will likely be removed in a future release");
2044   }
2045 }
2046 
2047 void Arguments::check_deprecated_gc_flags() {
2048   if (FLAG_IS_CMDLINE(MaxGCMinorPauseMillis)) {
2049     warning("Using MaxGCMinorPauseMillis as minor pause goal is deprecated"
2050             "and will likely be removed in future release");
2051   }
2052   if (FLAG_IS_CMDLINE(DefaultMaxRAMFraction)) {
2053     warning("DefaultMaxRAMFraction is deprecated and will likely be removed in a future release. "
2054         "Use MaxRAMFraction instead.");
2055   }
2056   if (FLAG_IS_CMDLINE(UseCMSCompactAtFullCollection)) {
2057     warning("UseCMSCompactAtFullCollection is deprecated and will likely be removed in a future release.");
2058   }
2059   if (FLAG_IS_CMDLINE(CMSFullGCsBeforeCompaction)) {
2060     warning("CMSFullGCsBeforeCompaction is deprecated and will likely be removed in a future release.");
2061   }
2062   if (FLAG_IS_CMDLINE(UseCMSCollectionPassing)) {
2063     warning("UseCMSCollectionPassing is deprecated and will likely be removed in a future release.");
2064   }
2065 }
2066 
2067 // Check stack pages settings
2068 bool Arguments::check_stack_pages()
2069 {
2070   bool status = true;
2071   status = status &amp;&amp; verify_min_value(StackYellowPages, 1, "StackYellowPages");
2072   status = status &amp;&amp; verify_min_value(StackRedPages, 1, "StackRedPages");
2073   // greater stack shadow pages can't generate instruction to bang stack
2074   status = status &amp;&amp; verify_interval(StackShadowPages, 1, 50, "StackShadowPages");
2075   return status;
2076 }
2077 
2078 // Check the consistency of vm_init_args
2079 bool Arguments::check_vm_args_consistency() {
2080   // Method for adding checks for flag consistency.
2081   // The intent is to warn the user of all possible conflicts,
2082   // before returning an error.
2083   // Note: Needs platform-dependent factoring.
2084   bool status = true;
2085 
2086   if (TLABRefillWasteFraction == 0) {
2087     jio_fprintf(defaultStream::error_stream(),
2088                 "TLABRefillWasteFraction should be a denominator, "
2089                 "not " SIZE_FORMAT "\n",
2090                 TLABRefillWasteFraction);
2091     status = false;
2092   }
2093 
2094   status = status &amp;&amp; verify_interval(AdaptiveSizePolicyWeight, 0, 100,
2095                               "AdaptiveSizePolicyWeight");
2096   status = status &amp;&amp; verify_percentage(ThresholdTolerance, "ThresholdTolerance");
2097 
2098   // Divide by bucket size to prevent a large size from causing rollover when
2099   // calculating amount of memory needed to be allocated for the String table.
2100   status = status &amp;&amp; verify_interval(StringTableSize, minimumStringTableSize,
2101     (max_uintx / StringTable::bucket_size()), "StringTable size");
2102 
2103   status = status &amp;&amp; verify_interval(SymbolTableSize, minimumSymbolTableSize,
2104     (max_uintx / SymbolTable::bucket_size()), "SymbolTable size");
2105 
2106   {
2107     // Using "else if" below to avoid printing two error messages if min &gt; max.
2108     // This will also prevent us from reporting both min&gt;100 and max&gt;100 at the
2109     // same time, but that is less annoying than printing two identical errors IMHO.
2110     FormatBuffer&lt;80&gt; err_msg("");
2111     if (!verify_MinHeapFreeRatio(err_msg, MinHeapFreeRatio)) {
2112       jio_fprintf(defaultStream::error_stream(), "%s\n", err_msg.buffer());
2113       status = false;
2114     } else if (!verify_MaxHeapFreeRatio(err_msg, MaxHeapFreeRatio)) {
2115       jio_fprintf(defaultStream::error_stream(), "%s\n", err_msg.buffer());
2116       status = false;
2117     }
2118   }
2119 
2120   // Min/MaxMetaspaceFreeRatio
2121   status = status &amp;&amp; verify_percentage(MinMetaspaceFreeRatio, "MinMetaspaceFreeRatio");
2122   status = status &amp;&amp; verify_percentage(MaxMetaspaceFreeRatio, "MaxMetaspaceFreeRatio");
2123 
2124   if (MinMetaspaceFreeRatio &gt; MaxMetaspaceFreeRatio) {
2125     jio_fprintf(defaultStream::error_stream(),
2126                 "MinMetaspaceFreeRatio (%s" UINTX_FORMAT ") must be less than or "
2127                 "equal to MaxMetaspaceFreeRatio (%s" UINTX_FORMAT ")\n",
2128                 FLAG_IS_DEFAULT(MinMetaspaceFreeRatio) ? "Default: " : "",
2129                 MinMetaspaceFreeRatio,
2130                 FLAG_IS_DEFAULT(MaxMetaspaceFreeRatio) ? "Default: " : "",
2131                 MaxMetaspaceFreeRatio);
2132     status = false;
2133   }
2134 
2135   // Trying to keep 100% free is not practical
2136   MinMetaspaceFreeRatio = MIN2(MinMetaspaceFreeRatio, (uintx) 99);
2137 
2138   if (FullGCALot &amp;&amp; FLAG_IS_DEFAULT(MarkSweepAlwaysCompactCount)) {
2139     MarkSweepAlwaysCompactCount = 1;  // Move objects every gc.
2140   }
2141 
2142   if (UseParallelOldGC &amp;&amp; ParallelOldGCSplitALot) {
2143     // Settings to encourage splitting.
2144     if (!FLAG_IS_CMDLINE(NewRatio)) {
2145       FLAG_SET_CMDLINE(uintx, NewRatio, 2);
2146     }
2147     if (!FLAG_IS_CMDLINE(ScavengeBeforeFullGC)) {
2148       FLAG_SET_CMDLINE(bool, ScavengeBeforeFullGC, false);
2149     }
2150   }
2151 
2152   status = status &amp;&amp; verify_percentage(GCHeapFreeLimit, "GCHeapFreeLimit");
2153   status = status &amp;&amp; verify_percentage(GCTimeLimit, "GCTimeLimit");
2154   if (GCTimeLimit == 100) {
2155     // Turn off gc-overhead-limit-exceeded checks
2156     FLAG_SET_DEFAULT(UseGCOverheadLimit, false);
2157   }
2158 
2159   status = status &amp;&amp; check_gc_consistency();
2160   status = status &amp;&amp; check_stack_pages();
2161 
2162   if (CMSIncrementalMode) {
2163     if (!UseConcMarkSweepGC) {
2164       jio_fprintf(defaultStream::error_stream(),
2165                   "error:  invalid argument combination.\n"
2166                   "The CMS collector (-XX:+UseConcMarkSweepGC) must be "
2167                   "selected in order\nto use CMSIncrementalMode.\n");
2168       status = false;
2169     } else {
2170       status = status &amp;&amp; verify_percentage(CMSIncrementalDutyCycle,
2171                                   "CMSIncrementalDutyCycle");
2172       status = status &amp;&amp; verify_percentage(CMSIncrementalDutyCycleMin,
2173                                   "CMSIncrementalDutyCycleMin");
2174       status = status &amp;&amp; verify_percentage(CMSIncrementalSafetyFactor,
2175                                   "CMSIncrementalSafetyFactor");
2176       status = status &amp;&amp; verify_percentage(CMSIncrementalOffset,
2177                                   "CMSIncrementalOffset");
2178       status = status &amp;&amp; verify_percentage(CMSExpAvgFactor,
2179                                   "CMSExpAvgFactor");
2180       // If it was not set on the command line, set
2181       // CMSInitiatingOccupancyFraction to 1 so icms can initiate cycles early.
2182       if (CMSInitiatingOccupancyFraction &lt; 0) {
2183         FLAG_SET_DEFAULT(CMSInitiatingOccupancyFraction, 1);
2184       }
2185     }
2186   }
2187 
2188   // CMS space iteration, which FLSVerifyAllHeapreferences entails,
2189   // insists that we hold the requisite locks so that the iteration is
2190   // MT-safe. For the verification at start-up and shut-down, we don't
2191   // yet have a good way of acquiring and releasing these locks,
2192   // which are not visible at the CollectedHeap level. We want to
2193   // be able to acquire these locks and then do the iteration rather
2194   // than just disable the lock verification. This will be fixed under
2195   // bug 4788986.
2196   if (UseConcMarkSweepGC &amp;&amp; FLSVerifyAllHeapReferences) {
2197     if (VerifyDuringStartup) {
2198       warning("Heap verification at start-up disabled "
2199               "(due to current incompatibility with FLSVerifyAllHeapReferences)");
2200       VerifyDuringStartup = false; // Disable verification at start-up
2201     }
2202 
2203     if (VerifyBeforeExit) {
2204       warning("Heap verification at shutdown disabled "
2205               "(due to current incompatibility with FLSVerifyAllHeapReferences)");
2206       VerifyBeforeExit = false; // Disable verification at shutdown
2207     }
2208   }
2209 
2210   // Note: only executed in non-PRODUCT mode
2211   if (!UseAsyncConcMarkSweepGC &amp;&amp;
2212       (ExplicitGCInvokesConcurrent ||
2213        ExplicitGCInvokesConcurrentAndUnloadsClasses)) {
2214     jio_fprintf(defaultStream::error_stream(),
2215                 "error: +ExplicitGCInvokesConcurrent[AndUnloadsClasses] conflicts"
2216                 " with -UseAsyncConcMarkSweepGC");
2217     status = false;
2218   }
2219 
2220   status = status &amp;&amp; verify_min_value(ParGCArrayScanChunk, 1, "ParGCArrayScanChunk");
2221 
2222 #if INCLUDE_ALL_GCS
2223   if (UseG1GC) {
2224     status = status &amp;&amp; verify_percentage(G1NewSizePercent, "G1NewSizePercent");
2225     status = status &amp;&amp; verify_percentage(G1MaxNewSizePercent, "G1MaxNewSizePercent");
2226     status = status &amp;&amp; verify_interval(G1NewSizePercent, 0, G1MaxNewSizePercent, "G1NewSizePercent");
2227 
2228     status = status &amp;&amp; verify_percentage(InitiatingHeapOccupancyPercent,
2229                                          "InitiatingHeapOccupancyPercent");
2230     status = status &amp;&amp; verify_min_value(G1RefProcDrainInterval, 1,
2231                                         "G1RefProcDrainInterval");
2232     status = status &amp;&amp; verify_min_value((intx)G1ConcMarkStepDurationMillis, 1,
2233                                         "G1ConcMarkStepDurationMillis");
2234     status = status &amp;&amp; verify_interval(G1ConcRSHotCardLimit, 0, max_jubyte,
2235                                        "G1ConcRSHotCardLimit");
2236     status = status &amp;&amp; verify_interval(G1ConcRSLogCacheSize, 0, 31,
2237                                        "G1ConcRSLogCacheSize");
2238     status = status &amp;&amp; verify_interval(StringDeduplicationAgeThreshold, 1, markOopDesc::max_age,
2239                                        "StringDeduplicationAgeThreshold");
2240   }
2241   if (UseConcMarkSweepGC) {
2242     status = status &amp;&amp; verify_min_value(CMSOldPLABNumRefills, 1, "CMSOldPLABNumRefills");
2243     status = status &amp;&amp; verify_min_value(CMSOldPLABToleranceFactor, 1, "CMSOldPLABToleranceFactor");
2244     status = status &amp;&amp; verify_min_value(CMSOldPLABMax, 1, "CMSOldPLABMax");
2245     status = status &amp;&amp; verify_interval(CMSOldPLABMin, 1, CMSOldPLABMax, "CMSOldPLABMin");
2246 
2247     status = status &amp;&amp; verify_min_value(CMSYoungGenPerWorker, 1, "CMSYoungGenPerWorker");
2248 
2249     status = status &amp;&amp; verify_min_value(CMSSamplingGrain, 1, "CMSSamplingGrain");
2250     status = status &amp;&amp; verify_interval(CMS_SweepWeight, 0, 100, "CMS_SweepWeight");
2251     status = status &amp;&amp; verify_interval(CMS_FLSWeight, 0, 100, "CMS_FLSWeight");
2252 
2253     status = status &amp;&amp; verify_interval(FLSCoalescePolicy, 0, 4, "FLSCoalescePolicy");
2254 
2255     status = status &amp;&amp; verify_min_value(CMSRescanMultiple, 1, "CMSRescanMultiple");
2256     status = status &amp;&amp; verify_min_value(CMSConcMarkMultiple, 1, "CMSConcMarkMultiple");
2257 
2258     status = status &amp;&amp; verify_interval(CMSPrecleanIter, 0, 9, "CMSPrecleanIter");
2259     status = status &amp;&amp; verify_min_value(CMSPrecleanDenominator, 1, "CMSPrecleanDenominator");
2260     status = status &amp;&amp; verify_interval(CMSPrecleanNumerator, 0, CMSPrecleanDenominator - 1, "CMSPrecleanNumerator");
2261 
2262     status = status &amp;&amp; verify_percentage(CMSBootstrapOccupancy, "CMSBootstrapOccupancy");
2263 
2264     status = status &amp;&amp; verify_min_value(CMSPrecleanThreshold, 100, "CMSPrecleanThreshold");
2265 
2266     status = status &amp;&amp; verify_percentage(CMSScheduleRemarkEdenPenetration, "CMSScheduleRemarkEdenPenetration");
2267     status = status &amp;&amp; verify_min_value(CMSScheduleRemarkSamplingRatio, 1, "CMSScheduleRemarkSamplingRatio");
2268     status = status &amp;&amp; verify_min_value(CMSBitMapYieldQuantum, 1, "CMSBitMapYieldQuantum");
2269     status = status &amp;&amp; verify_percentage(CMSTriggerRatio, "CMSTriggerRatio");
2270     status = status &amp;&amp; verify_percentage(CMSIsTooFullPercentage, "CMSIsTooFullPercentage");
2271   }
2272 
2273   if (UseParallelGC || UseParallelOldGC) {
2274     status = status &amp;&amp; verify_interval(ParallelOldDeadWoodLimiterMean, 0, 100, "ParallelOldDeadWoodLimiterMean");
2275     status = status &amp;&amp; verify_interval(ParallelOldDeadWoodLimiterStdDev, 0, 100, "ParallelOldDeadWoodLimiterStdDev");
2276 
2277     status = status &amp;&amp; verify_percentage(YoungGenerationSizeIncrement, "YoungGenerationSizeIncrement");
2278     status = status &amp;&amp; verify_percentage(TenuredGenerationSizeIncrement, "TenuredGenerationSizeIncrement");
2279 
2280     status = status &amp;&amp; verify_min_value(YoungGenerationSizeSupplementDecay, 1, "YoungGenerationSizeSupplementDecay");
2281     status = status &amp;&amp; verify_min_value(TenuredGenerationSizeSupplementDecay, 1, "TenuredGenerationSizeSupplementDecay");
2282 
2283     status = status &amp;&amp; verify_min_value(ParGCCardsPerStrideChunk, 1, "ParGCCardsPerStrideChunk");
2284 
2285     status = status &amp;&amp; verify_min_value(ParallelOldGCSplitInterval, 0, "ParallelOldGCSplitInterval");
2286   }
2287 #endif // INCLUDE_ALL_GCS
2288 
2289   status = status &amp;&amp; verify_interval(RefDiscoveryPolicy,
2290                                      ReferenceProcessor::DiscoveryPolicyMin,
2291                                      ReferenceProcessor::DiscoveryPolicyMax,
2292                                      "RefDiscoveryPolicy");
2293 
2294   // Limit the lower bound of this flag to 1 as it is used in a division
2295   // expression.
2296   status = status &amp;&amp; verify_interval(TLABWasteTargetPercent,
2297                                      1, 100, "TLABWasteTargetPercent");
2298 
2299   status = status &amp;&amp; verify_object_alignment();
2300 
2301   status = status &amp;&amp; verify_interval(CompressedClassSpaceSize, 1*M, 3*G,
2302                                       "CompressedClassSpaceSize");
2303 
2304   status = status &amp;&amp; verify_interval(MarkStackSizeMax,
2305                                   1, (max_jint - 1), "MarkStackSizeMax");
2306   status = status &amp;&amp; verify_interval(NUMAChunkResizeWeight, 0, 100, "NUMAChunkResizeWeight");
2307 
2308   status = status &amp;&amp; verify_min_value(LogEventsBufferEntries, 1, "LogEventsBufferEntries");
2309 
2310   status = status &amp;&amp; verify_min_value(HeapSizePerGCThread, (uintx) os::vm_page_size(), "HeapSizePerGCThread");
2311 
2312   status = status &amp;&amp; verify_min_value(GCTaskTimeStampEntries, 1, "GCTaskTimeStampEntries");
2313 
2314   status = status &amp;&amp; verify_percentage(ParallelGCBufferWastePct, "ParallelGCBufferWastePct");
2315   status = status &amp;&amp; verify_interval(TargetPLABWastePct, 1, 100, "TargetPLABWastePct");
2316 
2317   status = status &amp;&amp; verify_min_value(ParGCStridesPerThread, 1, "ParGCStridesPerThread");
2318 
2319   status = status &amp;&amp; verify_min_value(MinRAMFraction, 1, "MinRAMFraction");
2320   status = status &amp;&amp; verify_min_value(InitialRAMFraction, 1, "InitialRAMFraction");
2321   status = status &amp;&amp; verify_min_value(MaxRAMFraction, 1, "MaxRAMFraction");
2322   status = status &amp;&amp; verify_min_value(DefaultMaxRAMFraction, 1, "DefaultMaxRAMFraction");
2323 
2324   status = status &amp;&amp; verify_interval(AdaptiveTimeWeight, 0, 100, "AdaptiveTimeWeight");
2325   status = status &amp;&amp; verify_min_value(AdaptiveSizeDecrementScaleFactor, 1, "AdaptiveSizeDecrementScaleFactor");
2326 
2327   status = status &amp;&amp; verify_interval(TLABAllocationWeight, 0, 100, "TLABAllocationWeight");
2328   status = status &amp;&amp; verify_min_value(MinTLABSize, 1, "MinTLABSize");
2329   status = status &amp;&amp; verify_min_value(TLABRefillWasteFraction, 1, "TLABRefillWasteFraction");
2330 
2331   status = status &amp;&amp; verify_percentage(YoungGenerationSizeSupplement, "YoungGenerationSizeSupplement");
2332   status = status &amp;&amp; verify_percentage(TenuredGenerationSizeSupplement, "TenuredGenerationSizeSupplement");
2333 
2334   status = status &amp;&amp; verify_interval(MaxTenuringThreshold, 0, markOopDesc::max_age + 1, "MaxTenuringThreshold");
2335   status = status &amp;&amp; verify_interval(InitialTenuringThreshold, 0, MaxTenuringThreshold, "InitialTenuringThreshold");
2336   status = status &amp;&amp; verify_percentage(TargetSurvivorRatio, "TargetSurvivorRatio");
2337   status = status &amp;&amp; verify_percentage(MarkSweepDeadRatio, "MarkSweepDeadRatio");
2338 
2339   status = status &amp;&amp; verify_min_value(MarkSweepAlwaysCompactCount, 1, "MarkSweepAlwaysCompactCount");
2340 
2341   if (PrintNMTStatistics) {
2342 #if INCLUDE_NMT
2343     if (MemTracker::tracking_level() == MemTracker::NMT_off) {
2344 #endif // INCLUDE_NMT
2345       warning("PrintNMTStatistics is disabled, because native memory tracking is not enabled");
2346       PrintNMTStatistics = false;
2347 #if INCLUDE_NMT
2348     }
2349 #endif
2350   }
2351 
2352   // Need to limit the extent of the padding to reasonable size.
2353   // 8K is well beyond the reasonable HW cache line size, even with the
2354   // aggressive prefetching, while still leaving the room for segregating
2355   // among the distinct pages.
2356   if (ContendedPaddingWidth &lt; 0 || ContendedPaddingWidth &gt; 8192) {
2357     jio_fprintf(defaultStream::error_stream(),
2358                 "ContendedPaddingWidth=" INTX_FORMAT " must be in between %d and %d\n",
2359                 ContendedPaddingWidth, 0, 8192);
2360     status = false;
2361   }
2362 
2363   // Need to enforce the padding not to break the existing field alignments.
2364   // It is sufficient to check against the largest type size.
2365   if ((ContendedPaddingWidth % BytesPerLong) != 0) {
2366     jio_fprintf(defaultStream::error_stream(),
2367                 "ContendedPaddingWidth=" INTX_FORMAT " must be a multiple of %d\n",
2368                 ContendedPaddingWidth, BytesPerLong);
2369     status = false;
2370   }
2371 
2372   // Check lower bounds of the code cache
2373   // Template Interpreter code is approximately 3X larger in debug builds.
2374   uint min_code_cache_size = (CodeCacheMinimumUseSpace DEBUG_ONLY(* 3)) + CodeCacheMinimumFreeSpace;
2375   if (InitialCodeCacheSize &lt; (uintx)os::vm_page_size()) {
2376     jio_fprintf(defaultStream::error_stream(),
2377                 "Invalid InitialCodeCacheSize=%dK. Must be at least %dK.\n", InitialCodeCacheSize/K,
2378                 os::vm_page_size()/K);
2379     status = false;
2380   } else if (ReservedCodeCacheSize &lt; InitialCodeCacheSize) {
2381     jio_fprintf(defaultStream::error_stream(),
2382                 "Invalid ReservedCodeCacheSize: %dK. Must be at least InitialCodeCacheSize=%dK.\n",
2383                 ReservedCodeCacheSize/K, InitialCodeCacheSize/K);
2384     status = false;
2385   } else if (ReservedCodeCacheSize &lt; min_code_cache_size) {
2386     jio_fprintf(defaultStream::error_stream(),
2387                 "Invalid ReservedCodeCacheSize=%dK. Must be at least %uK.\n", ReservedCodeCacheSize/K,
2388                 min_code_cache_size/K);
2389     status = false;
2390   } else if (ReservedCodeCacheSize &gt; 2*G) {
2391     // Code cache size larger than MAXINT is not supported.
2392     jio_fprintf(defaultStream::error_stream(),
2393                 "Invalid ReservedCodeCacheSize=%dM. Must be at most %uM.\n", ReservedCodeCacheSize/M,
2394                 (2*G)/M);
2395     status = false;
2396   }
2397 
2398   status &amp;= verify_interval(NmethodSweepFraction, 1, ReservedCodeCacheSize/K, "NmethodSweepFraction");
2399   status &amp;= verify_interval(NmethodSweepActivity, 0, 2000, "NmethodSweepActivity");
2400   status &amp;= verify_interval(CodeCacheMinBlockLength, 1, 100, "CodeCacheMinBlockLength");
2401   status &amp;= verify_interval(CodeCacheSegmentSize, 1, 1024, "CodeCacheSegmentSize");
2402 
2403   // TieredCompilation needs at least 2 compiler threads.
2404   const int num_min_compiler_threads = (TieredCompilation &amp;&amp; (TieredStopAtLevel &gt;= CompLevel_full_optimization)) ? 2 : 1;
2405   status &amp;=verify_min_value(CICompilerCount, num_min_compiler_threads, "CICompilerCount");
2406 
2407   if (!FLAG_IS_DEFAULT(CICompilerCount) &amp;&amp; !FLAG_IS_DEFAULT(CICompilerCountPerCPU) &amp;&amp; CICompilerCountPerCPU) {
2408     warning("The VM option CICompilerCountPerCPU overrides CICompilerCount.");
2409   }
2410 
2411   return status;
2412 }
2413 
2414 bool Arguments::is_bad_option(const JavaVMOption* option, jboolean ignore,
2415   const char* option_type) {
2416   if (ignore) return false;
2417 
2418   const char* spacer = " ";
2419   if (option_type == NULL) {
2420     option_type = ++spacer; // Set both to the empty string.
2421   }
2422 
2423   if (os::obsolete_option(option)) {
2424     jio_fprintf(defaultStream::error_stream(),
2425                 "Obsolete %s%soption: %s\n", option_type, spacer,
2426       option-&gt;optionString);
2427     return false;
2428   } else {
2429     jio_fprintf(defaultStream::error_stream(),
2430                 "Unrecognized %s%soption: %s\n", option_type, spacer,
2431       option-&gt;optionString);
2432     return true;
2433   }
2434 }
2435 
2436 static const char* user_assertion_options[] = {
2437   "-da", "-ea", "-disableassertions", "-enableassertions", 0
2438 };
2439 
2440 static const char* system_assertion_options[] = {
2441   "-dsa", "-esa", "-disablesystemassertions", "-enablesystemassertions", 0
2442 };
2443 
2444 // Return true if any of the strings in null-terminated array 'names' matches.
2445 // If tail_allowed is true, then the tail must begin with a colon; otherwise,
2446 // the option must match exactly.
2447 static bool match_option(const JavaVMOption* option, const char** names, const char** tail,
2448   bool tail_allowed) {
2449   for (/* empty */; *names != NULL; ++names) {
2450     if (match_option(option, *names, tail)) {
2451       if (**tail == '\0' || tail_allowed &amp;&amp; **tail == ':') {
2452         return true;
2453       }
2454     }
2455   }
2456   return false;
2457 }
2458 
2459 bool Arguments::parse_uintx(const char* value,
2460                             uintx* uintx_arg,
2461                             uintx min_size) {
2462 
2463   // Check the sign first since atomull() parses only unsigned values.
2464   bool value_is_positive = !(*value == '-');
2465 
2466   if (value_is_positive) {
2467     julong n;
2468     bool good_return = atomull(value, &amp;n);
2469     if (good_return) {
2470       bool above_minimum = n &gt;= min_size;
2471       bool value_is_too_large = n &gt; max_uintx;
2472 
2473       if (above_minimum &amp;&amp; !value_is_too_large) {
2474         *uintx_arg = n;
2475         return true;
2476       }
2477     }
2478   }
2479   return false;
2480 }
2481 
2482 Arguments::ArgsRange Arguments::parse_memory_size(const char* s,
2483                                                   julong* long_arg,
2484                                                   julong min_size) {
2485   if (!atomull(s, long_arg)) return arg_unreadable;
2486   return check_memory_size(*long_arg, min_size);
2487 }
2488 
2489 // Parse JavaVMInitArgs structure
2490 
2491 jint Arguments::parse_vm_init_args(const JavaVMInitArgs* args) {
2492   // For components of the system classpath.
2493   SysClassPath scp(Arguments::get_sysclasspath());
2494   bool scp_assembly_required = false;
2495 
2496   // Save default settings for some mode flags
2497   Arguments::_AlwaysCompileLoopMethods = AlwaysCompileLoopMethods;
2498   Arguments::_UseOnStackReplacement    = UseOnStackReplacement;
2499   Arguments::_ClipInlining             = ClipInlining;
2500   Arguments::_BackgroundCompilation    = BackgroundCompilation;
2501 
2502   // Setup flags for mixed which is the default
2503   set_mode_flags(_mixed);
2504 
2505   // Parse JAVA_TOOL_OPTIONS environment variable (if present)
2506   jint result = parse_java_tool_options_environment_variable(&amp;scp, &amp;scp_assembly_required);
2507   if (result != JNI_OK) {
2508     return result;
2509   }
2510 
2511   // Parse JavaVMInitArgs structure passed in
2512   result = parse_each_vm_init_arg(args, &amp;scp, &amp;scp_assembly_required, Flag::COMMAND_LINE);
2513   if (result != JNI_OK) {
2514     return result;
2515   }
2516 
2517   // Parse _JAVA_OPTIONS environment variable (if present) (mimics classic VM)
2518   result = parse_java_options_environment_variable(&amp;scp, &amp;scp_assembly_required);
2519   if (result != JNI_OK) {
2520     return result;
2521   }
2522 
2523   // Do final processing now that all arguments have been parsed
2524   result = finalize_vm_init_args(&amp;scp, scp_assembly_required);
2525   if (result != JNI_OK) {
2526     return result;
2527   }
2528 
2529   return JNI_OK;
2530 }
2531 
2532 // Checks if name in command-line argument -agent{lib,path}:name[=options]
2533 // represents a valid HPROF of JDWP agent.  is_path==true denotes that we
2534 // are dealing with -agentpath (case where name is a path), otherwise with
2535 // -agentlib
2536 bool valid_hprof_or_jdwp_agent(char *name, bool is_path) {
2537   char *_name;
2538   const char *_hprof = "hprof", *_jdwp = "jdwp";
2539   size_t _len_hprof, _len_jdwp, _len_prefix;
2540 
2541   if (is_path) {
2542     if ((_name = strrchr(name, (int) *os::file_separator())) == NULL) {
2543       return false;
2544     }
2545 
2546     _name++;  // skip past last path separator
2547     _len_prefix = strlen(JNI_LIB_PREFIX);
2548 
2549     if (strncmp(_name, JNI_LIB_PREFIX, _len_prefix) != 0) {
2550       return false;
2551     }
2552 
2553     _name += _len_prefix;
2554     _len_hprof = strlen(_hprof);
2555     _len_jdwp = strlen(_jdwp);
2556 
2557     if (strncmp(_name, _hprof, _len_hprof) == 0) {
2558       _name += _len_hprof;
2559     }
2560     else if (strncmp(_name, _jdwp, _len_jdwp) == 0) {
2561       _name += _len_jdwp;
2562     }
2563     else {
2564       return false;
2565     }
2566 
2567     if (strcmp(_name, JNI_LIB_SUFFIX) != 0) {
2568       return false;
2569     }
2570 
2571     return true;
2572   }
2573 
2574   if (strcmp(name, _hprof) == 0 || strcmp(name, _jdwp) == 0) {
2575     return true;
2576   }
2577 
2578   return false;
2579 }
2580 
2581 jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args,
2582                                        SysClassPath* scp_p,
2583                                        bool* scp_assembly_required_p,
2584                                        Flag::Flags origin) {
2585   // Remaining part of option string
2586   const char* tail;
2587 
2588   // iterate over arguments
2589   for (int index = 0; index &lt; args-&gt;nOptions; index++) {
2590     bool is_absolute_path = false;  // for -agentpath vs -agentlib
2591 
2592     const JavaVMOption* option = args-&gt;options + index;
2593 
2594     if (!match_option(option, "-Djava.class.path", &amp;tail) &amp;&amp;
2595         !match_option(option, "-Dsun.java.command", &amp;tail) &amp;&amp;
2596         !match_option(option, "-Dsun.java.launcher", &amp;tail)) {
2597 
2598         // add all jvm options to the jvm_args string. This string
2599         // is used later to set the java.vm.args PerfData string constant.
2600         // the -Djava.class.path and the -Dsun.java.command options are
2601         // omitted from jvm_args string as each have their own PerfData
2602         // string constant object.
2603         build_jvm_args(option-&gt;optionString);
2604     }
2605 
2606     // -verbose:[class/gc/jni]
2607     if (match_option(option, "-verbose", &amp;tail)) {
2608       if (!strcmp(tail, ":class") || !strcmp(tail, "")) {
2609         FLAG_SET_CMDLINE(bool, TraceClassLoading, true);
2610         FLAG_SET_CMDLINE(bool, TraceClassUnloading, true);
2611       } else if (!strcmp(tail, ":gc")) {
2612         FLAG_SET_CMDLINE(bool, PrintGC, true);
2613       } else if (!strcmp(tail, ":jni")) {
2614         FLAG_SET_CMDLINE(bool, PrintJNIResolving, true);
2615       }
2616     // -da / -ea / -disableassertions / -enableassertions
2617     // These accept an optional class/package name separated by a colon, e.g.,
2618     // -da:java.lang.Thread.
2619     } else if (match_option(option, user_assertion_options, &amp;tail, true)) {
2620       bool enable = option-&gt;optionString[1] == 'e';     // char after '-' is 'e'
2621       if (*tail == '\0') {
2622         JavaAssertions::setUserClassDefault(enable);
2623       } else {
2624         assert(*tail == ':', "bogus match by match_option()");
2625         JavaAssertions::addOption(tail + 1, enable);
2626       }
2627     // -dsa / -esa / -disablesystemassertions / -enablesystemassertions
2628     } else if (match_option(option, system_assertion_options, &amp;tail, false)) {
2629       bool enable = option-&gt;optionString[1] == 'e';     // char after '-' is 'e'
2630       JavaAssertions::setSystemClassDefault(enable);
2631     // -bootclasspath:
2632     } else if (match_option(option, "-Xbootclasspath:", &amp;tail)) {
2633       scp_p-&gt;reset_path(tail);
2634       *scp_assembly_required_p = true;
2635     // -bootclasspath/a:
2636     } else if (match_option(option, "-Xbootclasspath/a:", &amp;tail)) {
2637       scp_p-&gt;add_suffix(tail);
2638       *scp_assembly_required_p = true;
2639     // -bootclasspath/p:
2640     } else if (match_option(option, "-Xbootclasspath/p:", &amp;tail)) {
2641       scp_p-&gt;add_prefix(tail);
2642       *scp_assembly_required_p = true;
2643     // -Xrun
2644     } else if (match_option(option, "-Xrun", &amp;tail)) {
2645       if (tail != NULL) {
2646         const char* pos = strchr(tail, ':');
2647         size_t len = (pos == NULL) ? strlen(tail) : pos - tail;
2648         char* name = (char*)memcpy(NEW_C_HEAP_ARRAY(char, len + 1, mtInternal), tail, len);
2649         name[len] = '\0';
2650 
2651         char *options = NULL;
2652         if(pos != NULL) {
2653           size_t len2 = strlen(pos+1) + 1; // options start after ':'.  Final zero must be copied.
2654           options = (char*)memcpy(NEW_C_HEAP_ARRAY(char, len2, mtInternal), pos+1, len2);
2655         }
2656 #if !INCLUDE_JVMTI
2657         if ((strcmp(name, "hprof") == 0) || (strcmp(name, "jdwp") == 0)) {
2658           jio_fprintf(defaultStream::error_stream(),
2659             "Profiling and debugging agents are not supported in this VM\n");
2660           return JNI_ERR;
2661         }
2662 #endif // !INCLUDE_JVMTI
2663         add_init_library(name, options);
2664       }
2665     // -agentlib and -agentpath
2666     } else if (match_option(option, "-agentlib:", &amp;tail) ||
2667           (is_absolute_path = match_option(option, "-agentpath:", &amp;tail))) {
2668       if(tail != NULL) {
2669         const char* pos = strchr(tail, '=');
2670         size_t len = (pos == NULL) ? strlen(tail) : pos - tail;
2671         char* name = strncpy(NEW_C_HEAP_ARRAY(char, len + 1, mtInternal), tail, len);
2672         name[len] = '\0';
2673 
2674         char *options = NULL;
2675         if(pos != NULL) {
2676           options = strcpy(NEW_C_HEAP_ARRAY(char, strlen(pos + 1) + 1, mtInternal), pos + 1);
2677         }
2678 #if !INCLUDE_JVMTI
2679         if (valid_hprof_or_jdwp_agent(name, is_absolute_path)) {
2680           jio_fprintf(defaultStream::error_stream(),
2681             "Profiling and debugging agents are not supported in this VM\n");
2682           return JNI_ERR;
2683         }
2684 #endif // !INCLUDE_JVMTI
2685         add_init_agent(name, options, is_absolute_path);
2686       }
2687     // -javaagent
2688     } else if (match_option(option, "-javaagent:", &amp;tail)) {
2689 #if !INCLUDE_JVMTI
2690       jio_fprintf(defaultStream::error_stream(),
2691         "Instrumentation agents are not supported in this VM\n");
2692       return JNI_ERR;
2693 #else
2694       if(tail != NULL) {
2695         char *options = strcpy(NEW_C_HEAP_ARRAY(char, strlen(tail) + 1, mtInternal), tail);
2696         add_init_agent("instrument", options, false);
2697       }
2698 #endif // !INCLUDE_JVMTI
2699     // -Xnoclassgc
2700     } else if (match_option(option, "-Xnoclassgc", &amp;tail)) {
2701       FLAG_SET_CMDLINE(bool, ClassUnloading, false);
2702     // -Xincgc: i-CMS
2703     } else if (match_option(option, "-Xincgc", &amp;tail)) {
2704       FLAG_SET_CMDLINE(bool, UseConcMarkSweepGC, true);
2705       FLAG_SET_CMDLINE(bool, CMSIncrementalMode, true);
2706     // -Xnoincgc: no i-CMS
2707     } else if (match_option(option, "-Xnoincgc", &amp;tail)) {
2708       FLAG_SET_CMDLINE(bool, UseConcMarkSweepGC, false);
2709       FLAG_SET_CMDLINE(bool, CMSIncrementalMode, false);
2710     // -Xconcgc
2711     } else if (match_option(option, "-Xconcgc", &amp;tail)) {
2712       FLAG_SET_CMDLINE(bool, UseConcMarkSweepGC, true);
2713     // -Xnoconcgc
2714     } else if (match_option(option, "-Xnoconcgc", &amp;tail)) {
2715       FLAG_SET_CMDLINE(bool, UseConcMarkSweepGC, false);
2716     // -Xbatch
2717     } else if (match_option(option, "-Xbatch", &amp;tail)) {
2718       FLAG_SET_CMDLINE(bool, BackgroundCompilation, false);
2719     // -Xmn for compatibility with other JVM vendors
2720     } else if (match_option(option, "-Xmn", &amp;tail)) {
2721       julong long_initial_young_size = 0;
2722       ArgsRange errcode = parse_memory_size(tail, &amp;long_initial_young_size, 1);
2723       if (errcode != arg_in_range) {
2724         jio_fprintf(defaultStream::error_stream(),
2725                     "Invalid initial young generation size: %s\n", option-&gt;optionString);
2726         describe_range_error(errcode);
2727         return JNI_EINVAL;
2728       }
2729       FLAG_SET_CMDLINE(uintx, MaxNewSize, (uintx)long_initial_young_size);
2730       FLAG_SET_CMDLINE(uintx, NewSize, (uintx)long_initial_young_size);
2731     // -Xms
2732     } else if (match_option(option, "-Xms", &amp;tail)) {
2733       julong long_initial_heap_size = 0;
2734       // an initial heap size of 0 means automatically determine
2735       ArgsRange errcode = parse_memory_size(tail, &amp;long_initial_heap_size, 0);
2736       if (errcode != arg_in_range) {
2737         jio_fprintf(defaultStream::error_stream(),
2738                     "Invalid initial heap size: %s\n", option-&gt;optionString);
2739         describe_range_error(errcode);
2740         return JNI_EINVAL;
2741       }
2742       set_min_heap_size((uintx)long_initial_heap_size);
2743       // Currently the minimum size and the initial heap sizes are the same.
2744       // Can be overridden with -XX:InitialHeapSize.
2745       FLAG_SET_CMDLINE(uintx, InitialHeapSize, (uintx)long_initial_heap_size);
2746     // -Xmx
2747     } else if (match_option(option, "-Xmx", &amp;tail) || match_option(option, "-XX:MaxHeapSize=", &amp;tail)) {
2748       julong long_max_heap_size = 0;
2749       ArgsRange errcode = parse_memory_size(tail, &amp;long_max_heap_size, 1);
2750       if (errcode != arg_in_range) {
2751         jio_fprintf(defaultStream::error_stream(),
2752                     "Invalid maximum heap size: %s\n", option-&gt;optionString);
2753         describe_range_error(errcode);
2754         return JNI_EINVAL;
2755       }
2756       FLAG_SET_CMDLINE(uintx, MaxHeapSize, (uintx)long_max_heap_size);
2757     // Xmaxf
2758     } else if (match_option(option, "-Xmaxf", &amp;tail)) {
2759       char* err;
2760       int maxf = (int)(strtod(tail, &amp;err) * 100);
2761       if (*err != '\0' || *tail == '\0' || maxf &lt; 0 || maxf &gt; 100) {
2762         jio_fprintf(defaultStream::error_stream(),
2763                     "Bad max heap free percentage size: %s\n",
2764                     option-&gt;optionString);
2765         return JNI_EINVAL;
2766       } else {
2767         FLAG_SET_CMDLINE(uintx, MaxHeapFreeRatio, maxf);
2768       }
2769     // Xminf
2770     } else if (match_option(option, "-Xminf", &amp;tail)) {
2771       char* err;
2772       int minf = (int)(strtod(tail, &amp;err) * 100);
2773       if (*err != '\0' || *tail == '\0' || minf &lt; 0 || minf &gt; 100) {
2774         jio_fprintf(defaultStream::error_stream(),
2775                     "Bad min heap free percentage size: %s\n",
2776                     option-&gt;optionString);
2777         return JNI_EINVAL;
2778       } else {
2779         FLAG_SET_CMDLINE(uintx, MinHeapFreeRatio, minf);
2780       }
2781     // -Xss
2782     } else if (match_option(option, "-Xss", &amp;tail)) {
2783       julong long_ThreadStackSize = 0;
2784       ArgsRange errcode = parse_memory_size(tail, &amp;long_ThreadStackSize, 1000);
2785       if (errcode != arg_in_range) {
2786         jio_fprintf(defaultStream::error_stream(),
2787                     "Invalid thread stack size: %s\n", option-&gt;optionString);
2788         describe_range_error(errcode);
2789         return JNI_EINVAL;
2790       }
2791       // Internally track ThreadStackSize in units of 1024 bytes.
2792       FLAG_SET_CMDLINE(intx, ThreadStackSize,
2793                               round_to((int)long_ThreadStackSize, K) / K);
2794     // -Xoss
2795     } else if (match_option(option, "-Xoss", &amp;tail)) {
2796           // HotSpot does not have separate native and Java stacks, ignore silently for compatibility
2797     } else if (match_option(option, "-XX:CodeCacheExpansionSize=", &amp;tail)) {
2798       julong long_CodeCacheExpansionSize = 0;
2799       ArgsRange errcode = parse_memory_size(tail, &amp;long_CodeCacheExpansionSize, os::vm_page_size());
2800       if (errcode != arg_in_range) {
2801         jio_fprintf(defaultStream::error_stream(),
2802                    "Invalid argument: %s. Must be at least %luK.\n", option-&gt;optionString,
2803                    os::vm_page_size()/K);
2804         return JNI_EINVAL;
2805       }
2806       FLAG_SET_CMDLINE(uintx, CodeCacheExpansionSize, (uintx)long_CodeCacheExpansionSize);
2807     } else if (match_option(option, "-Xmaxjitcodesize", &amp;tail) ||
2808                match_option(option, "-XX:ReservedCodeCacheSize=", &amp;tail)) {
2809       julong long_ReservedCodeCacheSize = 0;
2810 
2811       ArgsRange errcode = parse_memory_size(tail, &amp;long_ReservedCodeCacheSize, 1);
2812       if (errcode != arg_in_range) {
2813         jio_fprintf(defaultStream::error_stream(),
2814                     "Invalid maximum code cache size: %s.\n", option-&gt;optionString);
2815         return JNI_EINVAL;
2816       }
2817       FLAG_SET_CMDLINE(uintx, ReservedCodeCacheSize, (uintx)long_ReservedCodeCacheSize);
2818       //-XX:IncreaseFirstTierCompileThresholdAt=
2819       } else if (match_option(option, "-XX:IncreaseFirstTierCompileThresholdAt=", &amp;tail)) {
2820         uintx uint_IncreaseFirstTierCompileThresholdAt = 0;
2821         if (!parse_uintx(tail, &amp;uint_IncreaseFirstTierCompileThresholdAt, 0) || uint_IncreaseFirstTierCompileThresholdAt &gt; 99) {
2822           jio_fprintf(defaultStream::error_stream(),
2823                       "Invalid value for IncreaseFirstTierCompileThresholdAt: %s. Should be between 0 and 99.\n",
2824                       option-&gt;optionString);
2825           return JNI_EINVAL;
2826         }
2827         FLAG_SET_CMDLINE(uintx, IncreaseFirstTierCompileThresholdAt, (uintx)uint_IncreaseFirstTierCompileThresholdAt);
2828     // -green
2829     } else if (match_option(option, "-green", &amp;tail)) {
2830       jio_fprintf(defaultStream::error_stream(),
2831                   "Green threads support not available\n");
2832           return JNI_EINVAL;
2833     // -native
2834     } else if (match_option(option, "-native", &amp;tail)) {
2835           // HotSpot always uses native threads, ignore silently for compatibility
2836     // -Xsqnopause
2837     } else if (match_option(option, "-Xsqnopause", &amp;tail)) {
2838           // EVM option, ignore silently for compatibility
2839     // -Xrs
2840     } else if (match_option(option, "-Xrs", &amp;tail)) {
2841           // Classic/EVM option, new functionality
2842       FLAG_SET_CMDLINE(bool, ReduceSignalUsage, true);
2843     } else if (match_option(option, "-Xusealtsigs", &amp;tail)) {
2844           // change default internal VM signals used - lower case for back compat
2845       FLAG_SET_CMDLINE(bool, UseAltSigs, true);
2846     // -Xoptimize
2847     } else if (match_option(option, "-Xoptimize", &amp;tail)) {
2848           // EVM option, ignore silently for compatibility
2849     // -Xprof
2850     } else if (match_option(option, "-Xprof", &amp;tail)) {
2851 #if INCLUDE_FPROF
2852       _has_profile = true;
2853 #else // INCLUDE_FPROF
2854       jio_fprintf(defaultStream::error_stream(),
2855         "Flat profiling is not supported in this VM.\n");
2856       return JNI_ERR;
2857 #endif // INCLUDE_FPROF
2858     // -Xconcurrentio
2859     } else if (match_option(option, "-Xconcurrentio", &amp;tail)) {
2860       FLAG_SET_CMDLINE(bool, UseLWPSynchronization, true);
2861       FLAG_SET_CMDLINE(bool, BackgroundCompilation, false);
2862       FLAG_SET_CMDLINE(intx, DeferThrSuspendLoopCount, 1);
2863       FLAG_SET_CMDLINE(bool, UseTLAB, false);
2864       FLAG_SET_CMDLINE(uintx, NewSizeThreadIncrease, 16 * K);  // 20Kb per thread added to new generation
2865 
2866       // -Xinternalversion
2867     } else if (match_option(option, "-Xinternalversion", &amp;tail)) {
2868       jio_fprintf(defaultStream::output_stream(), "%s\n",
2869                   VM_Version::internal_vm_info_string());
2870       vm_exit(0);
2871 #ifndef PRODUCT
2872     // -Xprintflags
2873     } else if (match_option(option, "-Xprintflags", &amp;tail)) {
2874       CommandLineFlags::printFlags(tty, false);
2875       vm_exit(0);
2876 #endif
2877     // -D
2878     } else if (match_option(option, "-D", &amp;tail)) {
2879       if (!add_property(tail)) {
2880         return JNI_ENOMEM;
2881       }
2882       // Out of the box management support
2883       if (match_option(option, "-Dcom.sun.management", &amp;tail)) {
2884 #if INCLUDE_MANAGEMENT
2885         FLAG_SET_CMDLINE(bool, ManagementServer, true);
2886 #else
2887         jio_fprintf(defaultStream::output_stream(),
2888           "-Dcom.sun.management is not supported in this VM.\n");
2889         return JNI_ERR;
2890 #endif
2891       }
2892     // -Xint
2893     } else if (match_option(option, "-Xint", &amp;tail)) {
2894           set_mode_flags(_int);
2895     // -Xmixed
2896     } else if (match_option(option, "-Xmixed", &amp;tail)) {
2897           set_mode_flags(_mixed);
2898     // -Xcomp
2899     } else if (match_option(option, "-Xcomp", &amp;tail)) {
2900       // for testing the compiler; turn off all flags that inhibit compilation
2901           set_mode_flags(_comp);
2902     // -Xshare:dump
2903     } else if (match_option(option, "-Xshare:dump", &amp;tail)) {
2904       FLAG_SET_CMDLINE(bool, DumpSharedSpaces, true);
2905       set_mode_flags(_int);     // Prevent compilation, which creates objects
2906     // -Xshare:on
2907     } else if (match_option(option, "-Xshare:on", &amp;tail)) {
2908       FLAG_SET_CMDLINE(bool, UseSharedSpaces, true);
2909       FLAG_SET_CMDLINE(bool, RequireSharedSpaces, true);
2910     // -Xshare:auto
2911     } else if (match_option(option, "-Xshare:auto", &amp;tail)) {
2912       FLAG_SET_CMDLINE(bool, UseSharedSpaces, true);
2913       FLAG_SET_CMDLINE(bool, RequireSharedSpaces, false);
2914     // -Xshare:off
2915     } else if (match_option(option, "-Xshare:off", &amp;tail)) {
2916       FLAG_SET_CMDLINE(bool, UseSharedSpaces, false);
2917       FLAG_SET_CMDLINE(bool, RequireSharedSpaces, false);
2918     // -Xverify
2919     } else if (match_option(option, "-Xverify", &amp;tail)) {
2920       if (strcmp(tail, ":all") == 0 || strcmp(tail, "") == 0) {
2921         FLAG_SET_CMDLINE(bool, BytecodeVerificationLocal, true);
2922         FLAG_SET_CMDLINE(bool, BytecodeVerificationRemote, true);
2923       } else if (strcmp(tail, ":remote") == 0) {
2924         FLAG_SET_CMDLINE(bool, BytecodeVerificationLocal, false);
2925         FLAG_SET_CMDLINE(bool, BytecodeVerificationRemote, true);
2926       } else if (strcmp(tail, ":none") == 0) {
2927         FLAG_SET_CMDLINE(bool, BytecodeVerificationLocal, false);
2928         FLAG_SET_CMDLINE(bool, BytecodeVerificationRemote, false);
2929       } else if (is_bad_option(option, args-&gt;ignoreUnrecognized, "verification")) {
2930         return JNI_EINVAL;
2931       }
2932     // -Xdebug
2933     } else if (match_option(option, "-Xdebug", &amp;tail)) {
2934       // note this flag has been used, then ignore
2935       set_xdebug_mode(true);
2936     // -Xnoagent
2937     } else if (match_option(option, "-Xnoagent", &amp;tail)) {
2938       // For compatibility with classic. HotSpot refuses to load the old style agent.dll.
2939     } else if (match_option(option, "-Xboundthreads", &amp;tail)) {
2940       // Bind user level threads to kernel threads (Solaris only)
2941       FLAG_SET_CMDLINE(bool, UseBoundThreads, true);
2942     } else if (match_option(option, "-Xloggc:", &amp;tail)) {
2943       // Redirect GC output to the file. -Xloggc:&lt;filename&gt;
2944       // ostream_init_log(), when called will use this filename
2945       // to initialize a fileStream.
2946       _gc_log_filename = strdup(tail);
2947      if (!is_filename_valid(_gc_log_filename)) {
2948        jio_fprintf(defaultStream::output_stream(),
2949                   "Invalid file name for use with -Xloggc: Filename can only contain the "
2950                   "characters [A-Z][a-z][0-9]-_.%%[p|t] but it has been %s\n"
2951                   "Note %%p or %%t can only be used once\n", _gc_log_filename);
2952         return JNI_EINVAL;
2953       }
2954       FLAG_SET_CMDLINE(bool, PrintGC, true);
2955       FLAG_SET_CMDLINE(bool, PrintGCTimeStamps, true);
2956 
2957     // JNI hooks
2958     } else if (match_option(option, "-Xcheck", &amp;tail)) {
2959       if (!strcmp(tail, ":jni")) {
2960 #if !INCLUDE_JNI_CHECK
2961         warning("JNI CHECKING is not supported in this VM");
2962 #else
2963         CheckJNICalls = true;
2964 #endif // INCLUDE_JNI_CHECK
2965       } else if (is_bad_option(option, args-&gt;ignoreUnrecognized,
2966                                      "check")) {
2967         return JNI_EINVAL;
2968       }
2969     } else if (match_option(option, "vfprintf", &amp;tail)) {
2970       _vfprintf_hook = CAST_TO_FN_PTR(vfprintf_hook_t, option-&gt;extraInfo);
2971     } else if (match_option(option, "exit", &amp;tail)) {
2972       _exit_hook = CAST_TO_FN_PTR(exit_hook_t, option-&gt;extraInfo);
2973     } else if (match_option(option, "abort", &amp;tail)) {
2974       _abort_hook = CAST_TO_FN_PTR(abort_hook_t, option-&gt;extraInfo);
2975     // -XX:+AggressiveHeap
2976     } else if (match_option(option, "-XX:+AggressiveHeap", &amp;tail)) {
2977 
2978       // This option inspects the machine and attempts to set various
2979       // parameters to be optimal for long-running, memory allocation
2980       // intensive jobs.  It is intended for machines with large
2981       // amounts of cpu and memory.
2982 
2983       // initHeapSize is needed since _initial_heap_size is 4 bytes on a 32 bit
2984       // VM, but we may not be able to represent the total physical memory
2985       // available (like having 8gb of memory on a box but using a 32bit VM).
2986       // Thus, we need to make sure we're using a julong for intermediate
2987       // calculations.
2988       julong initHeapSize;
2989       julong total_memory = os::physical_memory();
2990 
2991       if (total_memory &lt; (julong)256*M) {
2992         jio_fprintf(defaultStream::error_stream(),
2993                     "You need at least 256mb of memory to use -XX:+AggressiveHeap\n");
2994         vm_exit(1);
2995       }
2996 
2997       // The heap size is half of available memory, or (at most)
2998       // all of possible memory less 160mb (leaving room for the OS
2999       // when using ISM).  This is the maximum; because adaptive sizing
3000       // is turned on below, the actual space used may be smaller.
3001 
3002       initHeapSize = MIN2(total_memory / (julong)2,
3003                           total_memory - (julong)160*M);
3004 
3005       initHeapSize = limit_by_allocatable_memory(initHeapSize);
3006 
3007       if (FLAG_IS_DEFAULT(MaxHeapSize)) {
3008          FLAG_SET_CMDLINE(uintx, MaxHeapSize, initHeapSize);
3009          FLAG_SET_CMDLINE(uintx, InitialHeapSize, initHeapSize);
3010          // Currently the minimum size and the initial heap sizes are the same.
3011          set_min_heap_size(initHeapSize);
3012       }
3013       if (FLAG_IS_DEFAULT(NewSize)) {
3014          // Make the young generation 3/8ths of the total heap.
3015          FLAG_SET_CMDLINE(uintx, NewSize,
3016                                 ((julong)MaxHeapSize / (julong)8) * (julong)3);
3017          FLAG_SET_CMDLINE(uintx, MaxNewSize, NewSize);
3018       }
3019 
3020 #ifndef _ALLBSD_SOURCE  // UseLargePages is not yet supported on BSD.
3021       FLAG_SET_DEFAULT(UseLargePages, true);
3022 #endif
3023 
3024       // Increase some data structure sizes for efficiency
3025       FLAG_SET_CMDLINE(uintx, BaseFootPrintEstimate, MaxHeapSize);
3026       FLAG_SET_CMDLINE(bool, ResizeTLAB, false);
3027       FLAG_SET_CMDLINE(uintx, TLABSize, 256*K);
3028 
3029       // See the OldPLABSize comment below, but replace 'after promotion'
3030       // with 'after copying'.  YoungPLABSize is the size of the survivor
3031       // space per-gc-thread buffers.  The default is 4kw.
3032       FLAG_SET_CMDLINE(uintx, YoungPLABSize, 256*K);      // Note: this is in words
3033 
3034       // OldPLABSize is the size of the buffers in the old gen that
3035       // UseParallelGC uses to promote live data that doesn't fit in the
3036       // survivor spaces.  At any given time, there's one for each gc thread.
3037       // The default size is 1kw. These buffers are rarely used, since the
3038       // survivor spaces are usually big enough.  For specjbb, however, there
3039       // are occasions when there's lots of live data in the young gen
3040       // and we end up promoting some of it.  We don't have a definite
3041       // explanation for why bumping OldPLABSize helps, but the theory
3042       // is that a bigger PLAB results in retaining something like the
3043       // original allocation order after promotion, which improves mutator
3044       // locality.  A minor effect may be that larger PLABs reduce the
3045       // number of PLAB allocation events during gc.  The value of 8kw
3046       // was arrived at by experimenting with specjbb.
3047       FLAG_SET_CMDLINE(uintx, OldPLABSize, 8*K);  // Note: this is in words
3048 
3049       // Enable parallel GC and adaptive generation sizing
3050       FLAG_SET_CMDLINE(bool, UseParallelGC, true);
3051       FLAG_SET_DEFAULT(ParallelGCThreads,
3052                        Abstract_VM_Version::parallel_worker_threads());
3053 
3054       // Encourage steady state memory management
3055       FLAG_SET_CMDLINE(uintx, ThresholdTolerance, 100);
3056 
3057       // This appears to improve mutator locality
3058       FLAG_SET_CMDLINE(bool, ScavengeBeforeFullGC, false);
3059 
3060       // Get around early Solaris scheduling bug
3061       // (affinity vs other jobs on system)
3062       // but disallow DR and offlining (5008695).
3063       FLAG_SET_CMDLINE(bool, BindGCTaskThreadsToCPUs, true);
3064 
3065     // Need to keep consistency of MaxTenuringThreshold and AlwaysTenure/NeverTenure;
3066     // and the last option wins.
3067     } else if (match_option(option, "-XX:+NeverTenure", &amp;tail)) {
3068       FLAG_SET_CMDLINE(bool, NeverTenure, true);
3069       FLAG_SET_CMDLINE(bool, AlwaysTenure, false);
3070       FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, markOopDesc::max_age + 1);
3071     } else if (match_option(option, "-XX:+AlwaysTenure", &amp;tail)) {
3072       FLAG_SET_CMDLINE(bool, NeverTenure, false);
3073       FLAG_SET_CMDLINE(bool, AlwaysTenure, true);
3074       FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, 0);
3075     } else if (match_option(option, "-XX:MaxTenuringThreshold=", &amp;tail)) {
3076       uintx max_tenuring_thresh = 0;
3077       if(!parse_uintx(tail, &amp;max_tenuring_thresh, 0)) {
3078         jio_fprintf(defaultStream::error_stream(),
3079                     "Invalid MaxTenuringThreshold: %s\n", option-&gt;optionString);
3080       }
3081       FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, max_tenuring_thresh);
3082 
3083       if (MaxTenuringThreshold == 0) {
3084         FLAG_SET_CMDLINE(bool, NeverTenure, false);
3085         FLAG_SET_CMDLINE(bool, AlwaysTenure, true);
3086       } else {
3087         FLAG_SET_CMDLINE(bool, NeverTenure, false);
3088         FLAG_SET_CMDLINE(bool, AlwaysTenure, false);
3089       }
3090     } else if (match_option(option, "-XX:+CMSPermGenSweepingEnabled", &amp;tail) ||
3091                match_option(option, "-XX:-CMSPermGenSweepingEnabled", &amp;tail)) {
3092       jio_fprintf(defaultStream::error_stream(),
3093         "Please use CMSClassUnloadingEnabled in place of "
3094         "CMSPermGenSweepingEnabled in the future\n");
3095     } else if (match_option(option, "-XX:+UseGCTimeLimit", &amp;tail)) {
3096       FLAG_SET_CMDLINE(bool, UseGCOverheadLimit, true);
3097       jio_fprintf(defaultStream::error_stream(),
3098         "Please use -XX:+UseGCOverheadLimit in place of "
3099         "-XX:+UseGCTimeLimit in the future\n");
3100     } else if (match_option(option, "-XX:-UseGCTimeLimit", &amp;tail)) {
3101       FLAG_SET_CMDLINE(bool, UseGCOverheadLimit, false);
3102       jio_fprintf(defaultStream::error_stream(),
3103         "Please use -XX:-UseGCOverheadLimit in place of "
3104         "-XX:-UseGCTimeLimit in the future\n");
3105     // The TLE options are for compatibility with 1.3 and will be
3106     // removed without notice in a future release.  These options
3107     // are not to be documented.
3108     } else if (match_option(option, "-XX:MaxTLERatio=", &amp;tail)) {
3109       // No longer used.
3110     } else if (match_option(option, "-XX:+ResizeTLE", &amp;tail)) {
3111       FLAG_SET_CMDLINE(bool, ResizeTLAB, true);
3112     } else if (match_option(option, "-XX:-ResizeTLE", &amp;tail)) {
3113       FLAG_SET_CMDLINE(bool, ResizeTLAB, false);
3114     } else if (match_option(option, "-XX:+PrintTLE", &amp;tail)) {
3115       FLAG_SET_CMDLINE(bool, PrintTLAB, true);
3116     } else if (match_option(option, "-XX:-PrintTLE", &amp;tail)) {
3117       FLAG_SET_CMDLINE(bool, PrintTLAB, false);
3118     } else if (match_option(option, "-XX:TLEFragmentationRatio=", &amp;tail)) {
3119       // No longer used.
3120     } else if (match_option(option, "-XX:TLESize=", &amp;tail)) {
3121       julong long_tlab_size = 0;
3122       ArgsRange errcode = parse_memory_size(tail, &amp;long_tlab_size, 1);
3123       if (errcode != arg_in_range) {
3124         jio_fprintf(defaultStream::error_stream(),
3125                     "Invalid TLAB size: %s\n", option-&gt;optionString);
3126         describe_range_error(errcode);
3127         return JNI_EINVAL;
3128       }
3129       FLAG_SET_CMDLINE(uintx, TLABSize, long_tlab_size);
3130     } else if (match_option(option, "-XX:TLEThreadRatio=", &amp;tail)) {
3131       // No longer used.
3132     } else if (match_option(option, "-XX:+UseTLE", &amp;tail)) {
3133       FLAG_SET_CMDLINE(bool, UseTLAB, true);
3134     } else if (match_option(option, "-XX:-UseTLE", &amp;tail)) {
3135       FLAG_SET_CMDLINE(bool, UseTLAB, false);
3136     } else if (match_option(option, "-XX:+DisplayVMOutputToStderr", &amp;tail)) {
3137       FLAG_SET_CMDLINE(bool, DisplayVMOutputToStdout, false);
3138       FLAG_SET_CMDLINE(bool, DisplayVMOutputToStderr, true);
3139     } else if (match_option(option, "-XX:+DisplayVMOutputToStdout", &amp;tail)) {
3140       FLAG_SET_CMDLINE(bool, DisplayVMOutputToStderr, false);
3141       FLAG_SET_CMDLINE(bool, DisplayVMOutputToStdout, true);
3142     } else if (match_option(option, "-XX:+ExtendedDTraceProbes", &amp;tail)) {
3143 #if defined(DTRACE_ENABLED)
3144       FLAG_SET_CMDLINE(bool, ExtendedDTraceProbes, true);
3145       FLAG_SET_CMDLINE(bool, DTraceMethodProbes, true);
3146       FLAG_SET_CMDLINE(bool, DTraceAllocProbes, true);
3147       FLAG_SET_CMDLINE(bool, DTraceMonitorProbes, true);
3148 #else // defined(DTRACE_ENABLED)
3149       jio_fprintf(defaultStream::error_stream(),
3150                   "ExtendedDTraceProbes flag is not applicable for this configuration\n");
3151       return JNI_EINVAL;
3152 #endif // defined(DTRACE_ENABLED)
3153 #ifdef ASSERT
3154     } else if (match_option(option, "-XX:+FullGCALot", &amp;tail)) {
3155       FLAG_SET_CMDLINE(bool, FullGCALot, true);
3156       // disable scavenge before parallel mark-compact
3157       FLAG_SET_CMDLINE(bool, ScavengeBeforeFullGC, false);
3158 #endif
3159     } else if (match_option(option, "-XX:CMSParPromoteBlocksToClaim=", &amp;tail)) {
3160       julong cms_blocks_to_claim = (julong)atol(tail);
3161       FLAG_SET_CMDLINE(uintx, CMSParPromoteBlocksToClaim, cms_blocks_to_claim);
3162       jio_fprintf(defaultStream::error_stream(),
3163         "Please use -XX:OldPLABSize in place of "
3164         "-XX:CMSParPromoteBlocksToClaim in the future\n");
3165     } else if (match_option(option, "-XX:ParCMSPromoteBlocksToClaim=", &amp;tail)) {
3166       julong cms_blocks_to_claim = (julong)atol(tail);
3167       FLAG_SET_CMDLINE(uintx, CMSParPromoteBlocksToClaim, cms_blocks_to_claim);
3168       jio_fprintf(defaultStream::error_stream(),
3169         "Please use -XX:OldPLABSize in place of "
3170         "-XX:ParCMSPromoteBlocksToClaim in the future\n");
3171     } else if (match_option(option, "-XX:ParallelGCOldGenAllocBufferSize=", &amp;tail)) {
3172       julong old_plab_size = 0;
3173       ArgsRange errcode = parse_memory_size(tail, &amp;old_plab_size, 1);
3174       if (errcode != arg_in_range) {
3175         jio_fprintf(defaultStream::error_stream(),
3176                     "Invalid old PLAB size: %s\n", option-&gt;optionString);
3177         describe_range_error(errcode);
3178         return JNI_EINVAL;
3179       }
3180       FLAG_SET_CMDLINE(uintx, OldPLABSize, old_plab_size);
3181       jio_fprintf(defaultStream::error_stream(),
3182                   "Please use -XX:OldPLABSize in place of "
3183                   "-XX:ParallelGCOldGenAllocBufferSize in the future\n");
3184     } else if (match_option(option, "-XX:ParallelGCToSpaceAllocBufferSize=", &amp;tail)) {
3185       julong young_plab_size = 0;
3186       ArgsRange errcode = parse_memory_size(tail, &amp;young_plab_size, 1);
3187       if (errcode != arg_in_range) {
3188         jio_fprintf(defaultStream::error_stream(),
3189                     "Invalid young PLAB size: %s\n", option-&gt;optionString);
3190         describe_range_error(errcode);
3191         return JNI_EINVAL;
3192       }
3193       FLAG_SET_CMDLINE(uintx, YoungPLABSize, young_plab_size);
3194       jio_fprintf(defaultStream::error_stream(),
3195                   "Please use -XX:YoungPLABSize in place of "
3196                   "-XX:ParallelGCToSpaceAllocBufferSize in the future\n");
3197     } else if (match_option(option, "-XX:CMSMarkStackSize=", &amp;tail) ||
3198                match_option(option, "-XX:G1MarkStackSize=", &amp;tail)) {
3199       julong stack_size = 0;
3200       ArgsRange errcode = parse_memory_size(tail, &amp;stack_size, 1);
3201       if (errcode != arg_in_range) {
3202         jio_fprintf(defaultStream::error_stream(),
3203                     "Invalid mark stack size: %s\n", option-&gt;optionString);
3204         describe_range_error(errcode);
3205         return JNI_EINVAL;
3206       }
3207       FLAG_SET_CMDLINE(uintx, MarkStackSize, stack_size);
3208     } else if (match_option(option, "-XX:CMSMarkStackSizeMax=", &amp;tail)) {
3209       julong max_stack_size = 0;
3210       ArgsRange errcode = parse_memory_size(tail, &amp;max_stack_size, 1);
3211       if (errcode != arg_in_range) {
3212         jio_fprintf(defaultStream::error_stream(),
3213                     "Invalid maximum mark stack size: %s\n",
3214                     option-&gt;optionString);
3215         describe_range_error(errcode);
3216         return JNI_EINVAL;
3217       }
3218       FLAG_SET_CMDLINE(uintx, MarkStackSizeMax, max_stack_size);
3219     } else if (match_option(option, "-XX:ParallelMarkingThreads=", &amp;tail) ||
3220                match_option(option, "-XX:ParallelCMSThreads=", &amp;tail)) {
3221       uintx conc_threads = 0;
3222       if (!parse_uintx(tail, &amp;conc_threads, 1)) {
3223         jio_fprintf(defaultStream::error_stream(),
3224                     "Invalid concurrent threads: %s\n", option-&gt;optionString);
3225         return JNI_EINVAL;
3226       }
3227       FLAG_SET_CMDLINE(uintx, ConcGCThreads, conc_threads);
3228     } else if (match_option(option, "-XX:MaxDirectMemorySize=", &amp;tail)) {
3229       julong max_direct_memory_size = 0;
3230       ArgsRange errcode = parse_memory_size(tail, &amp;max_direct_memory_size, 0);
3231       if (errcode != arg_in_range) {
3232         jio_fprintf(defaultStream::error_stream(),
3233                     "Invalid maximum direct memory size: %s\n",
3234                     option-&gt;optionString);
3235         describe_range_error(errcode);
3236         return JNI_EINVAL;
3237       }
3238       FLAG_SET_CMDLINE(uintx, MaxDirectMemorySize, max_direct_memory_size);
3239 #if !INCLUDE_MANAGEMENT
3240     } else if (match_option(option, "-XX:+ManagementServer", &amp;tail)) {
3241         jio_fprintf(defaultStream::error_stream(),
3242           "ManagementServer is not supported in this VM.\n");
3243         return JNI_ERR;
3244 #endif // INCLUDE_MANAGEMENT
3245     } else if (match_option(option, "-XX:", &amp;tail)) { // -XX:xxxx
3246       // Skip -XX:Flags= since that case has already been handled
3247       if (strncmp(tail, "Flags=", strlen("Flags=")) != 0) {
3248         if (!process_argument(tail, args-&gt;ignoreUnrecognized, origin)) {
3249           return JNI_EINVAL;
3250         }
3251       }
3252     // Unknown option
3253     } else if (is_bad_option(option, args-&gt;ignoreUnrecognized)) {
3254       return JNI_ERR;
3255     }
3256   }
3257 
3258   // Change the default value for flags  which have different default values
3259   // when working with older JDKs.
3260 #ifdef LINUX
3261  if (JDK_Version::current().compare_major(6) &lt;= 0 &amp;&amp;
3262       FLAG_IS_DEFAULT(UseLinuxPosixThreadCPUClocks)) {
3263     FLAG_SET_DEFAULT(UseLinuxPosixThreadCPUClocks, false);
3264   }
3265 #endif // LINUX
3266   return JNI_OK;
3267 }
3268 
3269 jint Arguments::finalize_vm_init_args(SysClassPath* scp_p, bool scp_assembly_required) {
3270   // This must be done after all -D arguments have been processed.
3271   scp_p-&gt;expand_endorsed();
3272 
3273   if (scp_assembly_required || scp_p-&gt;get_endorsed() != NULL) {
3274     // Assemble the bootclasspath elements into the final path.
3275     Arguments::set_sysclasspath(scp_p-&gt;combined_path());
3276   }
3277 
3278   // This must be done after all arguments have been processed.
3279   // java_compiler() true means set to "NONE" or empty.
3280   if (java_compiler() &amp;&amp; !xdebug_mode()) {
3281     // For backwards compatibility, we switch to interpreted mode if
3282     // -Djava.compiler="NONE" or "" is specified AND "-Xdebug" was
3283     // not specified.
3284     set_mode_flags(_int);
3285   }
3286   if (CompileThreshold == 0) {
3287     set_mode_flags(_int);
3288   }
3289 
3290   // eventually fix up InitialTenuringThreshold if only MaxTenuringThreshold is set
3291   if (FLAG_IS_DEFAULT(InitialTenuringThreshold) &amp;&amp; (InitialTenuringThreshold &gt; MaxTenuringThreshold)) {
3292     FLAG_SET_ERGO(uintx, InitialTenuringThreshold, MaxTenuringThreshold);
3293   }
3294 
3295 #ifndef COMPILER2
3296   // Don't degrade server performance for footprint
3297   if (FLAG_IS_DEFAULT(UseLargePages) &amp;&amp;
3298       MaxHeapSize &lt; LargePageHeapSizeThreshold) {
3299     // No need for large granularity pages w/small heaps.
3300     // Note that large pages are enabled/disabled for both the
3301     // Java heap and the code cache.
3302     FLAG_SET_DEFAULT(UseLargePages, false);
3303   }
3304 
3305 #else
3306   if (!FLAG_IS_DEFAULT(OptoLoopAlignment) &amp;&amp; FLAG_IS_DEFAULT(MaxLoopPad)) {
3307     FLAG_SET_DEFAULT(MaxLoopPad, OptoLoopAlignment-1);
3308   }
3309 #endif
3310 
3311 #ifndef TIERED
3312   // Tiered compilation is undefined.
3313   UNSUPPORTED_OPTION(TieredCompilation, "TieredCompilation");
3314 #endif
3315 
3316   // If we are running in a headless jre, force java.awt.headless property
3317   // to be true unless the property has already been set.
3318   // Also allow the OS environment variable JAVA_AWT_HEADLESS to set headless state.
3319   if (os::is_headless_jre()) {
3320     const char* headless = Arguments::get_property("java.awt.headless");
3321     if (headless == NULL) {
3322       char envbuffer[128];
3323       if (!os::getenv("JAVA_AWT_HEADLESS", envbuffer, sizeof(envbuffer))) {
3324         if (!add_property("java.awt.headless=true")) {
3325           return JNI_ENOMEM;
3326         }
3327       } else {
3328         char buffer[256];
3329         strcpy(buffer, "java.awt.headless=");
3330         strcat(buffer, envbuffer);
3331         if (!add_property(buffer)) {
3332           return JNI_ENOMEM;
3333         }
3334       }
3335     }
3336   }
3337 
3338   if (!check_vm_args_consistency()) {
3339     return JNI_ERR;
3340   }
3341 
3342   return JNI_OK;
3343 }
3344 
3345 jint Arguments::parse_java_options_environment_variable(SysClassPath* scp_p, bool* scp_assembly_required_p) {
3346   return parse_options_environment_variable("_JAVA_OPTIONS", scp_p,
3347                                             scp_assembly_required_p);
3348 }
3349 
3350 jint Arguments::parse_java_tool_options_environment_variable(SysClassPath* scp_p, bool* scp_assembly_required_p) {
3351   return parse_options_environment_variable("JAVA_TOOL_OPTIONS", scp_p,
3352                                             scp_assembly_required_p);
3353 }
3354 
3355 jint Arguments::parse_options_environment_variable(const char* name, SysClassPath* scp_p, bool* scp_assembly_required_p) {
3356   const int N_MAX_OPTIONS = 64;
3357   const int OPTION_BUFFER_SIZE = 1024;
3358   char buffer[OPTION_BUFFER_SIZE];
3359 
3360   // The variable will be ignored if it exceeds the length of the buffer.
3361   // Don't check this variable if user has special privileges
3362   // (e.g. unix su command).
3363   if (os::getenv(name, buffer, sizeof(buffer)) &amp;&amp;
3364       !os::have_special_privileges()) {
3365     JavaVMOption options[N_MAX_OPTIONS];      // Construct option array
3366     jio_fprintf(defaultStream::error_stream(),
3367                 "Picked up %s: %s\n", name, buffer);
3368     char* rd = buffer;                        // pointer to the input string (rd)
3369     int i;
3370     for (i = 0; i &lt; N_MAX_OPTIONS;) {         // repeat for all options in the input string
3371       while (isspace(*rd)) rd++;              // skip whitespace
3372       if (*rd == 0) break;                    // we re done when the input string is read completely
3373 
3374       // The output, option string, overwrites the input string.
3375       // Because of quoting, the pointer to the option string (wrt) may lag the pointer to
3376       // input string (rd).
3377       char* wrt = rd;
3378 
3379       options[i++].optionString = wrt;        // Fill in option
3380       while (*rd != 0 &amp;&amp; !isspace(*rd)) {     // unquoted strings terminate with a space or NULL
3381         if (*rd == '\'' || *rd == '"') {      // handle a quoted string
3382           int quote = *rd;                    // matching quote to look for
3383           rd++;                               // don't copy open quote
3384           while (*rd != quote) {              // include everything (even spaces) up until quote
3385             if (*rd == 0) {                   // string termination means unmatched string
3386               jio_fprintf(defaultStream::error_stream(),
3387                           "Unmatched quote in %s\n", name);
3388               return JNI_ERR;
3389             }
3390             *wrt++ = *rd++;                   // copy to option string
3391           }
3392           rd++;                               // don't copy close quote
3393         } else {
3394           *wrt++ = *rd++;                     // copy to option string
3395         }
3396       }
3397       // Need to check if we're done before writing a NULL,
3398       // because the write could be to the byte that rd is pointing to.
3399       if (*rd++ == 0) {
3400         *wrt = 0;
3401         break;
3402       }
3403       *wrt = 0;                               // Zero terminate option
3404     }
3405     // Construct JavaVMInitArgs structure and parse as if it was part of the command line
3406     JavaVMInitArgs vm_args;
3407     vm_args.version = JNI_VERSION_1_2;
3408     vm_args.options = options;
3409     vm_args.nOptions = i;
3410     vm_args.ignoreUnrecognized = IgnoreUnrecognizedVMOptions;
3411 
3412     if (PrintVMOptions) {
3413       const char* tail;
3414       for (int i = 0; i &lt; vm_args.nOptions; i++) {
3415         const JavaVMOption *option = vm_args.options + i;
3416         if (match_option(option, "-XX:", &amp;tail)) {
3417           logOption(tail);
3418         }
3419       }
3420     }
3421 
3422     return(parse_each_vm_init_arg(&amp;vm_args, scp_p, scp_assembly_required_p, Flag::ENVIRON_VAR));
3423   }
3424   return JNI_OK;
3425 }
3426 
3427 void Arguments::set_shared_spaces_flags() {
3428   if (DumpSharedSpaces) {
3429     if (RequireSharedSpaces) {
3430       warning("cannot dump shared archive while using shared archive");
3431     }
3432     UseSharedSpaces = false;
3433 #ifdef _LP64
3434     if (!UseCompressedOops || !UseCompressedClassPointers) {
3435       vm_exit_during_initialization(
3436         "Cannot dump shared archive when UseCompressedOops or UseCompressedClassPointers is off.", NULL);
3437     }
3438   } else {
3439     // UseCompressedOops and UseCompressedClassPointers must be on for UseSharedSpaces.
3440     if (!UseCompressedOops || !UseCompressedClassPointers) {
3441       no_shared_spaces();
3442     }
3443 #endif
3444   }
3445 }
3446 
3447 #if !INCLUDE_ALL_GCS
3448 static void force_serial_gc() {
3449   FLAG_SET_DEFAULT(UseSerialGC, true);
3450   FLAG_SET_DEFAULT(CMSIncrementalMode, false);  // special CMS suboption
3451   UNSUPPORTED_GC_OPTION(UseG1GC);
3452   UNSUPPORTED_GC_OPTION(UseParallelGC);
3453   UNSUPPORTED_GC_OPTION(UseParallelOldGC);
3454   UNSUPPORTED_GC_OPTION(UseConcMarkSweepGC);
3455   UNSUPPORTED_GC_OPTION(UseParNewGC);
3456 }
3457 #endif // INCLUDE_ALL_GCS
3458 
3459 // Sharing support
3460 // Construct the path to the archive
3461 static char* get_shared_archive_path() {
3462   char *shared_archive_path;
3463   if (SharedArchiveFile == NULL) {
3464     char jvm_path[JVM_MAXPATHLEN];
3465     os::jvm_path(jvm_path, sizeof(jvm_path));
3466     char *end = strrchr(jvm_path, *os::file_separator());
3467     if (end != NULL) *end = '\0';
3468     size_t jvm_path_len = strlen(jvm_path);
3469     size_t file_sep_len = strlen(os::file_separator());
3470     shared_archive_path = NEW_C_HEAP_ARRAY(char, jvm_path_len +
3471         file_sep_len + 20, mtInternal);
3472     if (shared_archive_path != NULL) {
3473       strncpy(shared_archive_path, jvm_path, jvm_path_len + 1);
3474       strncat(shared_archive_path, os::file_separator(), file_sep_len);
3475       strncat(shared_archive_path, "classes.jsa", 11);
3476     }
3477   } else {
3478     shared_archive_path = NEW_C_HEAP_ARRAY(char, strlen(SharedArchiveFile) + 1, mtInternal);
3479     if (shared_archive_path != NULL) {
3480       strncpy(shared_archive_path, SharedArchiveFile, strlen(SharedArchiveFile) + 1);
3481     }
3482   }
3483   return shared_archive_path;
3484 }
3485 
3486 #ifndef PRODUCT
3487 // Determine whether LogVMOutput should be implicitly turned on.
3488 static bool use_vm_log() {
3489   if (LogCompilation || !FLAG_IS_DEFAULT(LogFile) ||
3490       PrintCompilation || PrintInlining || PrintDependencies || PrintNativeNMethods ||
3491       PrintDebugInfo || PrintRelocations || PrintNMethods || PrintExceptionHandlers ||
3492       PrintAssembly || TraceDeoptimization || TraceDependencies ||
3493       (VerifyDependencies &amp;&amp; FLAG_IS_CMDLINE(VerifyDependencies))) {
3494     return true;
3495   }
3496 
3497 #ifdef COMPILER1
3498   if (PrintC1Statistics) {
3499     return true;
3500   }
3501 #endif // COMPILER1
3502 
3503 #ifdef COMPILER2
3504   if (PrintOptoAssembly || PrintOptoStatistics) {
3505     return true;
3506   }
3507 #endif // COMPILER2
3508 
3509   return false;
3510 }
3511 #endif // PRODUCT
3512 
3513 // Parse entry point called from JNI_CreateJavaVM
3514 
3515 jint Arguments::parse(const JavaVMInitArgs* args) {
3516 
3517   // Remaining part of option string
3518   const char* tail;
3519 
3520   // If flag "-XX:Flags=flags-file" is used it will be the first option to be processed.
3521   const char* hotspotrc = ".hotspotrc";
3522   bool settings_file_specified = false;
3523   bool needs_hotspotrc_warning = false;
3524 
3525   const char* flags_file;
3526   int index;
3527   for (index = 0; index &lt; args-&gt;nOptions; index++) {
3528     const JavaVMOption *option = args-&gt;options + index;
3529     if (match_option(option, "-XX:Flags=", &amp;tail)) {
3530       flags_file = tail;
3531       settings_file_specified = true;
3532     }
3533     if (match_option(option, "-XX:+PrintVMOptions", &amp;tail)) {
3534       PrintVMOptions = true;
3535     }
3536     if (match_option(option, "-XX:-PrintVMOptions", &amp;tail)) {
3537       PrintVMOptions = false;
3538     }
3539     if (match_option(option, "-XX:+IgnoreUnrecognizedVMOptions", &amp;tail)) {
3540       IgnoreUnrecognizedVMOptions = true;
3541     }
3542     if (match_option(option, "-XX:-IgnoreUnrecognizedVMOptions", &amp;tail)) {
3543       IgnoreUnrecognizedVMOptions = false;
3544     }
3545     if (match_option(option, "-XX:+PrintFlagsInitial", &amp;tail)) {
3546       CommandLineFlags::printFlags(tty, false);
3547       vm_exit(0);
3548     }
3549     if (match_option(option, "-XX:NativeMemoryTracking", &amp;tail)) {
3550 #if INCLUDE_NMT
3551       MemTracker::init_tracking_options(tail);
3552 #else
3553       jio_fprintf(defaultStream::error_stream(),
3554         "Native Memory Tracking is not supported in this VM\n");
3555       return JNI_ERR;
3556 #endif
3557     }
3558 
3559 
3560 #ifndef PRODUCT
3561     if (match_option(option, "-XX:+PrintFlagsWithComments", &amp;tail)) {
3562       CommandLineFlags::printFlags(tty, true);
3563       vm_exit(0);
3564     }
3565 #endif
3566   }
3567 
3568   if (IgnoreUnrecognizedVMOptions) {
3569     // uncast const to modify the flag args-&gt;ignoreUnrecognized
3570     *(jboolean*)(&amp;args-&gt;ignoreUnrecognized) = true;
3571   }
3572 
3573   // Parse specified settings file
3574   if (settings_file_specified) {
3575     if (!process_settings_file(flags_file, true, args-&gt;ignoreUnrecognized)) {
3576       return JNI_EINVAL;
3577     }
3578   } else {
3579 #ifdef ASSERT
3580     // Parse default .hotspotrc settings file
3581     if (!process_settings_file(".hotspotrc", false, args-&gt;ignoreUnrecognized)) {
3582       return JNI_EINVAL;
3583     }
3584 #else
3585     struct stat buf;
3586     if (os::stat(hotspotrc, &amp;buf) == 0) {
3587       needs_hotspotrc_warning = true;
3588     }
3589 #endif
3590   }
3591 
3592   if (PrintVMOptions) {
3593     for (index = 0; index &lt; args-&gt;nOptions; index++) {
3594       const JavaVMOption *option = args-&gt;options + index;
3595       if (match_option(option, "-XX:", &amp;tail)) {
3596         logOption(tail);
3597       }
3598     }
3599   }
3600 
3601   // Parse JavaVMInitArgs structure passed in, as well as JAVA_TOOL_OPTIONS and _JAVA_OPTIONS
3602   jint result = parse_vm_init_args(args);
3603   if (result != JNI_OK) {
3604     return result;
3605   }
3606 
3607   // Call get_shared_archive_path() here, after possible SharedArchiveFile option got parsed.
3608   SharedArchivePath = get_shared_archive_path();
3609   if (SharedArchivePath == NULL) {
3610     return JNI_ENOMEM;
3611   }
3612 
3613   // Delay warning until here so that we've had a chance to process
3614   // the -XX:-PrintWarnings flag
3615   if (needs_hotspotrc_warning) {
3616     warning("%s file is present but has been ignored.  "
3617             "Run with -XX:Flags=%s to load the file.",
3618             hotspotrc, hotspotrc);
3619   }
3620 
3621 #ifdef _ALLBSD_SOURCE  // UseLargePages is not yet supported on BSD.
3622   UNSUPPORTED_OPTION(UseLargePages, "-XX:+UseLargePages");
3623 #endif
3624 
3625 #if INCLUDE_ALL_GCS
3626   #if (defined JAVASE_EMBEDDED || defined ARM)
3627     UNSUPPORTED_OPTION(UseG1GC, "G1 GC");
3628   #endif
3629 #endif
3630 
3631 #ifndef PRODUCT
3632   if (TraceBytecodesAt != 0) {
3633     TraceBytecodes = true;
3634   }
3635   if (CountCompiledCalls) {
3636     if (UseCounterDecay) {
3637       warning("UseCounterDecay disabled because CountCalls is set");
3638       UseCounterDecay = false;
3639     }
3640   }
3641 #endif // PRODUCT
3642 
3643   // JSR 292 is not supported before 1.7
3644   if (!JDK_Version::is_gte_jdk17x_version()) {
3645     if (EnableInvokeDynamic) {
3646       if (!FLAG_IS_DEFAULT(EnableInvokeDynamic)) {
3647         warning("JSR 292 is not supported before 1.7.  Disabling support.");
3648       }
3649       EnableInvokeDynamic = false;
3650     }
3651   }
3652 
3653   if (EnableInvokeDynamic &amp;&amp; ScavengeRootsInCode == 0) {
3654     if (!FLAG_IS_DEFAULT(ScavengeRootsInCode)) {
3655       warning("forcing ScavengeRootsInCode non-zero because EnableInvokeDynamic is true");
3656     }
3657     ScavengeRootsInCode = 1;
3658   }
3659 
3660   if (PrintGCDetails) {
3661     // Turn on -verbose:gc options as well
3662     PrintGC = true;
3663   }
3664 
3665   if (!JDK_Version::is_gte_jdk18x_version()) {
3666     // To avoid changing the log format for 7 updates this flag is only
3667     // true by default in JDK8 and above.
3668     if (FLAG_IS_DEFAULT(PrintGCCause)) {
3669       FLAG_SET_DEFAULT(PrintGCCause, false);
3670     }
3671   }
3672 
3673   // Set object alignment values.
3674   set_object_alignment();
3675 
3676 #if !INCLUDE_ALL_GCS
3677   force_serial_gc();
3678 #endif // INCLUDE_ALL_GCS
3679 #if !INCLUDE_CDS
3680   if (DumpSharedSpaces || RequireSharedSpaces) {
3681     jio_fprintf(defaultStream::error_stream(),
3682       "Shared spaces are not supported in this VM\n");
3683     return JNI_ERR;
3684   }
3685   if ((UseSharedSpaces &amp;&amp; FLAG_IS_CMDLINE(UseSharedSpaces)) || PrintSharedSpaces) {
3686     warning("Shared spaces are not supported in this VM");
3687     FLAG_SET_DEFAULT(UseSharedSpaces, false);
3688     FLAG_SET_DEFAULT(PrintSharedSpaces, false);
3689   }
3690   no_shared_spaces();
3691 #endif // INCLUDE_CDS
3692 
3693   return JNI_OK;
3694 }
3695 
3696 jint Arguments::apply_ergo() {
3697 
3698   // Set flags based on ergonomics.
3699   set_ergonomics_flags();
3700 
3701   set_shared_spaces_flags();
3702 
3703   // Check the GC selections again.
3704   if (!check_gc_consistency()) {
3705     return JNI_EINVAL;
3706   }
3707 
3708   if (TieredCompilation) {
3709     set_tiered_flags();
3710   } else {
3711     // Check if the policy is valid. Policies 0 and 1 are valid for non-tiered setup.
3712     if (CompilationPolicyChoice &gt;= 2) {
3713       vm_exit_during_initialization(
3714         "Incompatible compilation policy selected", NULL);
3715     }
3716   }
3717   // Set NmethodSweepFraction after the size of the code cache is adapted (in case of tiered)
3718   if (FLAG_IS_DEFAULT(NmethodSweepFraction)) {
3719     FLAG_SET_DEFAULT(NmethodSweepFraction, 1 + ReservedCodeCacheSize / (16 * M));
3720   }
3721 
3722 
3723   // Set heap size based on available physical memory
3724   set_heap_size();
3725 
3726 #if INCLUDE_ALL_GCS
3727   // Set per-collector flags
3728   if (UseParallelGC || UseParallelOldGC) {
3729     set_parallel_gc_flags();
3730   } else if (UseConcMarkSweepGC) { // Should be done before ParNew check below
3731     set_cms_and_parnew_gc_flags();
3732   } else if (UseParNewGC) {  // Skipped if CMS is set above
3733     set_parnew_gc_flags();
3734   } else if (UseG1GC) {
3735     set_g1_gc_flags();
3736   }
3737   check_deprecated_gcs();
3738   check_deprecated_gc_flags();
3739   if (AssumeMP &amp;&amp; !UseSerialGC) {
3740     if (FLAG_IS_DEFAULT(ParallelGCThreads) &amp;&amp; ParallelGCThreads == 1) {
3741       warning("If the number of processors is expected to increase from one, then"
3742               " you should configure the number of parallel GC threads appropriately"
3743               " using -XX:ParallelGCThreads=N");
3744     }
3745   }
3746   if (MinHeapFreeRatio == 100) {
3747     // Keeping the heap 100% free is hard ;-) so limit it to 99%.
3748     FLAG_SET_ERGO(uintx, MinHeapFreeRatio, 99);
3749   }
3750 #else // INCLUDE_ALL_GCS
3751   assert(verify_serial_gc_flags(), "SerialGC unset");
3752 #endif // INCLUDE_ALL_GCS
3753 
3754   // Initialize Metaspace flags and alignments
3755   Metaspace::ergo_initialize();
3756 
3757   // Set bytecode rewriting flags
3758   set_bytecode_flags();
3759 
3760   // Set flags if Aggressive optimization flags (-XX:+AggressiveOpts) enabled
3761   set_aggressive_opts_flags();
3762 
3763   // Turn off biased locking for locking debug mode flags,
3764   // which are subtly different from each other but neither works with
3765   // biased locking
3766   if (UseHeavyMonitors
3767 #ifdef COMPILER1
3768       || !UseFastLocking
3769 #endif // COMPILER1
3770     ) {
3771     if (!FLAG_IS_DEFAULT(UseBiasedLocking) &amp;&amp; UseBiasedLocking) {
3772       // flag set to true on command line; warn the user that they
3773       // can't enable biased locking here
3774       warning("Biased Locking is not supported with locking debug flags"
3775               "; ignoring UseBiasedLocking flag." );
3776     }
3777     UseBiasedLocking = false;
3778   }
3779 
3780 #ifdef ZERO
3781   // Clear flags not supported on zero.
3782   FLAG_SET_DEFAULT(ProfileInterpreter, false);
3783   FLAG_SET_DEFAULT(UseBiasedLocking, false);
3784   LP64_ONLY(FLAG_SET_DEFAULT(UseCompressedOops, false));
3785   LP64_ONLY(FLAG_SET_DEFAULT(UseCompressedClassPointers, false));
3786 #endif // CC_INTERP
3787 
3788 #ifdef COMPILER2
3789   if (!EliminateLocks) {
3790     EliminateNestedLocks = false;
3791   }
3792   if (!Inline) {
3793     IncrementalInline = false;
3794   }
3795 #ifndef PRODUCT
3796   if (!IncrementalInline) {
3797     AlwaysIncrementalInline = false;
3798   }
3799 #endif
3800   if (!UseTypeSpeculation &amp;&amp; FLAG_IS_DEFAULT(TypeProfileLevel)) {
3801     // nothing to use the profiling, turn if off
3802     FLAG_SET_DEFAULT(TypeProfileLevel, 0);
3803   }
3804   if (UseTypeSpeculation &amp;&amp; FLAG_IS_DEFAULT(ReplaceInParentMaps)) {
3805     // Doing the replace in parent maps helps speculation
3806     FLAG_SET_DEFAULT(ReplaceInParentMaps, true);
3807   }
3808 #endif
3809 
3810   if (PrintAssembly &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
3811     warning("PrintAssembly is enabled; turning on DebugNonSafepoints to gain additional output");
3812     DebugNonSafepoints = true;
3813   }
3814 
3815   if (FLAG_IS_CMDLINE(CompressedClassSpaceSize) &amp;&amp; !UseCompressedClassPointers) {
3816     warning("Setting CompressedClassSpaceSize has no effect when compressed class pointers are not used");
3817   }
3818 
3819 #ifndef PRODUCT
3820   if (CompileTheWorld) {
3821     // Force NmethodSweeper to sweep whole CodeCache each time.
3822     if (FLAG_IS_DEFAULT(NmethodSweepFraction)) {
3823       NmethodSweepFraction = 1;
3824     }
3825   }
3826 
3827   if (!LogVMOutput &amp;&amp; FLAG_IS_DEFAULT(LogVMOutput)) {
3828     if (use_vm_log()) {
3829       LogVMOutput = true;
3830     }
3831   }
3832 #endif // PRODUCT
3833 
3834   if (PrintCommandLineFlags) {
3835     CommandLineFlags::printSetFlags(tty);
3836   }
3837 
3838   // Apply CPU specific policy for the BiasedLocking
3839   if (UseBiasedLocking) {
3840     if (!VM_Version::use_biased_locking() &amp;&amp;
3841         !(FLAG_IS_CMDLINE(UseBiasedLocking))) {
3842       UseBiasedLocking = false;
3843     }
3844   }
3845 #ifdef COMPILER2
3846   if (!UseBiasedLocking || EmitSync != 0) {
3847     UseOptoBiasInlining = false;
3848   }
3849 #endif
3850 
3851   return JNI_OK;
3852 }
3853 
3854 jint Arguments::adjust_after_os() {
3855   if (UseNUMA) {
3856     if (UseParallelGC || UseParallelOldGC) {
3857       if (FLAG_IS_DEFAULT(MinHeapDeltaBytes)) {
3858          FLAG_SET_DEFAULT(MinHeapDeltaBytes, 64*M);
3859       }
3860     }
3861     // UseNUMAInterleaving is set to ON for all collectors and
3862     // platforms when UseNUMA is set to ON. NUMA-aware collectors
3863     // such as the parallel collector for Linux and Solaris will
3864     // interleave old gen and survivor spaces on top of NUMA
3865     // allocation policy for the eden space.
3866     // Non NUMA-aware collectors such as CMS, G1 and Serial-GC on
3867     // all platforms and ParallelGC on Windows will interleave all
3868     // of the heap spaces across NUMA nodes.
3869     if (FLAG_IS_DEFAULT(UseNUMAInterleaving)) {
3870       FLAG_SET_ERGO(bool, UseNUMAInterleaving, true);
3871     }
3872   }
3873   return JNI_OK;
3874 }
3875 
3876 int Arguments::PropertyList_count(SystemProperty* pl) {
3877   int count = 0;
3878   while(pl != NULL) {
3879     count++;
3880     pl = pl-&gt;next();
3881   }
3882   return count;
3883 }
3884 
3885 const char* Arguments::PropertyList_get_value(SystemProperty *pl, const char* key) {
3886   assert(key != NULL, "just checking");
3887   SystemProperty* prop;
3888   for (prop = pl; prop != NULL; prop = prop-&gt;next()) {
3889     if (strcmp(key, prop-&gt;key()) == 0) return prop-&gt;value();
3890   }
3891   return NULL;
3892 }
3893 
3894 const char* Arguments::PropertyList_get_key_at(SystemProperty *pl, int index) {
3895   int count = 0;
3896   const char* ret_val = NULL;
3897 
3898   while(pl != NULL) {
3899     if(count &gt;= index) {
3900       ret_val = pl-&gt;key();
3901       break;
3902     }
3903     count++;
3904     pl = pl-&gt;next();
3905   }
3906 
3907   return ret_val;
3908 }
3909 
3910 char* Arguments::PropertyList_get_value_at(SystemProperty* pl, int index) {
3911   int count = 0;
3912   char* ret_val = NULL;
3913 
3914   while(pl != NULL) {
3915     if(count &gt;= index) {
3916       ret_val = pl-&gt;value();
3917       break;
3918     }
3919     count++;
3920     pl = pl-&gt;next();
3921   }
3922 
3923   return ret_val;
3924 }
3925 
3926 void Arguments::PropertyList_add(SystemProperty** plist, SystemProperty *new_p) {
3927   SystemProperty* p = *plist;
3928   if (p == NULL) {
3929     *plist = new_p;
3930   } else {
3931     while (p-&gt;next() != NULL) {
3932       p = p-&gt;next();
3933     }
3934     p-&gt;set_next(new_p);
3935   }
3936 }
3937 
3938 void Arguments::PropertyList_add(SystemProperty** plist, const char* k, char* v) {
3939   if (plist == NULL)
3940     return;
3941 
3942   SystemProperty* new_p = new SystemProperty(k, v, true);
3943   PropertyList_add(plist, new_p);
3944 }
3945 
3946 // This add maintains unique property key in the list.
3947 void Arguments::PropertyList_unique_add(SystemProperty** plist, const char* k, char* v, jboolean append) {
3948   if (plist == NULL)
3949     return;
3950 
3951   // If property key exist then update with new value.
3952   SystemProperty* prop;
3953   for (prop = *plist; prop != NULL; prop = prop-&gt;next()) {
3954     if (strcmp(k, prop-&gt;key()) == 0) {
3955       if (append) {
3956         prop-&gt;append_value(v);
3957       } else {
3958         prop-&gt;set_value(v);
3959       }
3960       return;
3961     }
3962   }
3963 
3964   PropertyList_add(plist, k, v);
3965 }
3966 
3967 // Copies src into buf, replacing "%%" with "%" and "%p" with pid
3968 // Returns true if all of the source pointed by src has been copied over to
3969 // the destination buffer pointed by buf. Otherwise, returns false.
3970 // Notes:
3971 // 1. If the length (buflen) of the destination buffer excluding the
3972 // NULL terminator character is not long enough for holding the expanded
3973 // pid characters, it also returns false instead of returning the partially
3974 // expanded one.
3975 // 2. The passed in "buflen" should be large enough to hold the null terminator.
3976 bool Arguments::copy_expand_pid(const char* src, size_t srclen,
3977                                 char* buf, size_t buflen) {
3978   const char* p = src;
3979   char* b = buf;
3980   const char* src_end = &amp;src[srclen];
3981   char* buf_end = &amp;buf[buflen - 1];
3982 
3983   while (p &lt; src_end &amp;&amp; b &lt; buf_end) {
3984     if (*p == '%') {
3985       switch (*(++p)) {
3986       case '%':         // "%%" ==&gt; "%"
3987         *b++ = *p++;
3988         break;
3989       case 'p':  {       //  "%p" ==&gt; current process id
3990         // buf_end points to the character before the last character so
3991         // that we could write '\0' to the end of the buffer.
3992         size_t buf_sz = buf_end - b + 1;
3993         int ret = jio_snprintf(b, buf_sz, "%d", os::current_process_id());
3994 
3995         // if jio_snprintf fails or the buffer is not long enough to hold
3996         // the expanded pid, returns false.
3997         if (ret &lt; 0 || ret &gt;= (int)buf_sz) {
3998           return false;
3999         } else {
4000           b += ret;
4001           assert(*b == '\0', "fail in copy_expand_pid");
4002           if (p == src_end &amp;&amp; b == buf_end + 1) {
4003             // reach the end of the buffer.
4004             return true;
4005           }
4006         }
4007         p++;
4008         break;
4009       }
4010       default :
4011         *b++ = '%';
4012       }
4013     } else {
4014       *b++ = *p++;
4015     }
4016   }
4017   *b = '\0';
4018   return (p == src_end); // return false if not all of the source was copied
4019 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
