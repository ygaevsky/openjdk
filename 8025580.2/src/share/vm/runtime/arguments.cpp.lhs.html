<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 #include "classfile/javaAssertions.hpp"
  27 #include "classfile/symbolTable.hpp"
  28 #include "compiler/compilerOracle.hpp"
  29 #include "memory/allocation.inline.hpp"
  30 #include "memory/cardTableRS.hpp"
  31 #include "memory/genCollectedHeap.hpp"
  32 #include "memory/referenceProcessor.hpp"
  33 #include "memory/universe.inline.hpp"
  34 #include "oops/oop.inline.hpp"
  35 #include "prims/jvmtiExport.hpp"
  36 #include "runtime/arguments.hpp"
  37 #include "runtime/globals_extension.hpp"
  38 #include "runtime/java.hpp"
  39 #include "services/management.hpp"
  40 #include "services/memTracker.hpp"
  41 #include "utilities/defaultStream.hpp"
  42 #include "utilities/macros.hpp"
  43 #include "utilities/taskqueue.hpp"
  44 #ifdef TARGET_OS_FAMILY_linux
  45 # include "os_linux.inline.hpp"
  46 #endif
  47 #ifdef TARGET_OS_FAMILY_solaris
  48 # include "os_solaris.inline.hpp"
  49 #endif
  50 #ifdef TARGET_OS_FAMILY_windows
  51 # include "os_windows.inline.hpp"
  52 #endif
  53 #ifdef TARGET_OS_FAMILY_aix
  54 # include "os_aix.inline.hpp"
  55 #endif
  56 #ifdef TARGET_OS_FAMILY_bsd
  57 # include "os_bsd.inline.hpp"
  58 #endif
  59 #if INCLUDE_ALL_GCS
  60 #include "gc_implementation/concurrentMarkSweep/compactibleFreeListSpace.hpp"
  61 #include "gc_implementation/g1/g1CollectedHeap.inline.hpp"
  62 #include "gc_implementation/parallelScavenge/parallelScavengeHeap.hpp"
  63 #endif // INCLUDE_ALL_GCS
  64 
  65 // Note: This is a special bug reporting site for the JVM
  66 #define DEFAULT_VENDOR_URL_BUG "http://bugreport.sun.com/bugreport/crash.jsp"
  67 #define DEFAULT_JAVA_LAUNCHER  "generic"
  68 
  69 // Disable options not supported in this release, with a warning if they
  70 // were explicitly requested on the command-line
  71 #define UNSUPPORTED_OPTION(opt, description)                    \
  72 do {                                                            \
  73   if (opt) {                                                    \
  74     if (FLAG_IS_CMDLINE(opt)) {                                 \
  75       warning(description " is disabled in this release.");     \
  76     }                                                           \
  77     FLAG_SET_DEFAULT(opt, false);                               \
  78   }                                                             \
  79 } while(0)
  80 
  81 #define UNSUPPORTED_GC_OPTION(gc)                                     \
  82 do {                                                                  \
  83   if (gc) {                                                           \
  84     if (FLAG_IS_CMDLINE(gc)) {                                        \
  85       warning(#gc " is not supported in this VM.  Using Serial GC."); \
  86     }                                                                 \
  87     FLAG_SET_DEFAULT(gc, false);                                      \
  88   }                                                                   \
  89 } while(0)
  90 
  91 char**  Arguments::_jvm_flags_array             = NULL;
  92 int     Arguments::_num_jvm_flags               = 0;
  93 char**  Arguments::_jvm_args_array              = NULL;
  94 int     Arguments::_num_jvm_args                = 0;
  95 char*  Arguments::_java_command                 = NULL;
  96 SystemProperty* Arguments::_system_properties   = NULL;
  97 const char*  Arguments::_gc_log_filename        = NULL;
  98 bool   Arguments::_has_profile                  = false;
  99 size_t Arguments::_conservative_max_heap_alignment = 0;
 100 uintx  Arguments::_min_heap_size                = 0;
 101 Arguments::Mode Arguments::_mode                = _mixed;
 102 bool   Arguments::_java_compiler                = false;
 103 bool   Arguments::_xdebug_mode                  = false;
 104 const char*  Arguments::_java_vendor_url_bug    = DEFAULT_VENDOR_URL_BUG;
 105 const char*  Arguments::_sun_java_launcher      = DEFAULT_JAVA_LAUNCHER;
 106 int    Arguments::_sun_java_launcher_pid        = -1;
 107 bool   Arguments::_sun_java_launcher_is_altjvm  = false;
 108 
 109 // These parameters are reset in method parse_vm_init_args(JavaVMInitArgs*)
 110 bool   Arguments::_AlwaysCompileLoopMethods     = AlwaysCompileLoopMethods;
 111 bool   Arguments::_UseOnStackReplacement        = UseOnStackReplacement;
 112 bool   Arguments::_BackgroundCompilation        = BackgroundCompilation;
 113 bool   Arguments::_ClipInlining                 = ClipInlining;
 114 
 115 char*  Arguments::SharedArchivePath             = NULL;
 116 
 117 AgentLibraryList Arguments::_libraryList;
 118 AgentLibraryList Arguments::_agentList;
 119 
 120 abort_hook_t     Arguments::_abort_hook         = NULL;
 121 exit_hook_t      Arguments::_exit_hook          = NULL;
 122 vfprintf_hook_t  Arguments::_vfprintf_hook      = NULL;
 123 
 124 
 125 SystemProperty *Arguments::_java_ext_dirs = NULL;
 126 SystemProperty *Arguments::_java_endorsed_dirs = NULL;
 127 SystemProperty *Arguments::_sun_boot_library_path = NULL;
 128 SystemProperty *Arguments::_java_library_path = NULL;
 129 SystemProperty *Arguments::_java_home = NULL;
 130 SystemProperty *Arguments::_java_class_path = NULL;
 131 SystemProperty *Arguments::_sun_boot_class_path = NULL;
 132 
 133 char* Arguments::_meta_index_path = NULL;
 134 char* Arguments::_meta_index_dir = NULL;
 135 
 136 // Check if head of 'option' matches 'name', and sets 'tail' remaining part of option string
 137 
 138 static bool match_option(const JavaVMOption *option, const char* name,
 139                          const char** tail) {
 140   int len = (int)strlen(name);
 141   if (strncmp(option-&gt;optionString, name, len) == 0) {
 142     *tail = option-&gt;optionString + len;
 143     return true;
 144   } else {
 145     return false;
 146   }
 147 }
 148 
 149 static void logOption(const char* opt) {
 150   if (PrintVMOptions) {
 151     jio_fprintf(defaultStream::output_stream(), "VM option '%s'\n", opt);
 152   }
 153 }
 154 
 155 // Process java launcher properties.
 156 void Arguments::process_sun_java_launcher_properties(JavaVMInitArgs* args) {
 157   // See if sun.java.launcher, sun.java.launcher.is_altjvm or
 158   // sun.java.launcher.pid is defined.
 159   // Must do this before setting up other system properties,
 160   // as some of them may depend on launcher type.
 161   for (int index = 0; index &lt; args-&gt;nOptions; index++) {
 162     const JavaVMOption* option = args-&gt;options + index;
 163     const char* tail;
 164 
 165     if (match_option(option, "-Dsun.java.launcher=", &amp;tail)) {
 166       process_java_launcher_argument(tail, option-&gt;extraInfo);
 167       continue;
 168     }
 169     if (match_option(option, "-Dsun.java.launcher.is_altjvm=", &amp;tail)) {
 170       if (strcmp(tail, "true") == 0) {
 171         _sun_java_launcher_is_altjvm = true;
 172       }
 173       continue;
 174     }
 175     if (match_option(option, "-Dsun.java.launcher.pid=", &amp;tail)) {
 176       _sun_java_launcher_pid = atoi(tail);
 177       continue;
 178     }
 179   }
 180 }
 181 
 182 // Initialize system properties key and value.
 183 void Arguments::init_system_properties() {
 184 
 185   PropertyList_add(&amp;_system_properties, new SystemProperty("java.vm.specification.name",
 186                                                                  "Java Virtual Machine Specification",  false));
 187   PropertyList_add(&amp;_system_properties, new SystemProperty("java.vm.version", VM_Version::vm_release(),  false));
 188   PropertyList_add(&amp;_system_properties, new SystemProperty("java.vm.name", VM_Version::vm_name(),  false));
 189   PropertyList_add(&amp;_system_properties, new SystemProperty("java.vm.info", VM_Version::vm_info_string(),  true));
 190 
 191   // Following are JVMTI agent writable properties.
 192   // Properties values are set to NULL and they are
 193   // os specific they are initialized in os::init_system_properties_values().
 194   _java_ext_dirs = new SystemProperty("java.ext.dirs", NULL,  true);
 195   _java_endorsed_dirs = new SystemProperty("java.endorsed.dirs", NULL,  true);
 196   _sun_boot_library_path = new SystemProperty("sun.boot.library.path", NULL,  true);
 197   _java_library_path = new SystemProperty("java.library.path", NULL,  true);
 198   _java_home =  new SystemProperty("java.home", NULL,  true);
 199   _sun_boot_class_path = new SystemProperty("sun.boot.class.path", NULL,  true);
 200 
 201   _java_class_path = new SystemProperty("java.class.path", "",  true);
 202 
 203   // Add to System Property list.
 204   PropertyList_add(&amp;_system_properties, _java_ext_dirs);
 205   PropertyList_add(&amp;_system_properties, _java_endorsed_dirs);
 206   PropertyList_add(&amp;_system_properties, _sun_boot_library_path);
 207   PropertyList_add(&amp;_system_properties, _java_library_path);
 208   PropertyList_add(&amp;_system_properties, _java_home);
 209   PropertyList_add(&amp;_system_properties, _java_class_path);
 210   PropertyList_add(&amp;_system_properties, _sun_boot_class_path);
 211 
 212   // Set OS specific system properties values
 213   os::init_system_properties_values();
 214 }
 215 
 216 
 217   // Update/Initialize System properties after JDK version number is known
 218 void Arguments::init_version_specific_system_properties() {
 219   enum { bufsz = 16 };
 220   char buffer[bufsz];
 221   const char* spec_vendor = "Sun Microsystems Inc.";
 222   uint32_t spec_version = 0;
 223 
 224   if (JDK_Version::is_gte_jdk17x_version()) {
 225     spec_vendor = "Oracle Corporation";
 226     spec_version = JDK_Version::current().major_version();
 227   }
 228   jio_snprintf(buffer, bufsz, "1." UINT32_FORMAT, spec_version);
 229 
 230   PropertyList_add(&amp;_system_properties,
 231       new SystemProperty("java.vm.specification.vendor",  spec_vendor, false));
 232   PropertyList_add(&amp;_system_properties,
 233       new SystemProperty("java.vm.specification.version", buffer, false));
 234   PropertyList_add(&amp;_system_properties,
 235       new SystemProperty("java.vm.vendor", VM_Version::vm_vendor(),  false));
 236 }
 237 
 238 /**
 239  * Provide a slightly more user-friendly way of eliminating -XX flags.
 240  * When a flag is eliminated, it can be added to this list in order to
 241  * continue accepting this flag on the command-line, while issuing a warning
 242  * and ignoring the value.  Once the JDK version reaches the 'accept_until'
 243  * limit, we flatly refuse to admit the existence of the flag.  This allows
 244  * a flag to die correctly over JDK releases using HSX.
 245  */
 246 typedef struct {
 247   const char* name;
 248   JDK_Version obsoleted_in; // when the flag went away
 249   JDK_Version accept_until; // which version to start denying the existence
 250 } ObsoleteFlag;
 251 
 252 static ObsoleteFlag obsolete_jvm_flags[] = {
 253   { "UseTrainGC",                    JDK_Version::jdk(5), JDK_Version::jdk(7) },
 254   { "UseSpecialLargeObjectHandling", JDK_Version::jdk(5), JDK_Version::jdk(7) },
 255   { "UseOversizedCarHandling",       JDK_Version::jdk(5), JDK_Version::jdk(7) },
 256   { "TraceCarAllocation",            JDK_Version::jdk(5), JDK_Version::jdk(7) },
 257   { "PrintTrainGCProcessingStats",   JDK_Version::jdk(5), JDK_Version::jdk(7) },
 258   { "LogOfCarSpaceSize",             JDK_Version::jdk(5), JDK_Version::jdk(7) },
 259   { "OversizedCarThreshold",         JDK_Version::jdk(5), JDK_Version::jdk(7) },
 260   { "MinTickInterval",               JDK_Version::jdk(5), JDK_Version::jdk(7) },
 261   { "DefaultTickInterval",           JDK_Version::jdk(5), JDK_Version::jdk(7) },
 262   { "MaxTickInterval",               JDK_Version::jdk(5), JDK_Version::jdk(7) },
 263   { "DelayTickAdjustment",           JDK_Version::jdk(5), JDK_Version::jdk(7) },
 264   { "ProcessingToTenuringRatio",     JDK_Version::jdk(5), JDK_Version::jdk(7) },
 265   { "MinTrainLength",                JDK_Version::jdk(5), JDK_Version::jdk(7) },
 266   { "AppendRatio",         JDK_Version::jdk_update(6,10), JDK_Version::jdk(7) },
 267   { "DefaultMaxRAM",       JDK_Version::jdk_update(6,18), JDK_Version::jdk(7) },
 268   { "DefaultInitialRAMFraction",
 269                            JDK_Version::jdk_update(6,18), JDK_Version::jdk(7) },
 270   { "UseDepthFirstScavengeOrder",
 271                            JDK_Version::jdk_update(6,22), JDK_Version::jdk(7) },
 272   { "HandlePromotionFailure",
 273                            JDK_Version::jdk_update(6,24), JDK_Version::jdk(8) },
 274   { "MaxLiveObjectEvacuationRatio",
 275                            JDK_Version::jdk_update(6,24), JDK_Version::jdk(8) },
 276   { "ForceSharedSpaces",   JDK_Version::jdk_update(6,25), JDK_Version::jdk(8) },
 277   { "UseParallelOldGCCompacting",
 278                            JDK_Version::jdk_update(6,27), JDK_Version::jdk(8) },
 279   { "UseParallelDensePrefixUpdate",
 280                            JDK_Version::jdk_update(6,27), JDK_Version::jdk(8) },
 281   { "UseParallelOldGCDensePrefix",
 282                            JDK_Version::jdk_update(6,27), JDK_Version::jdk(8) },
 283   { "AllowTransitionalJSR292",       JDK_Version::jdk(7), JDK_Version::jdk(8) },
 284   { "UseCompressedStrings",          JDK_Version::jdk(7), JDK_Version::jdk(8) },
 285   { "CMSPermGenPrecleaningEnabled", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 286   { "CMSTriggerPermRatio", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 287   { "CMSInitiatingPermOccupancyFraction", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 288   { "AdaptivePermSizeWeight", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 289   { "PermGenPadding", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 290   { "PermMarkSweepDeadRatio", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 291   { "PermSize", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 292   { "MaxPermSize", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 293   { "MinPermHeapExpansion", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 294   { "MaxPermHeapExpansion", JDK_Version::jdk(8),  JDK_Version::jdk(9) },
 295   { "CMSRevisitStackSize",           JDK_Version::jdk(8), JDK_Version::jdk(9) },
 296   { "PrintRevisitStats",             JDK_Version::jdk(8), JDK_Version::jdk(9) },
 297   { "UseVectoredExceptions",         JDK_Version::jdk(8), JDK_Version::jdk(9) },
 298   { "UseSplitVerifier",              JDK_Version::jdk(8), JDK_Version::jdk(9) },
 299   { "UseISM",                        JDK_Version::jdk(8), JDK_Version::jdk(9) },
 300   { "UsePermISM",                    JDK_Version::jdk(8), JDK_Version::jdk(9) },
 301   { "UseMPSS",                       JDK_Version::jdk(8), JDK_Version::jdk(9) },
 302   { "UseStringCache",                JDK_Version::jdk(8), JDK_Version::jdk(9) },
 303   { "UseOldInlining",                JDK_Version::jdk(9), JDK_Version::jdk(10) },
 304   { "SafepointPollOffset",           JDK_Version::jdk(9), JDK_Version::jdk(10) },
 305 #ifdef PRODUCT
 306   { "DesiredMethodLimit",
 307                            JDK_Version::jdk_update(7, 2), JDK_Version::jdk(8) },
 308 #endif // PRODUCT
 309   { "UseVMInterruptibleIO",          JDK_Version::jdk(8), JDK_Version::jdk(9) },
 310   { "UseBoundThreads",               JDK_Version::jdk(9), JDK_Version::jdk(10) },
 311   { "DefaultThreadPriority",         JDK_Version::jdk(9), JDK_Version::jdk(10) },
 312   { "NoYieldsInMicrolock",           JDK_Version::jdk(9), JDK_Version::jdk(10) },
<a name="1" id="anc1"></a>


 313   { NULL, JDK_Version(0), JDK_Version(0) }
 314 };
 315 
 316 // Returns true if the flag is obsolete and fits into the range specified
 317 // for being ignored.  In the case that the flag is ignored, the 'version'
 318 // value is filled in with the version number when the flag became
 319 // obsolete so that that value can be displayed to the user.
 320 bool Arguments::is_newly_obsolete(const char *s, JDK_Version* version) {
 321   int i = 0;
 322   assert(version != NULL, "Must provide a version buffer");
 323   while (obsolete_jvm_flags[i].name != NULL) {
 324     const ObsoleteFlag&amp; flag_status = obsolete_jvm_flags[i];
 325     // &lt;flag&gt;=xxx form
 326     // [-|+]&lt;flag&gt; form
 327     if ((strncmp(flag_status.name, s, strlen(flag_status.name)) == 0) ||
 328         ((s[0] == '+' || s[0] == '-') &amp;&amp;
 329         (strncmp(flag_status.name, &amp;s[1], strlen(flag_status.name)) == 0))) {
 330       if (JDK_Version::current().compare(flag_status.accept_until) == -1) {
 331           *version = flag_status.obsoleted_in;
 332           return true;
 333       }
 334     }
 335     i++;
 336   }
 337   return false;
 338 }
 339 
 340 // Constructs the system class path (aka boot class path) from the following
 341 // components, in order:
 342 //
 343 //     prefix           // from -Xbootclasspath/p:...
 344 //     endorsed         // the expansion of -Djava.endorsed.dirs=...
 345 //     base             // from os::get_system_properties() or -Xbootclasspath=
 346 //     suffix           // from -Xbootclasspath/a:...
 347 //
 348 // java.endorsed.dirs is a list of directories; any jar or zip files in the
 349 // directories are added to the sysclasspath just before the base.
 350 //
 351 // This could be AllStatic, but it isn't needed after argument processing is
 352 // complete.
 353 class SysClassPath: public StackObj {
 354 public:
 355   SysClassPath(const char* base);
 356   ~SysClassPath();
 357 
 358   inline void set_base(const char* base);
 359   inline void add_prefix(const char* prefix);
 360   inline void add_suffix_to_prefix(const char* suffix);
 361   inline void add_suffix(const char* suffix);
 362   inline void reset_path(const char* base);
 363 
 364   // Expand the jar/zip files in each directory listed by the java.endorsed.dirs
 365   // property.  Must be called after all command-line arguments have been
 366   // processed (in particular, -Djava.endorsed.dirs=...) and before calling
 367   // combined_path().
 368   void expand_endorsed();
 369 
 370   inline const char* get_base()     const { return _items[_scp_base]; }
 371   inline const char* get_prefix()   const { return _items[_scp_prefix]; }
 372   inline const char* get_suffix()   const { return _items[_scp_suffix]; }
 373   inline const char* get_endorsed() const { return _items[_scp_endorsed]; }
 374 
 375   // Combine all the components into a single c-heap-allocated string; caller
 376   // must free the string if/when no longer needed.
 377   char* combined_path();
 378 
 379 private:
 380   // Utility routines.
 381   static char* add_to_path(const char* path, const char* str, bool prepend);
 382   static char* add_jars_to_path(char* path, const char* directory);
 383 
 384   inline void reset_item_at(int index);
 385 
 386   // Array indices for the items that make up the sysclasspath.  All except the
 387   // base are allocated in the C heap and freed by this class.
 388   enum {
 389     _scp_prefix,        // from -Xbootclasspath/p:...
 390     _scp_endorsed,      // the expansion of -Djava.endorsed.dirs=...
 391     _scp_base,          // the default sysclasspath
 392     _scp_suffix,        // from -Xbootclasspath/a:...
 393     _scp_nitems         // the number of items, must be last.
 394   };
 395 
 396   const char* _items[_scp_nitems];
 397   DEBUG_ONLY(bool _expansion_done;)
 398 };
 399 
 400 SysClassPath::SysClassPath(const char* base) {
 401   memset(_items, 0, sizeof(_items));
 402   _items[_scp_base] = base;
 403   DEBUG_ONLY(_expansion_done = false;)
 404 }
 405 
 406 SysClassPath::~SysClassPath() {
 407   // Free everything except the base.
 408   for (int i = 0; i &lt; _scp_nitems; ++i) {
 409     if (i != _scp_base) reset_item_at(i);
 410   }
 411   DEBUG_ONLY(_expansion_done = false;)
 412 }
 413 
 414 inline void SysClassPath::set_base(const char* base) {
 415   _items[_scp_base] = base;
 416 }
 417 
 418 inline void SysClassPath::add_prefix(const char* prefix) {
 419   _items[_scp_prefix] = add_to_path(_items[_scp_prefix], prefix, true);
 420 }
 421 
 422 inline void SysClassPath::add_suffix_to_prefix(const char* suffix) {
 423   _items[_scp_prefix] = add_to_path(_items[_scp_prefix], suffix, false);
 424 }
 425 
 426 inline void SysClassPath::add_suffix(const char* suffix) {
 427   _items[_scp_suffix] = add_to_path(_items[_scp_suffix], suffix, false);
 428 }
 429 
 430 inline void SysClassPath::reset_item_at(int index) {
 431   assert(index &lt; _scp_nitems &amp;&amp; index != _scp_base, "just checking");
 432   if (_items[index] != NULL) {
 433     FREE_C_HEAP_ARRAY(char, _items[index], mtInternal);
 434     _items[index] = NULL;
 435   }
 436 }
 437 
 438 inline void SysClassPath::reset_path(const char* base) {
 439   // Clear the prefix and suffix.
 440   reset_item_at(_scp_prefix);
 441   reset_item_at(_scp_suffix);
 442   set_base(base);
 443 }
 444 
 445 //------------------------------------------------------------------------------
 446 
 447 void SysClassPath::expand_endorsed() {
 448   assert(_items[_scp_endorsed] == NULL, "can only be called once.");
 449 
 450   const char* path = Arguments::get_property("java.endorsed.dirs");
 451   if (path == NULL) {
 452     path = Arguments::get_endorsed_dir();
 453     assert(path != NULL, "no default for java.endorsed.dirs");
 454   }
 455 
 456   char* expanded_path = NULL;
 457   const char separator = *os::path_separator();
 458   const char* const end = path + strlen(path);
 459   while (path &lt; end) {
 460     const char* tmp_end = strchr(path, separator);
 461     if (tmp_end == NULL) {
 462       expanded_path = add_jars_to_path(expanded_path, path);
 463       path = end;
 464     } else {
 465       char* dirpath = NEW_C_HEAP_ARRAY(char, tmp_end - path + 1, mtInternal);
 466       memcpy(dirpath, path, tmp_end - path);
 467       dirpath[tmp_end - path] = '\0';
 468       expanded_path = add_jars_to_path(expanded_path, dirpath);
 469       FREE_C_HEAP_ARRAY(char, dirpath, mtInternal);
 470       path = tmp_end + 1;
 471     }
 472   }
 473   _items[_scp_endorsed] = expanded_path;
 474   DEBUG_ONLY(_expansion_done = true;)
 475 }
 476 
 477 // Combine the bootclasspath elements, some of which may be null, into a single
 478 // c-heap-allocated string.
 479 char* SysClassPath::combined_path() {
 480   assert(_items[_scp_base] != NULL, "empty default sysclasspath");
 481   assert(_expansion_done, "must call expand_endorsed() first.");
 482 
 483   size_t lengths[_scp_nitems];
 484   size_t total_len = 0;
 485 
 486   const char separator = *os::path_separator();
 487 
 488   // Get the lengths.
 489   int i;
 490   for (i = 0; i &lt; _scp_nitems; ++i) {
 491     if (_items[i] != NULL) {
 492       lengths[i] = strlen(_items[i]);
 493       // Include space for the separator char (or a NULL for the last item).
 494       total_len += lengths[i] + 1;
 495     }
 496   }
 497   assert(total_len &gt; 0, "empty sysclasspath not allowed");
 498 
 499   // Copy the _items to a single string.
 500   char* cp = NEW_C_HEAP_ARRAY(char, total_len, mtInternal);
 501   char* cp_tmp = cp;
 502   for (i = 0; i &lt; _scp_nitems; ++i) {
 503     if (_items[i] != NULL) {
 504       memcpy(cp_tmp, _items[i], lengths[i]);
 505       cp_tmp += lengths[i];
 506       *cp_tmp++ = separator;
 507     }
 508   }
 509   *--cp_tmp = '\0';     // Replace the extra separator.
 510   return cp;
 511 }
 512 
 513 // Note:  path must be c-heap-allocated (or NULL); it is freed if non-null.
 514 char*
 515 SysClassPath::add_to_path(const char* path, const char* str, bool prepend) {
 516   char *cp;
 517 
 518   assert(str != NULL, "just checking");
 519   if (path == NULL) {
 520     size_t len = strlen(str) + 1;
 521     cp = NEW_C_HEAP_ARRAY(char, len, mtInternal);
 522     memcpy(cp, str, len);                       // copy the trailing null
 523   } else {
 524     const char separator = *os::path_separator();
 525     size_t old_len = strlen(path);
 526     size_t str_len = strlen(str);
 527     size_t len = old_len + str_len + 2;
 528 
 529     if (prepend) {
 530       cp = NEW_C_HEAP_ARRAY(char, len, mtInternal);
 531       char* cp_tmp = cp;
 532       memcpy(cp_tmp, str, str_len);
 533       cp_tmp += str_len;
 534       *cp_tmp = separator;
 535       memcpy(++cp_tmp, path, old_len + 1);      // copy the trailing null
 536       FREE_C_HEAP_ARRAY(char, path, mtInternal);
 537     } else {
 538       cp = REALLOC_C_HEAP_ARRAY(char, path, len, mtInternal);
 539       char* cp_tmp = cp + old_len;
 540       *cp_tmp = separator;
 541       memcpy(++cp_tmp, str, str_len + 1);       // copy the trailing null
 542     }
 543   }
 544   return cp;
 545 }
 546 
 547 // Scan the directory and append any jar or zip files found to path.
 548 // Note:  path must be c-heap-allocated (or NULL); it is freed if non-null.
 549 char* SysClassPath::add_jars_to_path(char* path, const char* directory) {
 550   DIR* dir = os::opendir(directory);
 551   if (dir == NULL) return path;
 552 
 553   char dir_sep[2] = { '\0', '\0' };
 554   size_t directory_len = strlen(directory);
 555   const char fileSep = *os::file_separator();
 556   if (directory[directory_len - 1] != fileSep) dir_sep[0] = fileSep;
 557 
 558   /* Scan the directory for jars/zips, appending them to path. */
 559   struct dirent *entry;
 560   char *dbuf = NEW_C_HEAP_ARRAY(char, os::readdir_buf_size(directory), mtInternal);
 561   while ((entry = os::readdir(dir, (dirent *) dbuf)) != NULL) {
 562     const char* name = entry-&gt;d_name;
 563     const char* ext = name + strlen(name) - 4;
 564     bool isJarOrZip = ext &gt; name &amp;&amp;
 565       (os::file_name_strcmp(ext, ".jar") == 0 ||
 566        os::file_name_strcmp(ext, ".zip") == 0);
 567     if (isJarOrZip) {
 568       char* jarpath = NEW_C_HEAP_ARRAY(char, directory_len + 2 + strlen(name), mtInternal);
 569       sprintf(jarpath, "%s%s%s", directory, dir_sep, name);
 570       path = add_to_path(path, jarpath, false);
 571       FREE_C_HEAP_ARRAY(char, jarpath, mtInternal);
 572     }
 573   }
 574   FREE_C_HEAP_ARRAY(char, dbuf, mtInternal);
 575   os::closedir(dir);
 576   return path;
 577 }
 578 
 579 // Parses a memory size specification string.
 580 static bool atomull(const char *s, julong* result) {
 581   julong n = 0;
 582   int args_read = sscanf(s, JULONG_FORMAT, &amp;n);
 583   if (args_read != 1) {
 584     return false;
 585   }
 586   while (*s != '\0' &amp;&amp; isdigit(*s)) {
 587     s++;
 588   }
 589   // 4705540: illegal if more characters are found after the first non-digit
 590   if (strlen(s) &gt; 1) {
 591     return false;
 592   }
 593   switch (*s) {
 594     case 'T': case 't':
 595       *result = n * G * K;
 596       // Check for overflow.
 597       if (*result/((julong)G * K) != n) return false;
 598       return true;
 599     case 'G': case 'g':
 600       *result = n * G;
 601       if (*result/G != n) return false;
 602       return true;
 603     case 'M': case 'm':
 604       *result = n * M;
 605       if (*result/M != n) return false;
 606       return true;
 607     case 'K': case 'k':
 608       *result = n * K;
 609       if (*result/K != n) return false;
 610       return true;
 611     case '\0':
 612       *result = n;
 613       return true;
 614     default:
 615       return false;
 616   }
 617 }
 618 
 619 Arguments::ArgsRange Arguments::check_memory_size(julong size, julong min_size) {
 620   if (size &lt; min_size) return arg_too_small;
 621   // Check that size will fit in a size_t (only relevant on 32-bit)
 622   if (size &gt; max_uintx) return arg_too_big;
 623   return arg_in_range;
 624 }
 625 
 626 // Describe an argument out of range error
 627 void Arguments::describe_range_error(ArgsRange errcode) {
 628   switch(errcode) {
 629   case arg_too_big:
 630     jio_fprintf(defaultStream::error_stream(),
 631                 "The specified size exceeds the maximum "
 632                 "representable size.\n");
 633     break;
 634   case arg_too_small:
 635   case arg_unreadable:
 636   case arg_in_range:
 637     // do nothing for now
 638     break;
 639   default:
 640     ShouldNotReachHere();
 641   }
 642 }
 643 
 644 static bool set_bool_flag(char* name, bool value, Flag::Flags origin) {
 645   return CommandLineFlags::boolAtPut(name, &amp;value, origin);
 646 }
 647 
 648 static bool set_fp_numeric_flag(char* name, char* value, Flag::Flags origin) {
 649   double v;
 650   if (sscanf(value, "%lf", &amp;v) != 1) {
 651     return false;
 652   }
 653 
 654   if (CommandLineFlags::doubleAtPut(name, &amp;v, origin)) {
 655     return true;
 656   }
 657   return false;
 658 }
 659 
 660 static bool set_numeric_flag(char* name, char* value, Flag::Flags origin) {
 661   julong v;
 662   intx intx_v;
 663   bool is_neg = false;
 664   // Check the sign first since atomull() parses only unsigned values.
 665   if (*value == '-') {
 666     if (!CommandLineFlags::intxAt(name, &amp;intx_v)) {
 667       return false;
 668     }
 669     value++;
 670     is_neg = true;
 671   }
 672   if (!atomull(value, &amp;v)) {
 673     return false;
 674   }
 675   intx_v = (intx) v;
 676   if (is_neg) {
 677     intx_v = -intx_v;
 678   }
 679   if (CommandLineFlags::intxAtPut(name, &amp;intx_v, origin)) {
 680     return true;
 681   }
 682   uintx uintx_v = (uintx) v;
 683   if (!is_neg &amp;&amp; CommandLineFlags::uintxAtPut(name, &amp;uintx_v, origin)) {
 684     return true;
 685   }
 686   uint64_t uint64_t_v = (uint64_t) v;
 687   if (!is_neg &amp;&amp; CommandLineFlags::uint64_tAtPut(name, &amp;uint64_t_v, origin)) {
 688     return true;
 689   }
 690   return false;
 691 }
 692 
 693 static bool set_string_flag(char* name, const char* value, Flag::Flags origin) {
 694   if (!CommandLineFlags::ccstrAtPut(name, &amp;value, origin))  return false;
 695   // Contract:  CommandLineFlags always returns a pointer that needs freeing.
 696   FREE_C_HEAP_ARRAY(char, value, mtInternal);
 697   return true;
 698 }
 699 
 700 static bool append_to_string_flag(char* name, const char* new_value, Flag::Flags origin) {
 701   const char* old_value = "";
 702   if (!CommandLineFlags::ccstrAt(name, &amp;old_value))  return false;
 703   size_t old_len = old_value != NULL ? strlen(old_value) : 0;
 704   size_t new_len = strlen(new_value);
 705   const char* value;
 706   char* free_this_too = NULL;
 707   if (old_len == 0) {
 708     value = new_value;
 709   } else if (new_len == 0) {
 710     value = old_value;
 711   } else {
 712     char* buf = NEW_C_HEAP_ARRAY(char, old_len + 1 + new_len + 1, mtInternal);
 713     // each new setting adds another LINE to the switch:
 714     sprintf(buf, "%s\n%s", old_value, new_value);
 715     value = buf;
 716     free_this_too = buf;
 717   }
 718   (void) CommandLineFlags::ccstrAtPut(name, &amp;value, origin);
 719   // CommandLineFlags always returns a pointer that needs freeing.
 720   FREE_C_HEAP_ARRAY(char, value, mtInternal);
 721   if (free_this_too != NULL) {
 722     // CommandLineFlags made its own copy, so I must delete my own temp. buffer.
 723     FREE_C_HEAP_ARRAY(char, free_this_too, mtInternal);
 724   }
 725   return true;
 726 }
 727 
 728 bool Arguments::parse_argument(const char* arg, Flag::Flags origin) {
 729 
 730   // range of acceptable characters spelled out for portability reasons
 731 #define NAME_RANGE  "[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]"
 732 #define BUFLEN 255
 733   char name[BUFLEN+1];
 734   char dummy;
 735 
 736   if (sscanf(arg, "-%" XSTR(BUFLEN) NAME_RANGE "%c", name, &amp;dummy) == 1) {
 737     return set_bool_flag(name, false, origin);
 738   }
 739   if (sscanf(arg, "+%" XSTR(BUFLEN) NAME_RANGE "%c", name, &amp;dummy) == 1) {
 740     return set_bool_flag(name, true, origin);
 741   }
 742 
 743   char punct;
 744   if (sscanf(arg, "%" XSTR(BUFLEN) NAME_RANGE "%c", name, &amp;punct) == 2 &amp;&amp; punct == '=') {
 745     const char* value = strchr(arg, '=') + 1;
 746     Flag* flag = Flag::find_flag(name, strlen(name));
 747     if (flag != NULL &amp;&amp; flag-&gt;is_ccstr()) {
 748       if (flag-&gt;ccstr_accumulates()) {
 749         return append_to_string_flag(name, value, origin);
 750       } else {
 751         if (value[0] == '\0') {
 752           value = NULL;
 753         }
 754         return set_string_flag(name, value, origin);
 755       }
 756     }
 757   }
 758 
 759   if (sscanf(arg, "%" XSTR(BUFLEN) NAME_RANGE ":%c", name, &amp;punct) == 2 &amp;&amp; punct == '=') {
 760     const char* value = strchr(arg, '=') + 1;
 761     // -XX:Foo:=xxx will reset the string flag to the given value.
 762     if (value[0] == '\0') {
 763       value = NULL;
 764     }
 765     return set_string_flag(name, value, origin);
 766   }
 767 
 768 #define SIGNED_FP_NUMBER_RANGE "[-0123456789.]"
 769 #define SIGNED_NUMBER_RANGE    "[-0123456789]"
 770 #define        NUMBER_RANGE    "[0123456789]"
 771   char value[BUFLEN + 1];
 772   char value2[BUFLEN + 1];
 773   if (sscanf(arg, "%" XSTR(BUFLEN) NAME_RANGE "=" "%" XSTR(BUFLEN) SIGNED_NUMBER_RANGE "." "%" XSTR(BUFLEN) NUMBER_RANGE "%c", name, value, value2, &amp;dummy) == 3) {
 774     // Looks like a floating-point number -- try again with more lenient format string
 775     if (sscanf(arg, "%" XSTR(BUFLEN) NAME_RANGE "=" "%" XSTR(BUFLEN) SIGNED_FP_NUMBER_RANGE "%c", name, value, &amp;dummy) == 2) {
 776       return set_fp_numeric_flag(name, value, origin);
 777     }
 778   }
 779 
 780 #define VALUE_RANGE "[-kmgtKMGT0123456789]"
 781   if (sscanf(arg, "%" XSTR(BUFLEN) NAME_RANGE "=" "%" XSTR(BUFLEN) VALUE_RANGE "%c", name, value, &amp;dummy) == 2) {
 782     return set_numeric_flag(name, value, origin);
 783   }
 784 
 785   return false;
 786 }
 787 
 788 void Arguments::add_string(char*** bldarray, int* count, const char* arg) {
 789   assert(bldarray != NULL, "illegal argument");
 790 
 791   if (arg == NULL) {
 792     return;
 793   }
 794 
 795   int new_count = *count + 1;
 796 
 797   // expand the array and add arg to the last element
 798   if (*bldarray == NULL) {
 799     *bldarray = NEW_C_HEAP_ARRAY(char*, new_count, mtInternal);
 800   } else {
 801     *bldarray = REALLOC_C_HEAP_ARRAY(char*, *bldarray, new_count, mtInternal);
 802   }
 803   (*bldarray)[*count] = strdup(arg);
 804   *count = new_count;
 805 }
 806 
 807 void Arguments::build_jvm_args(const char* arg) {
 808   add_string(&amp;_jvm_args_array, &amp;_num_jvm_args, arg);
 809 }
 810 
 811 void Arguments::build_jvm_flags(const char* arg) {
 812   add_string(&amp;_jvm_flags_array, &amp;_num_jvm_flags, arg);
 813 }
 814 
 815 // utility function to return a string that concatenates all
 816 // strings in a given char** array
 817 const char* Arguments::build_resource_string(char** args, int count) {
 818   if (args == NULL || count == 0) {
 819     return NULL;
 820   }
 821   size_t length = strlen(args[0]) + 1; // add 1 for the null terminator
 822   for (int i = 1; i &lt; count; i++) {
 823     length += strlen(args[i]) + 1; // add 1 for a space
 824   }
 825   char* s = NEW_RESOURCE_ARRAY(char, length);
 826   strcpy(s, args[0]);
 827   for (int j = 1; j &lt; count; j++) {
 828     strcat(s, " ");
 829     strcat(s, args[j]);
 830   }
 831   return (const char*) s;
 832 }
 833 
 834 void Arguments::print_on(outputStream* st) {
 835   st-&gt;print_cr("VM Arguments:");
 836   if (num_jvm_flags() &gt; 0) {
 837     st-&gt;print("jvm_flags: "); print_jvm_flags_on(st);
 838   }
 839   if (num_jvm_args() &gt; 0) {
 840     st-&gt;print("jvm_args: "); print_jvm_args_on(st);
 841   }
 842   st-&gt;print_cr("java_command: %s", java_command() ? java_command() : "&lt;unknown&gt;");
 843   if (_java_class_path != NULL) {
 844     char* path = _java_class_path-&gt;value();
 845     st-&gt;print_cr("java_class_path (initial): %s", strlen(path) == 0 ? "&lt;not set&gt;" : path );
 846   }
 847   st-&gt;print_cr("Launcher Type: %s", _sun_java_launcher);
 848 }
 849 
 850 void Arguments::print_jvm_flags_on(outputStream* st) {
 851   if (_num_jvm_flags &gt; 0) {
 852     for (int i=0; i &lt; _num_jvm_flags; i++) {
 853       st-&gt;print("%s ", _jvm_flags_array[i]);
 854     }
 855     st-&gt;print_cr("");
 856   }
 857 }
 858 
 859 void Arguments::print_jvm_args_on(outputStream* st) {
 860   if (_num_jvm_args &gt; 0) {
 861     for (int i=0; i &lt; _num_jvm_args; i++) {
 862       st-&gt;print("%s ", _jvm_args_array[i]);
 863     }
 864     st-&gt;print_cr("");
 865   }
 866 }
 867 
 868 bool Arguments::process_argument(const char* arg,
 869     jboolean ignore_unrecognized, Flag::Flags origin) {
 870 
 871   JDK_Version since = JDK_Version();
 872 
 873   if (parse_argument(arg, origin) || ignore_unrecognized) {
 874     return true;
 875   }
 876 
 877   bool has_plus_minus = (*arg == '+' || *arg == '-');
 878   const char* const argname = has_plus_minus ? arg + 1 : arg;
 879   if (is_newly_obsolete(arg, &amp;since)) {
 880     char version[256];
 881     since.to_string(version, sizeof(version));
 882     warning("ignoring option %s; support was removed in %s", argname, version);
 883     return true;
 884   }
 885 
 886   // For locked flags, report a custom error message if available.
 887   // Otherwise, report the standard unrecognized VM option.
 888 
 889   size_t arg_len;
 890   const char* equal_sign = strchr(argname, '=');
 891   if (equal_sign == NULL) {
 892     arg_len = strlen(argname);
 893   } else {
 894     arg_len = equal_sign - argname;
 895   }
 896 
 897   Flag* found_flag = Flag::find_flag((const char*)argname, arg_len, true, true);
 898   if (found_flag != NULL) {
 899     char locked_message_buf[BUFLEN];
 900     found_flag-&gt;get_locked_message(locked_message_buf, BUFLEN);
 901     if (strlen(locked_message_buf) == 0) {
 902       if (found_flag-&gt;is_bool() &amp;&amp; !has_plus_minus) {
 903         jio_fprintf(defaultStream::error_stream(),
 904           "Missing +/- setting for VM option '%s'\n", argname);
 905       } else if (!found_flag-&gt;is_bool() &amp;&amp; has_plus_minus) {
 906         jio_fprintf(defaultStream::error_stream(),
 907           "Unexpected +/- setting in VM option '%s'\n", argname);
 908       } else {
 909         jio_fprintf(defaultStream::error_stream(),
 910           "Improperly specified VM option '%s'\n", argname);
 911       }
 912     } else {
 913       jio_fprintf(defaultStream::error_stream(), "%s", locked_message_buf);
 914     }
 915   } else {
 916     jio_fprintf(defaultStream::error_stream(),
 917                 "Unrecognized VM option '%s'\n", argname);
 918     Flag* fuzzy_matched = Flag::fuzzy_match((const char*)argname, arg_len, true);
 919     if (fuzzy_matched != NULL) {
 920       jio_fprintf(defaultStream::error_stream(),
 921                   "Did you mean '%s%s%s'?\n",
 922                   (fuzzy_matched-&gt;is_bool()) ? "(+/-)" : "",
 923                   fuzzy_matched-&gt;_name,
 924                   (fuzzy_matched-&gt;is_bool()) ? "" : "=&lt;value&gt;");
 925     }
 926   }
 927 
 928   // allow for commandline "commenting out" options like -XX:#+Verbose
 929   return arg[0] == '#';
 930 }
 931 
 932 bool Arguments::process_settings_file(const char* file_name, bool should_exist, jboolean ignore_unrecognized) {
 933   FILE* stream = fopen(file_name, "rb");
 934   if (stream == NULL) {
 935     if (should_exist) {
 936       jio_fprintf(defaultStream::error_stream(),
 937                   "Could not open settings file %s\n", file_name);
 938       return false;
 939     } else {
 940       return true;
 941     }
 942   }
 943 
 944   char token[1024];
 945   int  pos = 0;
 946 
 947   bool in_white_space = true;
 948   bool in_comment     = false;
 949   bool in_quote       = false;
 950   char quote_c        = 0;
 951   bool result         = true;
 952 
 953   int c = getc(stream);
 954   while(c != EOF &amp;&amp; pos &lt; (int)(sizeof(token)-1)) {
 955     if (in_white_space) {
 956       if (in_comment) {
 957         if (c == '\n') in_comment = false;
 958       } else {
 959         if (c == '#') in_comment = true;
 960         else if (!isspace(c)) {
 961           in_white_space = false;
 962           token[pos++] = c;
 963         }
 964       }
 965     } else {
 966       if (c == '\n' || (!in_quote &amp;&amp; isspace(c))) {
 967         // token ends at newline, or at unquoted whitespace
 968         // this allows a way to include spaces in string-valued options
 969         token[pos] = '\0';
 970         logOption(token);
 971         result &amp;= process_argument(token, ignore_unrecognized, Flag::CONFIG_FILE);
 972         build_jvm_flags(token);
 973         pos = 0;
 974         in_white_space = true;
 975         in_quote = false;
 976       } else if (!in_quote &amp;&amp; (c == '\'' || c == '"')) {
 977         in_quote = true;
 978         quote_c = c;
 979       } else if (in_quote &amp;&amp; (c == quote_c)) {
 980         in_quote = false;
 981       } else {
 982         token[pos++] = c;
 983       }
 984     }
 985     c = getc(stream);
 986   }
 987   if (pos &gt; 0) {
 988     token[pos] = '\0';
 989     result &amp;= process_argument(token, ignore_unrecognized, Flag::CONFIG_FILE);
 990     build_jvm_flags(token);
 991   }
 992   fclose(stream);
 993   return result;
 994 }
 995 
 996 //=============================================================================================================
 997 // Parsing of properties (-D)
 998 
 999 const char* Arguments::get_property(const char* key) {
1000   return PropertyList_get_value(system_properties(), key);
1001 }
1002 
1003 bool Arguments::add_property(const char* prop) {
1004   const char* eq = strchr(prop, '=');
1005   char* key;
1006   // ns must be static--its address may be stored in a SystemProperty object.
1007   const static char ns[1] = {0};
1008   char* value = (char *)ns;
1009 
1010   size_t key_len = (eq == NULL) ? strlen(prop) : (eq - prop);
1011   key = AllocateHeap(key_len + 1, mtInternal);
1012   strncpy(key, prop, key_len);
1013   key[key_len] = '\0';
1014 
1015   if (eq != NULL) {
1016     size_t value_len = strlen(prop) - key_len - 1;
1017     value = AllocateHeap(value_len + 1, mtInternal);
1018     strncpy(value, &amp;prop[key_len + 1], value_len + 1);
1019   }
1020 
1021   if (strcmp(key, "java.compiler") == 0) {
1022     process_java_compiler_argument(value);
1023     FreeHeap(key);
1024     if (eq != NULL) {
1025       FreeHeap(value);
1026     }
1027     return true;
1028   } else if (strcmp(key, "sun.java.command") == 0) {
1029     _java_command = value;
1030 
1031     // Record value in Arguments, but let it get passed to Java.
1032   } else if (strcmp(key, "sun.java.launcher.is_altjvm") == 0 ||
1033              strcmp(key, "sun.java.launcher.pid") == 0) {
1034     // sun.java.launcher.is_altjvm and sun.java.launcher.pid property are
1035     // private and are processed in process_sun_java_launcher_properties();
1036     // the sun.java.launcher property is passed on to the java application
1037     FreeHeap(key);
1038     if (eq != NULL) {
1039       FreeHeap(value);
1040     }
1041     return true;
1042   } else if (strcmp(key, "java.vendor.url.bug") == 0) {
1043     // save it in _java_vendor_url_bug, so JVM fatal error handler can access
1044     // its value without going through the property list or making a Java call.
1045     _java_vendor_url_bug = value;
1046   } else if (strcmp(key, "sun.boot.library.path") == 0) {
1047     PropertyList_unique_add(&amp;_system_properties, key, value, true);
1048     return true;
1049   }
1050   // Create new property and add at the end of the list
1051   PropertyList_unique_add(&amp;_system_properties, key, value);
1052   return true;
1053 }
1054 
1055 //===========================================================================================================
1056 // Setting int/mixed/comp mode flags
1057 
1058 void Arguments::set_mode_flags(Mode mode) {
1059   // Set up default values for all flags.
1060   // If you add a flag to any of the branches below,
1061   // add a default value for it here.
1062   set_java_compiler(false);
1063   _mode                      = mode;
1064 
1065   // Ensure Agent_OnLoad has the correct initial values.
1066   // This may not be the final mode; mode may change later in onload phase.
1067   PropertyList_unique_add(&amp;_system_properties, "java.vm.info",
1068                           (char*)VM_Version::vm_info_string(), false);
1069 
1070   UseInterpreter             = true;
1071   UseCompiler                = true;
1072   UseLoopCounter             = true;
1073 
1074 #ifndef ZERO
1075   // Turn these off for mixed and comp.  Leave them on for Zero.
1076   if (FLAG_IS_DEFAULT(UseFastAccessorMethods)) {
1077     UseFastAccessorMethods = (mode == _int);
1078   }
1079   if (FLAG_IS_DEFAULT(UseFastEmptyMethods)) {
1080     UseFastEmptyMethods = (mode == _int);
1081   }
1082 #endif
1083 
1084   // Default values may be platform/compiler dependent -
1085   // use the saved values
1086   ClipInlining               = Arguments::_ClipInlining;
1087   AlwaysCompileLoopMethods   = Arguments::_AlwaysCompileLoopMethods;
1088   UseOnStackReplacement      = Arguments::_UseOnStackReplacement;
1089   BackgroundCompilation      = Arguments::_BackgroundCompilation;
1090 
1091   // Change from defaults based on mode
1092   switch (mode) {
1093   default:
1094     ShouldNotReachHere();
1095     break;
1096   case _int:
1097     UseCompiler              = false;
1098     UseLoopCounter           = false;
1099     AlwaysCompileLoopMethods = false;
1100     UseOnStackReplacement    = false;
1101     break;
1102   case _mixed:
1103     // same as default
1104     break;
1105   case _comp:
1106     UseInterpreter           = false;
1107     BackgroundCompilation    = false;
1108     ClipInlining             = false;
1109     // Be much more aggressive in tiered mode with -Xcomp and exercise C2 more.
1110     // We will first compile a level 3 version (C1 with full profiling), then do one invocation of it and
1111     // compile a level 4 (C2) and then continue executing it.
1112     if (TieredCompilation) {
1113       Tier3InvokeNotifyFreqLog = 0;
1114       Tier4InvocationThreshold = 0;
1115     }
1116     break;
1117   }
1118 }
1119 
1120 #if defined(COMPILER2) || defined(_LP64) || !INCLUDE_CDS
1121 // Conflict: required to use shared spaces (-Xshare:on), but
1122 // incompatible command line options were chosen.
1123 
1124 static void no_shared_spaces() {
1125   if (RequireSharedSpaces) {
1126     jio_fprintf(defaultStream::error_stream(),
1127       "Class data sharing is inconsistent with other specified options.\n");
1128     vm_exit_during_initialization("Unable to use shared archive.", NULL);
1129   } else {
1130     FLAG_SET_DEFAULT(UseSharedSpaces, false);
1131   }
1132 }
1133 #endif
1134 
1135 void Arguments::set_tiered_flags() {
1136   // With tiered, set default policy to AdvancedThresholdPolicy, which is 3.
1137   if (FLAG_IS_DEFAULT(CompilationPolicyChoice)) {
1138     FLAG_SET_DEFAULT(CompilationPolicyChoice, 3);
1139   }
1140   if (CompilationPolicyChoice &lt; 2) {
1141     vm_exit_during_initialization(
1142       "Incompatible compilation policy selected", NULL);
1143   }
1144   // Increase the code cache size - tiered compiles a lot more.
1145   if (FLAG_IS_DEFAULT(ReservedCodeCacheSize)) {
1146     FLAG_SET_DEFAULT(ReservedCodeCacheSize, ReservedCodeCacheSize * 5);
1147   }
1148   if (!UseInterpreter) { // -Xcomp
1149     Tier3InvokeNotifyFreqLog = 0;
1150     Tier4InvocationThreshold = 0;
1151   }
1152 }
1153 
1154 #if INCLUDE_ALL_GCS
1155 static void disable_adaptive_size_policy(const char* collector_name) {
1156   if (UseAdaptiveSizePolicy) {
1157     if (FLAG_IS_CMDLINE(UseAdaptiveSizePolicy)) {
1158       warning("disabling UseAdaptiveSizePolicy; it is incompatible with %s.",
1159               collector_name);
1160     }
1161     FLAG_SET_DEFAULT(UseAdaptiveSizePolicy, false);
1162   }
1163 }
1164 
1165 void Arguments::set_parnew_gc_flags() {
1166   assert(!UseSerialGC &amp;&amp; !UseParallelOldGC &amp;&amp; !UseParallelGC &amp;&amp; !UseG1GC,
1167          "control point invariant");
1168   assert(UseParNewGC, "Error");
1169 
1170   // Turn off AdaptiveSizePolicy for parnew until it is complete.
1171   disable_adaptive_size_policy("UseParNewGC");
1172 
1173   if (FLAG_IS_DEFAULT(ParallelGCThreads)) {
1174     FLAG_SET_DEFAULT(ParallelGCThreads, Abstract_VM_Version::parallel_worker_threads());
1175     assert(ParallelGCThreads &gt; 0, "We should always have at least one thread by default");
1176   } else if (ParallelGCThreads == 0) {
1177     jio_fprintf(defaultStream::error_stream(),
1178         "The ParNew GC can not be combined with -XX:ParallelGCThreads=0\n");
1179     vm_exit(1);
1180   }
1181 
1182   // By default YoungPLABSize and OldPLABSize are set to 4096 and 1024 respectively,
1183   // these settings are default for Parallel Scavenger. For ParNew+Tenured configuration
1184   // we set them to 1024 and 1024.
1185   // See CR 6362902.
1186   if (FLAG_IS_DEFAULT(YoungPLABSize)) {
1187     FLAG_SET_DEFAULT(YoungPLABSize, (intx)1024);
1188   }
1189   if (FLAG_IS_DEFAULT(OldPLABSize)) {
1190     FLAG_SET_DEFAULT(OldPLABSize, (intx)1024);
1191   }
1192 
1193   // When using compressed oops, we use local overflow stacks,
1194   // rather than using a global overflow list chained through
1195   // the klass word of the object's pre-image.
1196   if (UseCompressedOops &amp;&amp; !ParGCUseLocalOverflow) {
1197     if (!FLAG_IS_DEFAULT(ParGCUseLocalOverflow)) {
1198       warning("Forcing +ParGCUseLocalOverflow: needed if using compressed references");
1199     }
1200     FLAG_SET_DEFAULT(ParGCUseLocalOverflow, true);
1201   }
1202   assert(ParGCUseLocalOverflow || !UseCompressedOops, "Error");
1203 }
1204 
1205 // Adjust some sizes to suit CMS and/or ParNew needs; these work well on
1206 // sparc/solaris for certain applications, but would gain from
1207 // further optimization and tuning efforts, and would almost
1208 // certainly gain from analysis of platform and environment.
1209 void Arguments::set_cms_and_parnew_gc_flags() {
1210   assert(!UseSerialGC &amp;&amp; !UseParallelOldGC &amp;&amp; !UseParallelGC, "Error");
1211   assert(UseConcMarkSweepGC, "CMS is expected to be on here");
1212 
1213   // If we are using CMS, we prefer to UseParNewGC,
1214   // unless explicitly forbidden.
1215   if (FLAG_IS_DEFAULT(UseParNewGC)) {
1216     FLAG_SET_ERGO(bool, UseParNewGC, true);
1217   }
1218 
1219   // Turn off AdaptiveSizePolicy by default for cms until it is complete.
1220   disable_adaptive_size_policy("UseConcMarkSweepGC");
1221 
1222   // In either case, adjust ParallelGCThreads and/or UseParNewGC
1223   // as needed.
1224   if (UseParNewGC) {
1225     set_parnew_gc_flags();
1226   }
1227 
1228   size_t max_heap = align_size_down(MaxHeapSize,
1229                                     CardTableRS::ct_max_alignment_constraint());
1230 
1231   // Now make adjustments for CMS
1232   intx   tenuring_default = (intx)6;
1233   size_t young_gen_per_worker = CMSYoungGenPerWorker;
1234 
1235   // Preferred young gen size for "short" pauses:
1236   // upper bound depends on # of threads and NewRatio.
1237   const uintx parallel_gc_threads =
1238     (ParallelGCThreads == 0 ? 1 : ParallelGCThreads);
1239   const size_t preferred_max_new_size_unaligned =
1240     MIN2(max_heap/(NewRatio+1), ScaleForWordSize(young_gen_per_worker * parallel_gc_threads));
1241   size_t preferred_max_new_size =
1242     align_size_up(preferred_max_new_size_unaligned, os::vm_page_size());
1243 
1244   // Unless explicitly requested otherwise, size young gen
1245   // for "short" pauses ~ CMSYoungGenPerWorker*ParallelGCThreads
1246 
1247   // If either MaxNewSize or NewRatio is set on the command line,
1248   // assume the user is trying to set the size of the young gen.
1249   if (FLAG_IS_DEFAULT(MaxNewSize) &amp;&amp; FLAG_IS_DEFAULT(NewRatio)) {
1250 
1251     // Set MaxNewSize to our calculated preferred_max_new_size unless
1252     // NewSize was set on the command line and it is larger than
1253     // preferred_max_new_size.
1254     if (!FLAG_IS_DEFAULT(NewSize)) {   // NewSize explicitly set at command-line
1255       FLAG_SET_ERGO(uintx, MaxNewSize, MAX2(NewSize, preferred_max_new_size));
1256     } else {
1257       FLAG_SET_ERGO(uintx, MaxNewSize, preferred_max_new_size);
1258     }
1259     if (PrintGCDetails &amp;&amp; Verbose) {
1260       // Too early to use gclog_or_tty
1261       tty-&gt;print_cr("CMS ergo set MaxNewSize: " SIZE_FORMAT, MaxNewSize);
1262     }
1263 
1264     // Code along this path potentially sets NewSize and OldSize
1265     if (PrintGCDetails &amp;&amp; Verbose) {
1266       // Too early to use gclog_or_tty
1267       tty-&gt;print_cr("CMS set min_heap_size: " SIZE_FORMAT
1268            " initial_heap_size:  " SIZE_FORMAT
1269            " max_heap: " SIZE_FORMAT,
1270            min_heap_size(), InitialHeapSize, max_heap);
1271     }
1272     size_t min_new = preferred_max_new_size;
1273     if (FLAG_IS_CMDLINE(NewSize)) {
1274       min_new = NewSize;
1275     }
1276     if (max_heap &gt; min_new &amp;&amp; min_heap_size() &gt; min_new) {
1277       // Unless explicitly requested otherwise, make young gen
1278       // at least min_new, and at most preferred_max_new_size.
1279       if (FLAG_IS_DEFAULT(NewSize)) {
1280         FLAG_SET_ERGO(uintx, NewSize, MAX2(NewSize, min_new));
1281         FLAG_SET_ERGO(uintx, NewSize, MIN2(preferred_max_new_size, NewSize));
1282         if (PrintGCDetails &amp;&amp; Verbose) {
1283           // Too early to use gclog_or_tty
1284           tty-&gt;print_cr("CMS ergo set NewSize: " SIZE_FORMAT, NewSize);
1285         }
1286       }
1287       // Unless explicitly requested otherwise, size old gen
1288       // so it's NewRatio x of NewSize.
1289       if (FLAG_IS_DEFAULT(OldSize)) {
1290         if (max_heap &gt; NewSize) {
1291           FLAG_SET_ERGO(uintx, OldSize, MIN2(NewRatio*NewSize, max_heap - NewSize));
1292           if (PrintGCDetails &amp;&amp; Verbose) {
1293             // Too early to use gclog_or_tty
1294             tty-&gt;print_cr("CMS ergo set OldSize: " SIZE_FORMAT, OldSize);
1295           }
1296         }
1297       }
1298     }
1299   }
1300   // Unless explicitly requested otherwise, definitely
1301   // promote all objects surviving "tenuring_default" scavenges.
1302   if (FLAG_IS_DEFAULT(MaxTenuringThreshold) &amp;&amp;
1303       FLAG_IS_DEFAULT(SurvivorRatio)) {
1304     FLAG_SET_ERGO(uintx, MaxTenuringThreshold, tenuring_default);
1305   }
1306   // If we decided above (or user explicitly requested)
1307   // `promote all' (via MaxTenuringThreshold := 0),
1308   // prefer minuscule survivor spaces so as not to waste
1309   // space for (non-existent) survivors
1310   if (FLAG_IS_DEFAULT(SurvivorRatio) &amp;&amp; MaxTenuringThreshold == 0) {
1311     FLAG_SET_ERGO(uintx, SurvivorRatio, MAX2((uintx)1024, SurvivorRatio));
1312   }
1313   // If OldPLABSize is set and CMSParPromoteBlocksToClaim is not,
1314   // set CMSParPromoteBlocksToClaim equal to OldPLABSize.
1315   // This is done in order to make ParNew+CMS configuration to work
1316   // with YoungPLABSize and OldPLABSize options.
1317   // See CR 6362902.
1318   if (!FLAG_IS_DEFAULT(OldPLABSize)) {
1319     if (FLAG_IS_DEFAULT(CMSParPromoteBlocksToClaim)) {
1320       // OldPLABSize is not the default value but CMSParPromoteBlocksToClaim
1321       // is.  In this situation let CMSParPromoteBlocksToClaim follow
1322       // the value (either from the command line or ergonomics) of
1323       // OldPLABSize.  Following OldPLABSize is an ergonomics decision.
1324       FLAG_SET_ERGO(uintx, CMSParPromoteBlocksToClaim, OldPLABSize);
1325     } else {
1326       // OldPLABSize and CMSParPromoteBlocksToClaim are both set.
1327       // CMSParPromoteBlocksToClaim is a collector-specific flag, so
1328       // we'll let it to take precedence.
1329       jio_fprintf(defaultStream::error_stream(),
1330                   "Both OldPLABSize and CMSParPromoteBlocksToClaim"
1331                   " options are specified for the CMS collector."
1332                   " CMSParPromoteBlocksToClaim will take precedence.\n");
1333     }
1334   }
1335   if (!FLAG_IS_DEFAULT(ResizeOldPLAB) &amp;&amp; !ResizeOldPLAB) {
1336     // OldPLAB sizing manually turned off: Use a larger default setting,
1337     // unless it was manually specified. This is because a too-low value
1338     // will slow down scavenges.
1339     if (FLAG_IS_DEFAULT(CMSParPromoteBlocksToClaim)) {
1340       FLAG_SET_ERGO(uintx, CMSParPromoteBlocksToClaim, 50); // default value before 6631166
1341     }
1342   }
1343   // Overwrite OldPLABSize which is the variable we will internally use everywhere.
1344   FLAG_SET_ERGO(uintx, OldPLABSize, CMSParPromoteBlocksToClaim);
1345   // If either of the static initialization defaults have changed, note this
1346   // modification.
1347   if (!FLAG_IS_DEFAULT(CMSParPromoteBlocksToClaim) || !FLAG_IS_DEFAULT(OldPLABWeight)) {
1348     CFLS_LAB::modify_initialization(OldPLABSize, OldPLABWeight);
1349   }
1350   if (PrintGCDetails &amp;&amp; Verbose) {
1351     tty-&gt;print_cr("MarkStackSize: %uk  MarkStackSizeMax: %uk",
1352       MarkStackSize / K, MarkStackSizeMax / K);
1353     tty-&gt;print_cr("ConcGCThreads: %u", ConcGCThreads);
1354   }
1355 }
1356 #endif // INCLUDE_ALL_GCS
1357 
1358 void set_object_alignment() {
1359   // Object alignment.
1360   assert(is_power_of_2(ObjectAlignmentInBytes), "ObjectAlignmentInBytes must be power of 2");
1361   MinObjAlignmentInBytes     = ObjectAlignmentInBytes;
1362   assert(MinObjAlignmentInBytes &gt;= HeapWordsPerLong * HeapWordSize, "ObjectAlignmentInBytes value is too small");
1363   MinObjAlignment            = MinObjAlignmentInBytes / HeapWordSize;
1364   assert(MinObjAlignmentInBytes == MinObjAlignment * HeapWordSize, "ObjectAlignmentInBytes value is incorrect");
1365   MinObjAlignmentInBytesMask = MinObjAlignmentInBytes - 1;
1366 
1367   LogMinObjAlignmentInBytes  = exact_log2(ObjectAlignmentInBytes);
1368   LogMinObjAlignment         = LogMinObjAlignmentInBytes - LogHeapWordSize;
1369 
1370   // Oop encoding heap max
1371   OopEncodingHeapMax = (uint64_t(max_juint) + 1) &lt;&lt; LogMinObjAlignmentInBytes;
1372 
1373 #if INCLUDE_ALL_GCS
1374   // Set CMS global values
1375   CompactibleFreeListSpace::set_cms_values();
1376 #endif // INCLUDE_ALL_GCS
1377 }
1378 
1379 bool verify_object_alignment() {
1380   // Object alignment.
1381   if (!is_power_of_2(ObjectAlignmentInBytes)) {
1382     jio_fprintf(defaultStream::error_stream(),
1383                 "error: ObjectAlignmentInBytes=%d must be power of 2\n",
1384                 (int)ObjectAlignmentInBytes);
1385     return false;
1386   }
1387   if ((int)ObjectAlignmentInBytes &lt; BytesPerLong) {
1388     jio_fprintf(defaultStream::error_stream(),
1389                 "error: ObjectAlignmentInBytes=%d must be greater or equal %d\n",
1390                 (int)ObjectAlignmentInBytes, BytesPerLong);
1391     return false;
1392   }
1393   // It does not make sense to have big object alignment
1394   // since a space lost due to alignment will be greater
1395   // then a saved space from compressed oops.
1396   if ((int)ObjectAlignmentInBytes &gt; 256) {
1397     jio_fprintf(defaultStream::error_stream(),
1398                 "error: ObjectAlignmentInBytes=%d must not be greater than 256\n",
1399                 (int)ObjectAlignmentInBytes);
1400     return false;
1401   }
1402   // In case page size is very small.
1403   if ((int)ObjectAlignmentInBytes &gt;= os::vm_page_size()) {
1404     jio_fprintf(defaultStream::error_stream(),
1405                 "error: ObjectAlignmentInBytes=%d must be less than page size %d\n",
1406                 (int)ObjectAlignmentInBytes, os::vm_page_size());
1407     return false;
1408   }
1409   return true;
1410 }
1411 
1412 uintx Arguments::max_heap_for_compressed_oops() {
1413   // Avoid sign flip.
1414   assert(OopEncodingHeapMax &gt; (uint64_t)os::vm_page_size(), "Unusual page size");
1415   // We need to fit both the NULL page and the heap into the memory budget, while
1416   // keeping alignment constraints of the heap. To guarantee the latter, as the
1417   // NULL page is located before the heap, we pad the NULL page to the conservative
1418   // maximum alignment that the GC may ever impose upon the heap.
1419   size_t displacement_due_to_null_page = align_size_up_(os::vm_page_size(),
1420                                                         _conservative_max_heap_alignment);
1421 
1422   LP64_ONLY(return OopEncodingHeapMax - displacement_due_to_null_page);
1423   NOT_LP64(ShouldNotReachHere(); return 0);
1424 }
1425 
1426 bool Arguments::should_auto_select_low_pause_collector() {
1427   if (UseAutoGCSelectPolicy &amp;&amp;
1428       !FLAG_IS_DEFAULT(MaxGCPauseMillis) &amp;&amp;
1429       (MaxGCPauseMillis &lt;= AutoGCSelectPauseMillis)) {
1430     if (PrintGCDetails) {
1431       // Cannot use gclog_or_tty yet.
1432       tty-&gt;print_cr("Automatic selection of the low pause collector"
1433        " based on pause goal of %d (ms)", MaxGCPauseMillis);
1434     }
1435     return true;
1436   }
1437   return false;
1438 }
1439 
1440 void Arguments::set_use_compressed_oops() {
1441 #ifndef ZERO
1442 #ifdef _LP64
1443   // MaxHeapSize is not set up properly at this point, but
1444   // the only value that can override MaxHeapSize if we are
1445   // to use UseCompressedOops is InitialHeapSize.
1446   size_t max_heap_size = MAX2(MaxHeapSize, InitialHeapSize);
1447 
1448   if (max_heap_size &lt;= max_heap_for_compressed_oops()) {
1449 #if !defined(COMPILER1) || defined(TIERED)
1450     if (FLAG_IS_DEFAULT(UseCompressedOops)) {
1451       FLAG_SET_ERGO(bool, UseCompressedOops, true);
1452     }
1453 #endif
1454 #ifdef _WIN64
1455     if (UseLargePages &amp;&amp; UseCompressedOops) {
1456       // Cannot allocate guard pages for implicit checks in indexed addressing
1457       // mode, when large pages are specified on windows.
1458       // This flag could be switched ON if narrow oop base address is set to 0,
1459       // see code in Universe::initialize_heap().
1460       Universe::set_narrow_oop_use_implicit_null_checks(false);
1461     }
1462 #endif //  _WIN64
1463   } else {
1464     if (UseCompressedOops &amp;&amp; !FLAG_IS_DEFAULT(UseCompressedOops)) {
1465       warning("Max heap size too large for Compressed Oops");
1466       FLAG_SET_DEFAULT(UseCompressedOops, false);
1467       FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1468     }
1469   }
1470 #endif // _LP64
1471 #endif // ZERO
1472 }
1473 
1474 
1475 // NOTE: set_use_compressed_klass_ptrs() must be called after calling
1476 // set_use_compressed_oops().
1477 void Arguments::set_use_compressed_klass_ptrs() {
1478 #ifndef ZERO
1479 #ifdef _LP64
1480   // UseCompressedOops must be on for UseCompressedClassPointers to be on.
1481   if (!UseCompressedOops) {
1482     if (UseCompressedClassPointers) {
1483       warning("UseCompressedClassPointers requires UseCompressedOops");
1484     }
1485     FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1486   } else {
1487     // Turn on UseCompressedClassPointers too
1488     if (FLAG_IS_DEFAULT(UseCompressedClassPointers)) {
1489       FLAG_SET_ERGO(bool, UseCompressedClassPointers, true);
1490     }
1491     // Check the CompressedClassSpaceSize to make sure we use compressed klass ptrs.
1492     if (UseCompressedClassPointers) {
1493       if (CompressedClassSpaceSize &gt; KlassEncodingMetaspaceMax) {
1494         warning("CompressedClassSpaceSize is too large for UseCompressedClassPointers");
1495         FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1496       }
1497     }
1498   }
1499 #endif // _LP64
1500 #endif // !ZERO
1501 }
1502 
1503 void Arguments::set_conservative_max_heap_alignment() {
1504   // The conservative maximum required alignment for the heap is the maximum of
1505   // the alignments imposed by several sources: any requirements from the heap
1506   // itself, the collector policy and the maximum page size we may run the VM
1507   // with.
1508   size_t heap_alignment = GenCollectedHeap::conservative_max_heap_alignment();
1509 #if INCLUDE_ALL_GCS
1510   if (UseParallelGC) {
1511     heap_alignment = ParallelScavengeHeap::conservative_max_heap_alignment();
1512   } else if (UseG1GC) {
1513     heap_alignment = G1CollectedHeap::conservative_max_heap_alignment();
1514   }
1515 #endif // INCLUDE_ALL_GCS
1516   _conservative_max_heap_alignment = MAX3(heap_alignment, os::max_page_size(),
1517     CollectorPolicy::compute_heap_alignment());
1518 }
1519 
1520 void Arguments::set_ergonomics_flags() {
1521 
1522   if (os::is_server_class_machine()) {
1523     // If no other collector is requested explicitly,
1524     // let the VM select the collector based on
1525     // machine class and automatic selection policy.
1526     if (!UseSerialGC &amp;&amp;
1527         !UseConcMarkSweepGC &amp;&amp;
1528         !UseG1GC &amp;&amp;
1529         !UseParNewGC &amp;&amp;
1530         FLAG_IS_DEFAULT(UseParallelGC)) {
1531       if (should_auto_select_low_pause_collector()) {
1532         FLAG_SET_ERGO(bool, UseConcMarkSweepGC, true);
1533       } else {
1534         FLAG_SET_ERGO(bool, UseParallelGC, true);
1535       }
1536     }
1537   }
1538 #ifdef COMPILER2
1539   // Shared spaces work fine with other GCs but causes bytecode rewriting
1540   // to be disabled, which hurts interpreter performance and decreases
1541   // server performance.  When -server is specified, keep the default off
1542   // unless it is asked for.  Future work: either add bytecode rewriting
1543   // at link time, or rewrite bytecodes in non-shared methods.
1544   if (!DumpSharedSpaces &amp;&amp; !RequireSharedSpaces &amp;&amp;
1545       (FLAG_IS_DEFAULT(UseSharedSpaces) || !UseSharedSpaces)) {
1546     no_shared_spaces();
1547   }
1548 #endif
1549 
1550   set_conservative_max_heap_alignment();
1551 
1552 #ifndef ZERO
1553 #ifdef _LP64
1554   set_use_compressed_oops();
1555 
1556   // set_use_compressed_klass_ptrs() must be called after calling
1557   // set_use_compressed_oops().
1558   set_use_compressed_klass_ptrs();
1559 
1560   // Also checks that certain machines are slower with compressed oops
1561   // in vm_version initialization code.
1562 #endif // _LP64
1563 #endif // !ZERO
1564 }
1565 
1566 void Arguments::set_parallel_gc_flags() {
1567   assert(UseParallelGC || UseParallelOldGC, "Error");
1568   // Enable ParallelOld unless it was explicitly disabled (cmd line or rc file).
1569   if (FLAG_IS_DEFAULT(UseParallelOldGC)) {
1570     FLAG_SET_DEFAULT(UseParallelOldGC, true);
1571   }
1572   FLAG_SET_DEFAULT(UseParallelGC, true);
1573 
1574   // If no heap maximum was requested explicitly, use some reasonable fraction
1575   // of the physical memory, up to a maximum of 1GB.
1576   FLAG_SET_DEFAULT(ParallelGCThreads,
1577                    Abstract_VM_Version::parallel_worker_threads());
1578   if (ParallelGCThreads == 0) {
1579     jio_fprintf(defaultStream::error_stream(),
1580         "The Parallel GC can not be combined with -XX:ParallelGCThreads=0\n");
1581     vm_exit(1);
1582   }
1583 
1584   if (UseAdaptiveSizePolicy) {
1585     // We don't want to limit adaptive heap sizing's freedom to adjust the heap
1586     // unless the user actually sets these flags.
1587     if (FLAG_IS_DEFAULT(MinHeapFreeRatio)) {
1588       FLAG_SET_DEFAULT(MinHeapFreeRatio, 0);
1589     }
1590     if (FLAG_IS_DEFAULT(MaxHeapFreeRatio)) {
1591       FLAG_SET_DEFAULT(MaxHeapFreeRatio, 100);
1592     }
1593   }
1594 
1595   // If InitialSurvivorRatio or MinSurvivorRatio were not specified, but the
1596   // SurvivorRatio has been set, reset their default values to SurvivorRatio +
1597   // 2.  By doing this we make SurvivorRatio also work for Parallel Scavenger.
1598   // See CR 6362902 for details.
1599   if (!FLAG_IS_DEFAULT(SurvivorRatio)) {
1600     if (FLAG_IS_DEFAULT(InitialSurvivorRatio)) {
1601        FLAG_SET_DEFAULT(InitialSurvivorRatio, SurvivorRatio + 2);
1602     }
1603     if (FLAG_IS_DEFAULT(MinSurvivorRatio)) {
1604       FLAG_SET_DEFAULT(MinSurvivorRatio, SurvivorRatio + 2);
1605     }
1606   }
1607 
1608   if (UseParallelOldGC) {
1609     // Par compact uses lower default values since they are treated as
1610     // minimums.  These are different defaults because of the different
1611     // interpretation and are not ergonomically set.
1612     if (FLAG_IS_DEFAULT(MarkSweepDeadRatio)) {
1613       FLAG_SET_DEFAULT(MarkSweepDeadRatio, 1);
1614     }
1615   }
1616 }
1617 
1618 void Arguments::set_g1_gc_flags() {
1619   assert(UseG1GC, "Error");
1620 #ifdef COMPILER1
1621   FastTLABRefill = false;
1622 #endif
1623   FLAG_SET_DEFAULT(ParallelGCThreads,
1624                      Abstract_VM_Version::parallel_worker_threads());
1625   if (ParallelGCThreads == 0) {
1626     FLAG_SET_DEFAULT(ParallelGCThreads,
1627                      Abstract_VM_Version::parallel_worker_threads());
1628   }
1629 
1630   // MarkStackSize will be set (if it hasn't been set by the user)
1631   // when concurrent marking is initialized.
1632   // Its value will be based upon the number of parallel marking threads.
1633   // But we do set the maximum mark stack size here.
1634   if (FLAG_IS_DEFAULT(MarkStackSizeMax)) {
1635     FLAG_SET_DEFAULT(MarkStackSizeMax, 128 * TASKQUEUE_SIZE);
1636   }
1637 
1638   if (FLAG_IS_DEFAULT(GCTimeRatio) || GCTimeRatio == 0) {
1639     // In G1, we want the default GC overhead goal to be higher than
1640     // say in PS. So we set it here to 10%. Otherwise the heap might
1641     // be expanded more aggressively than we would like it to. In
1642     // fact, even 10% seems to not be high enough in some cases
1643     // (especially small GC stress tests that the main thing they do
1644     // is allocation). We might consider increase it further.
1645     FLAG_SET_DEFAULT(GCTimeRatio, 9);
1646   }
1647 
1648   if (PrintGCDetails &amp;&amp; Verbose) {
1649     tty-&gt;print_cr("MarkStackSize: %uk  MarkStackSizeMax: %uk",
1650       MarkStackSize / K, MarkStackSizeMax / K);
1651     tty-&gt;print_cr("ConcGCThreads: %u", ConcGCThreads);
1652   }
1653 }
1654 
1655 julong Arguments::limit_by_allocatable_memory(julong limit) {
1656   julong max_allocatable;
1657   julong result = limit;
1658   if (os::has_allocatable_memory_limit(&amp;max_allocatable)) {
1659     result = MIN2(result, max_allocatable / MaxVirtMemFraction);
1660   }
1661   return result;
1662 }
1663 
1664 // Use static initialization to get the default before parsing
1665 static const uintx DefaultHeapBaseMinAddress = HeapBaseMinAddress;
1666 
1667 void Arguments::set_heap_size() {
1668   if (!FLAG_IS_DEFAULT(DefaultMaxRAMFraction)) {
1669     // Deprecated flag
1670     FLAG_SET_CMDLINE(uintx, MaxRAMFraction, DefaultMaxRAMFraction);
1671   }
1672 
1673   const julong phys_mem =
1674     FLAG_IS_DEFAULT(MaxRAM) ? MIN2(os::physical_memory(), (julong)MaxRAM)
1675                             : (julong)MaxRAM;
1676 
1677   // If the maximum heap size has not been set with -Xmx,
1678   // then set it as fraction of the size of physical memory,
1679   // respecting the maximum and minimum sizes of the heap.
1680   if (FLAG_IS_DEFAULT(MaxHeapSize)) {
1681     julong reasonable_max = phys_mem / MaxRAMFraction;
1682 
1683     if (phys_mem &lt;= MaxHeapSize * MinRAMFraction) {
1684       // Small physical memory, so use a minimum fraction of it for the heap
1685       reasonable_max = phys_mem / MinRAMFraction;
1686     } else {
1687       // Not-small physical memory, so require a heap at least
1688       // as large as MaxHeapSize
1689       reasonable_max = MAX2(reasonable_max, (julong)MaxHeapSize);
1690     }
1691     if (!FLAG_IS_DEFAULT(ErgoHeapSizeLimit) &amp;&amp; ErgoHeapSizeLimit != 0) {
1692       // Limit the heap size to ErgoHeapSizeLimit
1693       reasonable_max = MIN2(reasonable_max, (julong)ErgoHeapSizeLimit);
1694     }
1695     if (UseCompressedOops) {
1696       // Limit the heap size to the maximum possible when using compressed oops
1697       julong max_coop_heap = (julong)max_heap_for_compressed_oops();
1698 
1699       // HeapBaseMinAddress can be greater than default but not less than.
1700       if (!FLAG_IS_DEFAULT(HeapBaseMinAddress)) {
1701         if (HeapBaseMinAddress &lt; DefaultHeapBaseMinAddress) {
1702           // matches compressed oops printing flags
1703           if (PrintCompressedOopsMode || (PrintMiscellaneous &amp;&amp; Verbose)) {
1704             jio_fprintf(defaultStream::error_stream(),
1705                         "HeapBaseMinAddress must be at least " UINTX_FORMAT
1706                         " (" UINTX_FORMAT "G) which is greater than value given "
1707                         UINTX_FORMAT "\n",
1708                         DefaultHeapBaseMinAddress,
1709                         DefaultHeapBaseMinAddress/G,
1710                         HeapBaseMinAddress);
1711           }
1712           FLAG_SET_ERGO(uintx, HeapBaseMinAddress, DefaultHeapBaseMinAddress);
1713         }
1714       }
1715 
1716       if (HeapBaseMinAddress + MaxHeapSize &lt; max_coop_heap) {
1717         // Heap should be above HeapBaseMinAddress to get zero based compressed oops
1718         // but it should be not less than default MaxHeapSize.
1719         max_coop_heap -= HeapBaseMinAddress;
1720       }
1721       reasonable_max = MIN2(reasonable_max, max_coop_heap);
1722     }
1723     reasonable_max = limit_by_allocatable_memory(reasonable_max);
1724 
1725     if (!FLAG_IS_DEFAULT(InitialHeapSize)) {
1726       // An initial heap size was specified on the command line,
1727       // so be sure that the maximum size is consistent.  Done
1728       // after call to limit_by_allocatable_memory because that
1729       // method might reduce the allocation size.
1730       reasonable_max = MAX2(reasonable_max, (julong)InitialHeapSize);
1731     }
1732 
1733     if (PrintGCDetails &amp;&amp; Verbose) {
1734       // Cannot use gclog_or_tty yet.
1735       tty-&gt;print_cr("  Maximum heap size " SIZE_FORMAT, reasonable_max);
1736     }
1737     FLAG_SET_ERGO(uintx, MaxHeapSize, (uintx)reasonable_max);
1738   }
1739 
1740   // If the minimum or initial heap_size have not been set or requested to be set
1741   // ergonomically, set them accordingly.
1742   if (InitialHeapSize == 0 || min_heap_size() == 0) {
1743     julong reasonable_minimum = (julong)(OldSize + NewSize);
1744 
1745     reasonable_minimum = MIN2(reasonable_minimum, (julong)MaxHeapSize);
1746 
1747     reasonable_minimum = limit_by_allocatable_memory(reasonable_minimum);
1748 
1749     if (InitialHeapSize == 0) {
1750       julong reasonable_initial = phys_mem / InitialRAMFraction;
1751 
1752       reasonable_initial = MAX3(reasonable_initial, reasonable_minimum, (julong)min_heap_size());
1753       reasonable_initial = MIN2(reasonable_initial, (julong)MaxHeapSize);
1754 
1755       reasonable_initial = limit_by_allocatable_memory(reasonable_initial);
1756 
1757       if (PrintGCDetails &amp;&amp; Verbose) {
1758         // Cannot use gclog_or_tty yet.
1759         tty-&gt;print_cr("  Initial heap size " SIZE_FORMAT, (uintx)reasonable_initial);
1760       }
1761       FLAG_SET_ERGO(uintx, InitialHeapSize, (uintx)reasonable_initial);
1762     }
1763     // If the minimum heap size has not been set (via -Xms),
1764     // synchronize with InitialHeapSize to avoid errors with the default value.
1765     if (min_heap_size() == 0) {
1766       set_min_heap_size(MIN2((uintx)reasonable_minimum, InitialHeapSize));
1767       if (PrintGCDetails &amp;&amp; Verbose) {
1768         // Cannot use gclog_or_tty yet.
1769         tty-&gt;print_cr("  Minimum heap size " SIZE_FORMAT, min_heap_size());
1770       }
1771     }
1772   }
1773 }
1774 
1775 // This must be called after ergonomics because we want bytecode rewriting
1776 // if the server compiler is used, or if UseSharedSpaces is disabled.
1777 void Arguments::set_bytecode_flags() {
1778   // Better not attempt to store into a read-only space.
1779   if (UseSharedSpaces) {
1780     FLAG_SET_DEFAULT(RewriteBytecodes, false);
1781     FLAG_SET_DEFAULT(RewriteFrequentPairs, false);
1782   }
1783 
1784   if (!RewriteBytecodes) {
1785     FLAG_SET_DEFAULT(RewriteFrequentPairs, false);
1786   }
1787 }
1788 
1789 // Aggressive optimization flags  -XX:+AggressiveOpts
1790 void Arguments::set_aggressive_opts_flags() {
1791 #ifdef COMPILER2
1792   if (AggressiveUnboxing) {
1793     if (FLAG_IS_DEFAULT(EliminateAutoBox)) {
1794       FLAG_SET_DEFAULT(EliminateAutoBox, true);
1795     } else if (!EliminateAutoBox) {
1796       // warning("AggressiveUnboxing is disabled because EliminateAutoBox is disabled");
1797       AggressiveUnboxing = false;
1798     }
1799     if (FLAG_IS_DEFAULT(DoEscapeAnalysis)) {
1800       FLAG_SET_DEFAULT(DoEscapeAnalysis, true);
1801     } else if (!DoEscapeAnalysis) {
1802       // warning("AggressiveUnboxing is disabled because DoEscapeAnalysis is disabled");
1803       AggressiveUnboxing = false;
1804     }
1805   }
1806   if (AggressiveOpts || !FLAG_IS_DEFAULT(AutoBoxCacheMax)) {
1807     if (FLAG_IS_DEFAULT(EliminateAutoBox)) {
1808       FLAG_SET_DEFAULT(EliminateAutoBox, true);
1809     }
1810     if (FLAG_IS_DEFAULT(AutoBoxCacheMax)) {
1811       FLAG_SET_DEFAULT(AutoBoxCacheMax, 20000);
1812     }
1813 
1814     // Feed the cache size setting into the JDK
1815     char buffer[1024];
1816     sprintf(buffer, "java.lang.Integer.IntegerCache.high=" INTX_FORMAT, AutoBoxCacheMax);
1817     add_property(buffer);
1818   }
1819   if (AggressiveOpts &amp;&amp; FLAG_IS_DEFAULT(BiasedLockingStartupDelay)) {
1820     FLAG_SET_DEFAULT(BiasedLockingStartupDelay, 500);
1821   }
1822 #endif
1823 
1824   if (AggressiveOpts) {
1825 // Sample flag setting code
1826 //    if (FLAG_IS_DEFAULT(EliminateZeroing)) {
1827 //      FLAG_SET_DEFAULT(EliminateZeroing, true);
1828 //    }
1829   }
1830 }
1831 
1832 //===========================================================================================================
1833 // Parsing of java.compiler property
1834 
1835 void Arguments::process_java_compiler_argument(char* arg) {
1836   // For backwards compatibility, Djava.compiler=NONE or ""
1837   // causes us to switch to -Xint mode UNLESS -Xdebug
1838   // is also specified.
1839   if (strlen(arg) == 0 || strcasecmp(arg, "NONE") == 0) {
1840     set_java_compiler(true);    // "-Djava.compiler[=...]" most recently seen.
1841   }
1842 }
1843 
1844 void Arguments::process_java_launcher_argument(const char* launcher, void* extra_info) {
1845   _sun_java_launcher = strdup(launcher);
1846 }
1847 
1848 bool Arguments::created_by_java_launcher() {
1849   assert(_sun_java_launcher != NULL, "property must have value");
1850   return strcmp(DEFAULT_JAVA_LAUNCHER, _sun_java_launcher) != 0;
1851 }
1852 
1853 bool Arguments::sun_java_launcher_is_altjvm() {
1854   return _sun_java_launcher_is_altjvm;
1855 }
1856 
1857 //===========================================================================================================
1858 // Parsing of main arguments
1859 
1860 bool Arguments::verify_interval(uintx val, uintx min,
1861                                 uintx max, const char* name) {
1862   // Returns true iff value is in the inclusive interval [min..max]
1863   // false, otherwise.
1864   if (val &gt;= min &amp;&amp; val &lt;= max) {
1865     return true;
1866   }
1867   jio_fprintf(defaultStream::error_stream(),
1868               "%s of " UINTX_FORMAT " is invalid; must be between " UINTX_FORMAT
1869               " and " UINTX_FORMAT "\n",
1870               name, val, min, max);
1871   return false;
1872 }
1873 
1874 bool Arguments::verify_min_value(intx val, intx min, const char* name) {
1875   // Returns true if given value is at least specified min threshold
1876   // false, otherwise.
1877   if (val &gt;= min ) {
1878       return true;
1879   }
1880   jio_fprintf(defaultStream::error_stream(),
1881               "%s of " INTX_FORMAT " is invalid; must be at least " INTX_FORMAT "\n",
1882               name, val, min);
1883   return false;
1884 }
1885 
1886 bool Arguments::verify_percentage(uintx value, const char* name) {
1887   if (is_percentage(value)) {
1888     return true;
1889   }
1890   jio_fprintf(defaultStream::error_stream(),
1891               "%s of " UINTX_FORMAT " is invalid; must be between 0 and 100\n",
1892               name, value);
1893   return false;
1894 }
1895 
1896 #if !INCLUDE_ALL_GCS
1897 #ifdef ASSERT
1898 static bool verify_serial_gc_flags() {
1899   return (UseSerialGC &amp;&amp;
1900         !(UseParNewGC || (UseConcMarkSweepGC || CMSIncrementalMode) || UseG1GC ||
1901           UseParallelGC || UseParallelOldGC));
1902 }
1903 #endif // ASSERT
1904 #endif // INCLUDE_ALL_GCS
1905 
1906 // check if do gclog rotation
1907 // +UseGCLogFileRotation is a must,
1908 // no gc log rotation when log file not supplied or
1909 // NumberOfGCLogFiles is 0
1910 void check_gclog_consistency() {
1911   if (UseGCLogFileRotation) {
1912     if ((Arguments::gc_log_filename() == NULL) || (NumberOfGCLogFiles == 0)) {
1913       jio_fprintf(defaultStream::output_stream(),
1914                   "To enable GC log rotation, use -Xloggc:&lt;filename&gt; -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=&lt;num_of_files&gt;\n"
1915                   "where num_of_file &gt; 0\n"
1916                   "GC log rotation is turned off\n");
1917       UseGCLogFileRotation = false;
1918     }
1919   }
1920 
1921   if (UseGCLogFileRotation &amp;&amp; (GCLogFileSize != 0) &amp;&amp; (GCLogFileSize &lt; 8*K)) {
1922     FLAG_SET_CMDLINE(uintx, GCLogFileSize, 8*K);
1923     jio_fprintf(defaultStream::output_stream(),
1924                 "GCLogFileSize changed to minimum 8K\n");
1925   }
1926 }
1927 
1928 // This function is called for -Xloggc:&lt;filename&gt;, it can be used
1929 // to check if a given file name(or string) conforms to the following
1930 // specification:
1931 // A valid string only contains "[A-Z][a-z][0-9].-_%[p|t]"
1932 // %p and %t only allowed once. We only limit usage of filename not path
1933 bool is_filename_valid(const char *file_name) {
1934   const char* p = file_name;
1935   char file_sep = os::file_separator()[0];
1936   const char* cp;
1937   // skip prefix path
1938   for (cp = file_name; *cp != '\0'; cp++) {
1939     if (*cp == '/' || *cp == file_sep) {
1940       p = cp + 1;
1941     }
1942   }
1943 
1944   int count_p = 0;
1945   int count_t = 0;
1946   while (*p != '\0') {
1947     if ((*p &gt;= '0' &amp;&amp; *p &lt;= '9') ||
1948         (*p &gt;= 'A' &amp;&amp; *p &lt;= 'Z') ||
1949         (*p &gt;= 'a' &amp;&amp; *p &lt;= 'z') ||
1950          *p == '-'               ||
1951          *p == '_'               ||
1952          *p == '.') {
1953        p++;
1954        continue;
1955     }
1956     if (*p == '%') {
1957       if(*(p + 1) == 'p') {
1958         p += 2;
1959         count_p ++;
1960         continue;
1961       }
1962       if (*(p + 1) == 't') {
1963         p += 2;
1964         count_t ++;
1965         continue;
1966       }
1967     }
1968     return false;
1969   }
1970   return count_p &lt; 2 &amp;&amp; count_t &lt; 2;
1971 }
1972 
1973 bool Arguments::verify_MinHeapFreeRatio(FormatBuffer&lt;80&gt;&amp; err_msg, uintx min_heap_free_ratio) {
1974   if (!is_percentage(min_heap_free_ratio)) {
1975     err_msg.print("MinHeapFreeRatio must have a value between 0 and 100");
1976     return false;
1977   }
1978   if (min_heap_free_ratio &gt; MaxHeapFreeRatio) {
1979     err_msg.print("MinHeapFreeRatio (" UINTX_FORMAT ") must be less than or "
1980                   "equal to MaxHeapFreeRatio (" UINTX_FORMAT ")", min_heap_free_ratio,
1981                   MaxHeapFreeRatio);
1982     return false;
1983   }
1984   return true;
1985 }
1986 
1987 bool Arguments::verify_MaxHeapFreeRatio(FormatBuffer&lt;80&gt;&amp; err_msg, uintx max_heap_free_ratio) {
1988   if (!is_percentage(max_heap_free_ratio)) {
1989     err_msg.print("MaxHeapFreeRatio must have a value between 0 and 100");
1990     return false;
1991   }
1992   if (max_heap_free_ratio &lt; MinHeapFreeRatio) {
1993     err_msg.print("MaxHeapFreeRatio (" UINTX_FORMAT ") must be greater than or "
1994                   "equal to MinHeapFreeRatio (" UINTX_FORMAT ")", max_heap_free_ratio,
1995                   MinHeapFreeRatio);
1996     return false;
1997   }
1998   return true;
1999 }
2000 
2001 // Check consistency of GC selection
2002 bool Arguments::check_gc_consistency() {
2003   check_gclog_consistency();
2004   bool status = true;
2005   // Ensure that the user has not selected conflicting sets
2006   // of collectors. [Note: this check is merely a user convenience;
2007   // collectors over-ride each other so that only a non-conflicting
2008   // set is selected; however what the user gets is not what they
2009   // may have expected from the combination they asked for. It's
2010   // better to reduce user confusion by not allowing them to
2011   // select conflicting combinations.
2012   uint i = 0;
2013   if (UseSerialGC)                       i++;
2014   if (UseConcMarkSweepGC || UseParNewGC) i++;
2015   if (UseParallelGC || UseParallelOldGC) i++;
2016   if (UseG1GC)                           i++;
2017   if (i &gt; 1) {
2018     jio_fprintf(defaultStream::error_stream(),
2019                 "Conflicting collector combinations in option list; "
2020                 "please refer to the release notes for the combinations "
2021                 "allowed\n");
2022     status = false;
2023   }
2024   return status;
2025 }
2026 
2027 void Arguments::check_deprecated_gcs() {
2028   if (UseConcMarkSweepGC &amp;&amp; !UseParNewGC) {
2029     warning("Using the DefNew young collector with the CMS collector is deprecated "
2030         "and will likely be removed in a future release");
2031   }
2032 
2033   if (UseParNewGC &amp;&amp; !UseConcMarkSweepGC) {
2034     // !UseConcMarkSweepGC means that we are using serial old gc. Unfortunately we don't
2035     // set up UseSerialGC properly, so that can't be used in the check here.
2036     warning("Using the ParNew young collector with the Serial old collector is deprecated "
2037         "and will likely be removed in a future release");
2038   }
2039 
2040   if (CMSIncrementalMode) {
2041     warning("Using incremental CMS is deprecated and will likely be removed in a future release");
2042   }
2043 }
2044 
2045 void Arguments::check_deprecated_gc_flags() {
2046   if (FLAG_IS_CMDLINE(MaxGCMinorPauseMillis)) {
2047     warning("Using MaxGCMinorPauseMillis as minor pause goal is deprecated"
2048             "and will likely be removed in future release");
2049   }
2050   if (FLAG_IS_CMDLINE(DefaultMaxRAMFraction)) {
2051     warning("DefaultMaxRAMFraction is deprecated and will likely be removed in a future release. "
2052         "Use MaxRAMFraction instead.");
2053   }
2054   if (FLAG_IS_CMDLINE(UseCMSCompactAtFullCollection)) {
2055     warning("UseCMSCompactAtFullCollection is deprecated and will likely be removed in a future release.");
2056   }
2057   if (FLAG_IS_CMDLINE(CMSFullGCsBeforeCompaction)) {
2058     warning("CMSFullGCsBeforeCompaction is deprecated and will likely be removed in a future release.");
2059   }
2060   if (FLAG_IS_CMDLINE(UseCMSCollectionPassing)) {
2061     warning("UseCMSCollectionPassing is deprecated and will likely be removed in a future release.");
2062   }
2063 }
2064 
2065 // Check stack pages settings
2066 bool Arguments::check_stack_pages()
2067 {
2068   bool status = true;
2069   status = status &amp;&amp; verify_min_value(StackYellowPages, 1, "StackYellowPages");
2070   status = status &amp;&amp; verify_min_value(StackRedPages, 1, "StackRedPages");
2071   // greater stack shadow pages can't generate instruction to bang stack
2072   status = status &amp;&amp; verify_interval(StackShadowPages, 1, 50, "StackShadowPages");
2073   return status;
2074 }
2075 
2076 // Check the consistency of vm_init_args
2077 bool Arguments::check_vm_args_consistency() {
2078   // Method for adding checks for flag consistency.
2079   // The intent is to warn the user of all possible conflicts,
2080   // before returning an error.
2081   // Note: Needs platform-dependent factoring.
2082   bool status = true;
2083 
2084   if (TLABRefillWasteFraction == 0) {
2085     jio_fprintf(defaultStream::error_stream(),
2086                 "TLABRefillWasteFraction should be a denominator, "
2087                 "not " SIZE_FORMAT "\n",
2088                 TLABRefillWasteFraction);
2089     status = false;
2090   }
2091 
2092   status = status &amp;&amp; verify_interval(AdaptiveSizePolicyWeight, 0, 100,
2093                               "AdaptiveSizePolicyWeight");
2094   status = status &amp;&amp; verify_percentage(ThresholdTolerance, "ThresholdTolerance");
2095 
2096   // Divide by bucket size to prevent a large size from causing rollover when
2097   // calculating amount of memory needed to be allocated for the String table.
2098   status = status &amp;&amp; verify_interval(StringTableSize, minimumStringTableSize,
2099     (max_uintx / StringTable::bucket_size()), "StringTable size");
2100 
2101   status = status &amp;&amp; verify_interval(SymbolTableSize, minimumSymbolTableSize,
2102     (max_uintx / SymbolTable::bucket_size()), "SymbolTable size");
2103 
2104   {
2105     // Using "else if" below to avoid printing two error messages if min &gt; max.
2106     // This will also prevent us from reporting both min&gt;100 and max&gt;100 at the
2107     // same time, but that is less annoying than printing two identical errors IMHO.
2108     FormatBuffer&lt;80&gt; err_msg("");
2109     if (!verify_MinHeapFreeRatio(err_msg, MinHeapFreeRatio)) {
2110       jio_fprintf(defaultStream::error_stream(), "%s\n", err_msg.buffer());
2111       status = false;
2112     } else if (!verify_MaxHeapFreeRatio(err_msg, MaxHeapFreeRatio)) {
2113       jio_fprintf(defaultStream::error_stream(), "%s\n", err_msg.buffer());
2114       status = false;
2115     }
2116   }
2117 
2118   // Min/MaxMetaspaceFreeRatio
2119   status = status &amp;&amp; verify_percentage(MinMetaspaceFreeRatio, "MinMetaspaceFreeRatio");
2120   status = status &amp;&amp; verify_percentage(MaxMetaspaceFreeRatio, "MaxMetaspaceFreeRatio");
2121 
2122   if (MinMetaspaceFreeRatio &gt; MaxMetaspaceFreeRatio) {
2123     jio_fprintf(defaultStream::error_stream(),
2124                 "MinMetaspaceFreeRatio (%s" UINTX_FORMAT ") must be less than or "
2125                 "equal to MaxMetaspaceFreeRatio (%s" UINTX_FORMAT ")\n",
2126                 FLAG_IS_DEFAULT(MinMetaspaceFreeRatio) ? "Default: " : "",
2127                 MinMetaspaceFreeRatio,
2128                 FLAG_IS_DEFAULT(MaxMetaspaceFreeRatio) ? "Default: " : "",
2129                 MaxMetaspaceFreeRatio);
2130     status = false;
2131   }
2132 
2133   // Trying to keep 100% free is not practical
2134   MinMetaspaceFreeRatio = MIN2(MinMetaspaceFreeRatio, (uintx) 99);
2135 
2136   if (FullGCALot &amp;&amp; FLAG_IS_DEFAULT(MarkSweepAlwaysCompactCount)) {
2137     MarkSweepAlwaysCompactCount = 1;  // Move objects every gc.
2138   }
2139 
2140   if (UseParallelOldGC &amp;&amp; ParallelOldGCSplitALot) {
2141     // Settings to encourage splitting.
2142     if (!FLAG_IS_CMDLINE(NewRatio)) {
2143       FLAG_SET_CMDLINE(uintx, NewRatio, 2);
2144     }
2145     if (!FLAG_IS_CMDLINE(ScavengeBeforeFullGC)) {
2146       FLAG_SET_CMDLINE(bool, ScavengeBeforeFullGC, false);
2147     }
2148   }
2149 
2150   status = status &amp;&amp; verify_percentage(GCHeapFreeLimit, "GCHeapFreeLimit");
2151   status = status &amp;&amp; verify_percentage(GCTimeLimit, "GCTimeLimit");
2152   if (GCTimeLimit == 100) {
2153     // Turn off gc-overhead-limit-exceeded checks
2154     FLAG_SET_DEFAULT(UseGCOverheadLimit, false);
2155   }
2156 
2157   status = status &amp;&amp; check_gc_consistency();
2158   status = status &amp;&amp; check_stack_pages();
2159 
2160   if (CMSIncrementalMode) {
2161     if (!UseConcMarkSweepGC) {
2162       jio_fprintf(defaultStream::error_stream(),
2163                   "error:  invalid argument combination.\n"
2164                   "The CMS collector (-XX:+UseConcMarkSweepGC) must be "
2165                   "selected in order\nto use CMSIncrementalMode.\n");
2166       status = false;
2167     } else {
2168       status = status &amp;&amp; verify_percentage(CMSIncrementalDutyCycle,
2169                                   "CMSIncrementalDutyCycle");
2170       status = status &amp;&amp; verify_percentage(CMSIncrementalDutyCycleMin,
2171                                   "CMSIncrementalDutyCycleMin");
2172       status = status &amp;&amp; verify_percentage(CMSIncrementalSafetyFactor,
2173                                   "CMSIncrementalSafetyFactor");
2174       status = status &amp;&amp; verify_percentage(CMSIncrementalOffset,
2175                                   "CMSIncrementalOffset");
2176       status = status &amp;&amp; verify_percentage(CMSExpAvgFactor,
2177                                   "CMSExpAvgFactor");
2178       // If it was not set on the command line, set
2179       // CMSInitiatingOccupancyFraction to 1 so icms can initiate cycles early.
2180       if (CMSInitiatingOccupancyFraction &lt; 0) {
2181         FLAG_SET_DEFAULT(CMSInitiatingOccupancyFraction, 1);
2182       }
2183     }
2184   }
2185 
2186   // CMS space iteration, which FLSVerifyAllHeapreferences entails,
2187   // insists that we hold the requisite locks so that the iteration is
2188   // MT-safe. For the verification at start-up and shut-down, we don't
2189   // yet have a good way of acquiring and releasing these locks,
2190   // which are not visible at the CollectedHeap level. We want to
2191   // be able to acquire these locks and then do the iteration rather
2192   // than just disable the lock verification. This will be fixed under
2193   // bug 4788986.
2194   if (UseConcMarkSweepGC &amp;&amp; FLSVerifyAllHeapReferences) {
2195     if (VerifyDuringStartup) {
2196       warning("Heap verification at start-up disabled "
2197               "(due to current incompatibility with FLSVerifyAllHeapReferences)");
2198       VerifyDuringStartup = false; // Disable verification at start-up
2199     }
2200 
2201     if (VerifyBeforeExit) {
2202       warning("Heap verification at shutdown disabled "
2203               "(due to current incompatibility with FLSVerifyAllHeapReferences)");
2204       VerifyBeforeExit = false; // Disable verification at shutdown
2205     }
2206   }
2207 
2208   // Note: only executed in non-PRODUCT mode
2209   if (!UseAsyncConcMarkSweepGC &amp;&amp;
2210       (ExplicitGCInvokesConcurrent ||
2211        ExplicitGCInvokesConcurrentAndUnloadsClasses)) {
2212     jio_fprintf(defaultStream::error_stream(),
2213                 "error: +ExplicitGCInvokesConcurrent[AndUnloadsClasses] conflicts"
2214                 " with -UseAsyncConcMarkSweepGC");
2215     status = false;
2216   }
2217 
2218   status = status &amp;&amp; verify_min_value(ParGCArrayScanChunk, 1, "ParGCArrayScanChunk");
2219 
2220 #if INCLUDE_ALL_GCS
2221   if (UseG1GC) {
2222     status = status &amp;&amp; verify_percentage(G1NewSizePercent, "G1NewSizePercent");
2223     status = status &amp;&amp; verify_percentage(G1MaxNewSizePercent, "G1MaxNewSizePercent");
2224     status = status &amp;&amp; verify_interval(G1NewSizePercent, 0, G1MaxNewSizePercent, "G1NewSizePercent");
2225 
2226     status = status &amp;&amp; verify_percentage(InitiatingHeapOccupancyPercent,
2227                                          "InitiatingHeapOccupancyPercent");
2228     status = status &amp;&amp; verify_min_value(G1RefProcDrainInterval, 1,
2229                                         "G1RefProcDrainInterval");
2230     status = status &amp;&amp; verify_min_value((intx)G1ConcMarkStepDurationMillis, 1,
2231                                         "G1ConcMarkStepDurationMillis");
2232     status = status &amp;&amp; verify_interval(G1ConcRSHotCardLimit, 0, max_jubyte,
2233                                        "G1ConcRSHotCardLimit");
2234     status = status &amp;&amp; verify_interval(G1ConcRSLogCacheSize, 0, 31,
2235                                        "G1ConcRSLogCacheSize");
2236     status = status &amp;&amp; verify_interval(StringDeduplicationAgeThreshold, 1, markOopDesc::max_age,
2237                                        "StringDeduplicationAgeThreshold");
2238   }
2239   if (UseConcMarkSweepGC) {
2240     status = status &amp;&amp; verify_min_value(CMSOldPLABNumRefills, 1, "CMSOldPLABNumRefills");
2241     status = status &amp;&amp; verify_min_value(CMSOldPLABToleranceFactor, 1, "CMSOldPLABToleranceFactor");
2242     status = status &amp;&amp; verify_min_value(CMSOldPLABMax, 1, "CMSOldPLABMax");
2243     status = status &amp;&amp; verify_interval(CMSOldPLABMin, 1, CMSOldPLABMax, "CMSOldPLABMin");
2244 
2245     status = status &amp;&amp; verify_min_value(CMSYoungGenPerWorker, 1, "CMSYoungGenPerWorker");
2246 
2247     status = status &amp;&amp; verify_min_value(CMSSamplingGrain, 1, "CMSSamplingGrain");
2248     status = status &amp;&amp; verify_interval(CMS_SweepWeight, 0, 100, "CMS_SweepWeight");
2249     status = status &amp;&amp; verify_interval(CMS_FLSWeight, 0, 100, "CMS_FLSWeight");
2250 
2251     status = status &amp;&amp; verify_interval(FLSCoalescePolicy, 0, 4, "FLSCoalescePolicy");
2252 
2253     status = status &amp;&amp; verify_min_value(CMSRescanMultiple, 1, "CMSRescanMultiple");
2254     status = status &amp;&amp; verify_min_value(CMSConcMarkMultiple, 1, "CMSConcMarkMultiple");
2255 
2256     status = status &amp;&amp; verify_interval(CMSPrecleanIter, 0, 9, "CMSPrecleanIter");
2257     status = status &amp;&amp; verify_min_value(CMSPrecleanDenominator, 1, "CMSPrecleanDenominator");
2258     status = status &amp;&amp; verify_interval(CMSPrecleanNumerator, 0, CMSPrecleanDenominator - 1, "CMSPrecleanNumerator");
2259 
2260     status = status &amp;&amp; verify_percentage(CMSBootstrapOccupancy, "CMSBootstrapOccupancy");
2261 
2262     status = status &amp;&amp; verify_min_value(CMSPrecleanThreshold, 100, "CMSPrecleanThreshold");
2263 
2264     status = status &amp;&amp; verify_percentage(CMSScheduleRemarkEdenPenetration, "CMSScheduleRemarkEdenPenetration");
2265     status = status &amp;&amp; verify_min_value(CMSScheduleRemarkSamplingRatio, 1, "CMSScheduleRemarkSamplingRatio");
2266     status = status &amp;&amp; verify_min_value(CMSBitMapYieldQuantum, 1, "CMSBitMapYieldQuantum");
2267     status = status &amp;&amp; verify_percentage(CMSTriggerRatio, "CMSTriggerRatio");
2268     status = status &amp;&amp; verify_percentage(CMSIsTooFullPercentage, "CMSIsTooFullPercentage");
2269   }
2270 
2271   if (UseParallelGC || UseParallelOldGC) {
2272     status = status &amp;&amp; verify_interval(ParallelOldDeadWoodLimiterMean, 0, 100, "ParallelOldDeadWoodLimiterMean");
2273     status = status &amp;&amp; verify_interval(ParallelOldDeadWoodLimiterStdDev, 0, 100, "ParallelOldDeadWoodLimiterStdDev");
2274 
2275     status = status &amp;&amp; verify_percentage(YoungGenerationSizeIncrement, "YoungGenerationSizeIncrement");
2276     status = status &amp;&amp; verify_percentage(TenuredGenerationSizeIncrement, "TenuredGenerationSizeIncrement");
2277 
2278     status = status &amp;&amp; verify_min_value(YoungGenerationSizeSupplementDecay, 1, "YoungGenerationSizeSupplementDecay");
2279     status = status &amp;&amp; verify_min_value(TenuredGenerationSizeSupplementDecay, 1, "TenuredGenerationSizeSupplementDecay");
2280 
2281     status = status &amp;&amp; verify_min_value(ParGCCardsPerStrideChunk, 1, "ParGCCardsPerStrideChunk");
2282 
2283     status = status &amp;&amp; verify_min_value(ParallelOldGCSplitInterval, 0, "ParallelOldGCSplitInterval");
2284   }
2285 #endif // INCLUDE_ALL_GCS
2286 
2287   status = status &amp;&amp; verify_interval(RefDiscoveryPolicy,
2288                                      ReferenceProcessor::DiscoveryPolicyMin,
2289                                      ReferenceProcessor::DiscoveryPolicyMax,
2290                                      "RefDiscoveryPolicy");
2291 
2292   // Limit the lower bound of this flag to 1 as it is used in a division
2293   // expression.
2294   status = status &amp;&amp; verify_interval(TLABWasteTargetPercent,
2295                                      1, 100, "TLABWasteTargetPercent");
2296 
2297   status = status &amp;&amp; verify_object_alignment();
2298 
2299   status = status &amp;&amp; verify_interval(CompressedClassSpaceSize, 1*M, 3*G,
2300                                       "CompressedClassSpaceSize");
2301 
2302   status = status &amp;&amp; verify_interval(MarkStackSizeMax,
2303                                   1, (max_jint - 1), "MarkStackSizeMax");
2304   status = status &amp;&amp; verify_interval(NUMAChunkResizeWeight, 0, 100, "NUMAChunkResizeWeight");
2305 
2306   status = status &amp;&amp; verify_min_value(LogEventsBufferEntries, 1, "LogEventsBufferEntries");
2307 
2308   status = status &amp;&amp; verify_min_value(HeapSizePerGCThread, (uintx) os::vm_page_size(), "HeapSizePerGCThread");
2309 
2310   status = status &amp;&amp; verify_min_value(GCTaskTimeStampEntries, 1, "GCTaskTimeStampEntries");
2311 
2312   status = status &amp;&amp; verify_percentage(ParallelGCBufferWastePct, "ParallelGCBufferWastePct");
2313   status = status &amp;&amp; verify_interval(TargetPLABWastePct, 1, 100, "TargetPLABWastePct");
2314 
2315   status = status &amp;&amp; verify_min_value(ParGCStridesPerThread, 1, "ParGCStridesPerThread");
2316 
2317   status = status &amp;&amp; verify_min_value(MinRAMFraction, 1, "MinRAMFraction");
2318   status = status &amp;&amp; verify_min_value(InitialRAMFraction, 1, "InitialRAMFraction");
2319   status = status &amp;&amp; verify_min_value(MaxRAMFraction, 1, "MaxRAMFraction");
2320   status = status &amp;&amp; verify_min_value(DefaultMaxRAMFraction, 1, "DefaultMaxRAMFraction");
2321 
2322   status = status &amp;&amp; verify_interval(AdaptiveTimeWeight, 0, 100, "AdaptiveTimeWeight");
2323   status = status &amp;&amp; verify_min_value(AdaptiveSizeDecrementScaleFactor, 1, "AdaptiveSizeDecrementScaleFactor");
2324 
2325   status = status &amp;&amp; verify_interval(TLABAllocationWeight, 0, 100, "TLABAllocationWeight");
2326   status = status &amp;&amp; verify_min_value(MinTLABSize, 1, "MinTLABSize");
2327   status = status &amp;&amp; verify_min_value(TLABRefillWasteFraction, 1, "TLABRefillWasteFraction");
2328 
2329   status = status &amp;&amp; verify_percentage(YoungGenerationSizeSupplement, "YoungGenerationSizeSupplement");
2330   status = status &amp;&amp; verify_percentage(TenuredGenerationSizeSupplement, "TenuredGenerationSizeSupplement");
2331 
2332   status = status &amp;&amp; verify_interval(MaxTenuringThreshold, 0, markOopDesc::max_age + 1, "MaxTenuringThreshold");
2333   status = status &amp;&amp; verify_interval(InitialTenuringThreshold, 0, MaxTenuringThreshold, "InitialTenuringThreshold");
2334   status = status &amp;&amp; verify_percentage(TargetSurvivorRatio, "TargetSurvivorRatio");
2335   status = status &amp;&amp; verify_percentage(MarkSweepDeadRatio, "MarkSweepDeadRatio");
2336 
2337   status = status &amp;&amp; verify_min_value(MarkSweepAlwaysCompactCount, 1, "MarkSweepAlwaysCompactCount");
2338 
2339   if (PrintNMTStatistics) {
2340 #if INCLUDE_NMT
2341     if (MemTracker::tracking_level() == MemTracker::NMT_off) {
2342 #endif // INCLUDE_NMT
2343       warning("PrintNMTStatistics is disabled, because native memory tracking is not enabled");
2344       PrintNMTStatistics = false;
2345 #if INCLUDE_NMT
2346     }
2347 #endif
2348   }
2349 
2350   // Need to limit the extent of the padding to reasonable size.
2351   // 8K is well beyond the reasonable HW cache line size, even with the
2352   // aggressive prefetching, while still leaving the room for segregating
2353   // among the distinct pages.
2354   if (ContendedPaddingWidth &lt; 0 || ContendedPaddingWidth &gt; 8192) {
2355     jio_fprintf(defaultStream::error_stream(),
2356                 "ContendedPaddingWidth=" INTX_FORMAT " must be in between %d and %d\n",
2357                 ContendedPaddingWidth, 0, 8192);
2358     status = false;
2359   }
2360 
2361   // Need to enforce the padding not to break the existing field alignments.
2362   // It is sufficient to check against the largest type size.
2363   if ((ContendedPaddingWidth % BytesPerLong) != 0) {
2364     jio_fprintf(defaultStream::error_stream(),
2365                 "ContendedPaddingWidth=" INTX_FORMAT " must be a multiple of %d\n",
2366                 ContendedPaddingWidth, BytesPerLong);
2367     status = false;
2368   }
2369 
2370   // Check lower bounds of the code cache
2371   // Template Interpreter code is approximately 3X larger in debug builds.
2372   uint min_code_cache_size = (CodeCacheMinimumUseSpace DEBUG_ONLY(* 3)) + CodeCacheMinimumFreeSpace;
2373   if (InitialCodeCacheSize &lt; (uintx)os::vm_page_size()) {
2374     jio_fprintf(defaultStream::error_stream(),
2375                 "Invalid InitialCodeCacheSize=%dK. Must be at least %dK.\n", InitialCodeCacheSize/K,
2376                 os::vm_page_size()/K);
2377     status = false;
2378   } else if (ReservedCodeCacheSize &lt; InitialCodeCacheSize) {
2379     jio_fprintf(defaultStream::error_stream(),
2380                 "Invalid ReservedCodeCacheSize: %dK. Must be at least InitialCodeCacheSize=%dK.\n",
2381                 ReservedCodeCacheSize/K, InitialCodeCacheSize/K);
2382     status = false;
2383   } else if (ReservedCodeCacheSize &lt; min_code_cache_size) {
2384     jio_fprintf(defaultStream::error_stream(),
2385                 "Invalid ReservedCodeCacheSize=%dK. Must be at least %uK.\n", ReservedCodeCacheSize/K,
2386                 min_code_cache_size/K);
2387     status = false;
2388   } else if (ReservedCodeCacheSize &gt; 2*G) {
2389     // Code cache size larger than MAXINT is not supported.
2390     jio_fprintf(defaultStream::error_stream(),
2391                 "Invalid ReservedCodeCacheSize=%dM. Must be at most %uM.\n", ReservedCodeCacheSize/M,
2392                 (2*G)/M);
2393     status = false;
2394   }
2395 
2396   status &amp;= verify_interval(NmethodSweepFraction, 1, ReservedCodeCacheSize/K, "NmethodSweepFraction");
2397   status &amp;= verify_interval(NmethodSweepActivity, 0, 2000, "NmethodSweepActivity");
2398   status &amp;= verify_interval(CodeCacheMinBlockLength, 1, 100, "CodeCacheMinBlockLength");
2399   status &amp;= verify_interval(CodeCacheSegmentSize, 1, 1024, "CodeCacheSegmentSize");
2400 
2401   // TieredCompilation needs at least 2 compiler threads.
2402   const int num_min_compiler_threads = (TieredCompilation &amp;&amp; (TieredStopAtLevel &gt;= CompLevel_full_optimization)) ? 2 : 1;
2403   status &amp;=verify_min_value(CICompilerCount, num_min_compiler_threads, "CICompilerCount");
2404 
2405   if (!FLAG_IS_DEFAULT(CICompilerCount) &amp;&amp; !FLAG_IS_DEFAULT(CICompilerCountPerCPU) &amp;&amp; CICompilerCountPerCPU) {
2406     warning("The VM option CICompilerCountPerCPU overrides CICompilerCount.");
2407   }
2408 
2409   return status;
2410 }
2411 
2412 bool Arguments::is_bad_option(const JavaVMOption* option, jboolean ignore,
2413   const char* option_type) {
2414   if (ignore) return false;
2415 
2416   const char* spacer = " ";
2417   if (option_type == NULL) {
2418     option_type = ++spacer; // Set both to the empty string.
2419   }
2420 
2421   if (os::obsolete_option(option)) {
2422     jio_fprintf(defaultStream::error_stream(),
2423                 "Obsolete %s%soption: %s\n", option_type, spacer,
2424       option-&gt;optionString);
2425     return false;
2426   } else {
2427     jio_fprintf(defaultStream::error_stream(),
2428                 "Unrecognized %s%soption: %s\n", option_type, spacer,
2429       option-&gt;optionString);
2430     return true;
2431   }
2432 }
2433 
2434 static const char* user_assertion_options[] = {
2435   "-da", "-ea", "-disableassertions", "-enableassertions", 0
2436 };
2437 
2438 static const char* system_assertion_options[] = {
2439   "-dsa", "-esa", "-disablesystemassertions", "-enablesystemassertions", 0
2440 };
2441 
2442 // Return true if any of the strings in null-terminated array 'names' matches.
2443 // If tail_allowed is true, then the tail must begin with a colon; otherwise,
2444 // the option must match exactly.
2445 static bool match_option(const JavaVMOption* option, const char** names, const char** tail,
2446   bool tail_allowed) {
2447   for (/* empty */; *names != NULL; ++names) {
2448     if (match_option(option, *names, tail)) {
2449       if (**tail == '\0' || tail_allowed &amp;&amp; **tail == ':') {
2450         return true;
2451       }
2452     }
2453   }
2454   return false;
2455 }
2456 
2457 bool Arguments::parse_uintx(const char* value,
2458                             uintx* uintx_arg,
2459                             uintx min_size) {
2460 
2461   // Check the sign first since atomull() parses only unsigned values.
2462   bool value_is_positive = !(*value == '-');
2463 
2464   if (value_is_positive) {
2465     julong n;
2466     bool good_return = atomull(value, &amp;n);
2467     if (good_return) {
2468       bool above_minimum = n &gt;= min_size;
2469       bool value_is_too_large = n &gt; max_uintx;
2470 
2471       if (above_minimum &amp;&amp; !value_is_too_large) {
2472         *uintx_arg = n;
2473         return true;
2474       }
2475     }
2476   }
2477   return false;
2478 }
2479 
2480 Arguments::ArgsRange Arguments::parse_memory_size(const char* s,
2481                                                   julong* long_arg,
2482                                                   julong min_size) {
2483   if (!atomull(s, long_arg)) return arg_unreadable;
2484   return check_memory_size(*long_arg, min_size);
2485 }
2486 
2487 // Parse JavaVMInitArgs structure
2488 
2489 jint Arguments::parse_vm_init_args(const JavaVMInitArgs* args) {
2490   // For components of the system classpath.
2491   SysClassPath scp(Arguments::get_sysclasspath());
2492   bool scp_assembly_required = false;
2493 
2494   // Save default settings for some mode flags
2495   Arguments::_AlwaysCompileLoopMethods = AlwaysCompileLoopMethods;
2496   Arguments::_UseOnStackReplacement    = UseOnStackReplacement;
2497   Arguments::_ClipInlining             = ClipInlining;
2498   Arguments::_BackgroundCompilation    = BackgroundCompilation;
2499 
2500   // Setup flags for mixed which is the default
2501   set_mode_flags(_mixed);
2502 
2503   // Parse JAVA_TOOL_OPTIONS environment variable (if present)
2504   jint result = parse_java_tool_options_environment_variable(&amp;scp, &amp;scp_assembly_required);
2505   if (result != JNI_OK) {
2506     return result;
2507   }
2508 
2509   // Parse JavaVMInitArgs structure passed in
2510   result = parse_each_vm_init_arg(args, &amp;scp, &amp;scp_assembly_required, Flag::COMMAND_LINE);
2511   if (result != JNI_OK) {
2512     return result;
2513   }
2514 
2515   // Parse _JAVA_OPTIONS environment variable (if present) (mimics classic VM)
2516   result = parse_java_options_environment_variable(&amp;scp, &amp;scp_assembly_required);
2517   if (result != JNI_OK) {
2518     return result;
2519   }
2520 
2521   // Do final processing now that all arguments have been parsed
2522   result = finalize_vm_init_args(&amp;scp, scp_assembly_required);
2523   if (result != JNI_OK) {
2524     return result;
2525   }
2526 
2527   return JNI_OK;
2528 }
2529 
2530 // Checks if name in command-line argument -agent{lib,path}:name[=options]
2531 // represents a valid HPROF of JDWP agent.  is_path==true denotes that we
2532 // are dealing with -agentpath (case where name is a path), otherwise with
2533 // -agentlib
2534 bool valid_hprof_or_jdwp_agent(char *name, bool is_path) {
2535   char *_name;
2536   const char *_hprof = "hprof", *_jdwp = "jdwp";
2537   size_t _len_hprof, _len_jdwp, _len_prefix;
2538 
2539   if (is_path) {
2540     if ((_name = strrchr(name, (int) *os::file_separator())) == NULL) {
2541       return false;
2542     }
2543 
2544     _name++;  // skip past last path separator
2545     _len_prefix = strlen(JNI_LIB_PREFIX);
2546 
2547     if (strncmp(_name, JNI_LIB_PREFIX, _len_prefix) != 0) {
2548       return false;
2549     }
2550 
2551     _name += _len_prefix;
2552     _len_hprof = strlen(_hprof);
2553     _len_jdwp = strlen(_jdwp);
2554 
2555     if (strncmp(_name, _hprof, _len_hprof) == 0) {
2556       _name += _len_hprof;
2557     }
2558     else if (strncmp(_name, _jdwp, _len_jdwp) == 0) {
2559       _name += _len_jdwp;
2560     }
2561     else {
2562       return false;
2563     }
2564 
2565     if (strcmp(_name, JNI_LIB_SUFFIX) != 0) {
2566       return false;
2567     }
2568 
2569     return true;
2570   }
2571 
2572   if (strcmp(name, _hprof) == 0 || strcmp(name, _jdwp) == 0) {
2573     return true;
2574   }
2575 
2576   return false;
2577 }
2578 
2579 jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args,
2580                                        SysClassPath* scp_p,
2581                                        bool* scp_assembly_required_p,
2582                                        Flag::Flags origin) {
2583   // Remaining part of option string
2584   const char* tail;
2585 
2586   // iterate over arguments
2587   for (int index = 0; index &lt; args-&gt;nOptions; index++) {
2588     bool is_absolute_path = false;  // for -agentpath vs -agentlib
2589 
2590     const JavaVMOption* option = args-&gt;options + index;
2591 
2592     if (!match_option(option, "-Djava.class.path", &amp;tail) &amp;&amp;
2593         !match_option(option, "-Dsun.java.command", &amp;tail) &amp;&amp;
2594         !match_option(option, "-Dsun.java.launcher", &amp;tail)) {
2595 
2596         // add all jvm options to the jvm_args string. This string
2597         // is used later to set the java.vm.args PerfData string constant.
2598         // the -Djava.class.path and the -Dsun.java.command options are
2599         // omitted from jvm_args string as each have their own PerfData
2600         // string constant object.
2601         build_jvm_args(option-&gt;optionString);
2602     }
2603 
2604     // -verbose:[class/gc/jni]
2605     if (match_option(option, "-verbose", &amp;tail)) {
2606       if (!strcmp(tail, ":class") || !strcmp(tail, "")) {
2607         FLAG_SET_CMDLINE(bool, TraceClassLoading, true);
2608         FLAG_SET_CMDLINE(bool, TraceClassUnloading, true);
2609       } else if (!strcmp(tail, ":gc")) {
2610         FLAG_SET_CMDLINE(bool, PrintGC, true);
2611       } else if (!strcmp(tail, ":jni")) {
2612         FLAG_SET_CMDLINE(bool, PrintJNIResolving, true);
2613       }
2614     // -da / -ea / -disableassertions / -enableassertions
2615     // These accept an optional class/package name separated by a colon, e.g.,
2616     // -da:java.lang.Thread.
2617     } else if (match_option(option, user_assertion_options, &amp;tail, true)) {
2618       bool enable = option-&gt;optionString[1] == 'e';     // char after '-' is 'e'
2619       if (*tail == '\0') {
2620         JavaAssertions::setUserClassDefault(enable);
2621       } else {
2622         assert(*tail == ':', "bogus match by match_option()");
2623         JavaAssertions::addOption(tail + 1, enable);
2624       }
2625     // -dsa / -esa / -disablesystemassertions / -enablesystemassertions
2626     } else if (match_option(option, system_assertion_options, &amp;tail, false)) {
2627       bool enable = option-&gt;optionString[1] == 'e';     // char after '-' is 'e'
2628       JavaAssertions::setSystemClassDefault(enable);
2629     // -bootclasspath:
2630     } else if (match_option(option, "-Xbootclasspath:", &amp;tail)) {
2631       scp_p-&gt;reset_path(tail);
2632       *scp_assembly_required_p = true;
2633     // -bootclasspath/a:
2634     } else if (match_option(option, "-Xbootclasspath/a:", &amp;tail)) {
2635       scp_p-&gt;add_suffix(tail);
2636       *scp_assembly_required_p = true;
2637     // -bootclasspath/p:
2638     } else if (match_option(option, "-Xbootclasspath/p:", &amp;tail)) {
2639       scp_p-&gt;add_prefix(tail);
2640       *scp_assembly_required_p = true;
2641     // -Xrun
2642     } else if (match_option(option, "-Xrun", &amp;tail)) {
2643       if (tail != NULL) {
2644         const char* pos = strchr(tail, ':');
2645         size_t len = (pos == NULL) ? strlen(tail) : pos - tail;
2646         char* name = (char*)memcpy(NEW_C_HEAP_ARRAY(char, len + 1, mtInternal), tail, len);
2647         name[len] = '\0';
2648 
2649         char *options = NULL;
2650         if(pos != NULL) {
2651           size_t len2 = strlen(pos+1) + 1; // options start after ':'.  Final zero must be copied.
2652           options = (char*)memcpy(NEW_C_HEAP_ARRAY(char, len2, mtInternal), pos+1, len2);
2653         }
2654 #if !INCLUDE_JVMTI
2655         if ((strcmp(name, "hprof") == 0) || (strcmp(name, "jdwp") == 0)) {
2656           jio_fprintf(defaultStream::error_stream(),
2657             "Profiling and debugging agents are not supported in this VM\n");
2658           return JNI_ERR;
2659         }
2660 #endif // !INCLUDE_JVMTI
2661         add_init_library(name, options);
2662       }
2663     // -agentlib and -agentpath
2664     } else if (match_option(option, "-agentlib:", &amp;tail) ||
2665           (is_absolute_path = match_option(option, "-agentpath:", &amp;tail))) {
2666       if(tail != NULL) {
2667         const char* pos = strchr(tail, '=');
2668         size_t len = (pos == NULL) ? strlen(tail) : pos - tail;
2669         char* name = strncpy(NEW_C_HEAP_ARRAY(char, len + 1, mtInternal), tail, len);
2670         name[len] = '\0';
2671 
2672         char *options = NULL;
2673         if(pos != NULL) {
2674           options = strcpy(NEW_C_HEAP_ARRAY(char, strlen(pos + 1) + 1, mtInternal), pos + 1);
2675         }
2676 #if !INCLUDE_JVMTI
2677         if (valid_hprof_or_jdwp_agent(name, is_absolute_path)) {
2678           jio_fprintf(defaultStream::error_stream(),
2679             "Profiling and debugging agents are not supported in this VM\n");
2680           return JNI_ERR;
2681         }
2682 #endif // !INCLUDE_JVMTI
2683         add_init_agent(name, options, is_absolute_path);
2684       }
2685     // -javaagent
2686     } else if (match_option(option, "-javaagent:", &amp;tail)) {
2687 #if !INCLUDE_JVMTI
2688       jio_fprintf(defaultStream::error_stream(),
2689         "Instrumentation agents are not supported in this VM\n");
2690       return JNI_ERR;
2691 #else
2692       if(tail != NULL) {
2693         char *options = strcpy(NEW_C_HEAP_ARRAY(char, strlen(tail) + 1, mtInternal), tail);
2694         add_init_agent("instrument", options, false);
2695       }
2696 #endif // !INCLUDE_JVMTI
2697     // -Xnoclassgc
2698     } else if (match_option(option, "-Xnoclassgc", &amp;tail)) {
2699       FLAG_SET_CMDLINE(bool, ClassUnloading, false);
2700     // -Xincgc: i-CMS
2701     } else if (match_option(option, "-Xincgc", &amp;tail)) {
2702       FLAG_SET_CMDLINE(bool, UseConcMarkSweepGC, true);
2703       FLAG_SET_CMDLINE(bool, CMSIncrementalMode, true);
2704     // -Xnoincgc: no i-CMS
2705     } else if (match_option(option, "-Xnoincgc", &amp;tail)) {
2706       FLAG_SET_CMDLINE(bool, UseConcMarkSweepGC, false);
2707       FLAG_SET_CMDLINE(bool, CMSIncrementalMode, false);
2708     // -Xconcgc
2709     } else if (match_option(option, "-Xconcgc", &amp;tail)) {
2710       FLAG_SET_CMDLINE(bool, UseConcMarkSweepGC, true);
2711     // -Xnoconcgc
2712     } else if (match_option(option, "-Xnoconcgc", &amp;tail)) {
2713       FLAG_SET_CMDLINE(bool, UseConcMarkSweepGC, false);
2714     // -Xbatch
2715     } else if (match_option(option, "-Xbatch", &amp;tail)) {
2716       FLAG_SET_CMDLINE(bool, BackgroundCompilation, false);
2717     // -Xmn for compatibility with other JVM vendors
2718     } else if (match_option(option, "-Xmn", &amp;tail)) {
2719       julong long_initial_young_size = 0;
2720       ArgsRange errcode = parse_memory_size(tail, &amp;long_initial_young_size, 1);
2721       if (errcode != arg_in_range) {
2722         jio_fprintf(defaultStream::error_stream(),
2723                     "Invalid initial young generation size: %s\n", option-&gt;optionString);
2724         describe_range_error(errcode);
2725         return JNI_EINVAL;
2726       }
2727       FLAG_SET_CMDLINE(uintx, MaxNewSize, (uintx)long_initial_young_size);
2728       FLAG_SET_CMDLINE(uintx, NewSize, (uintx)long_initial_young_size);
2729     // -Xms
2730     } else if (match_option(option, "-Xms", &amp;tail)) {
2731       julong long_initial_heap_size = 0;
2732       // an initial heap size of 0 means automatically determine
2733       ArgsRange errcode = parse_memory_size(tail, &amp;long_initial_heap_size, 0);
2734       if (errcode != arg_in_range) {
2735         jio_fprintf(defaultStream::error_stream(),
2736                     "Invalid initial heap size: %s\n", option-&gt;optionString);
2737         describe_range_error(errcode);
2738         return JNI_EINVAL;
2739       }
2740       set_min_heap_size((uintx)long_initial_heap_size);
2741       // Currently the minimum size and the initial heap sizes are the same.
2742       // Can be overridden with -XX:InitialHeapSize.
2743       FLAG_SET_CMDLINE(uintx, InitialHeapSize, (uintx)long_initial_heap_size);
2744     // -Xmx
2745     } else if (match_option(option, "-Xmx", &amp;tail) || match_option(option, "-XX:MaxHeapSize=", &amp;tail)) {
2746       julong long_max_heap_size = 0;
2747       ArgsRange errcode = parse_memory_size(tail, &amp;long_max_heap_size, 1);
2748       if (errcode != arg_in_range) {
2749         jio_fprintf(defaultStream::error_stream(),
2750                     "Invalid maximum heap size: %s\n", option-&gt;optionString);
2751         describe_range_error(errcode);
2752         return JNI_EINVAL;
2753       }
2754       FLAG_SET_CMDLINE(uintx, MaxHeapSize, (uintx)long_max_heap_size);
2755     // Xmaxf
2756     } else if (match_option(option, "-Xmaxf", &amp;tail)) {
2757       char* err;
2758       int maxf = (int)(strtod(tail, &amp;err) * 100);
2759       if (*err != '\0' || *tail == '\0' || maxf &lt; 0 || maxf &gt; 100) {
2760         jio_fprintf(defaultStream::error_stream(),
2761                     "Bad max heap free percentage size: %s\n",
2762                     option-&gt;optionString);
2763         return JNI_EINVAL;
2764       } else {
2765         FLAG_SET_CMDLINE(uintx, MaxHeapFreeRatio, maxf);
2766       }
2767     // Xminf
2768     } else if (match_option(option, "-Xminf", &amp;tail)) {
2769       char* err;
2770       int minf = (int)(strtod(tail, &amp;err) * 100);
2771       if (*err != '\0' || *tail == '\0' || minf &lt; 0 || minf &gt; 100) {
2772         jio_fprintf(defaultStream::error_stream(),
2773                     "Bad min heap free percentage size: %s\n",
2774                     option-&gt;optionString);
2775         return JNI_EINVAL;
2776       } else {
2777         FLAG_SET_CMDLINE(uintx, MinHeapFreeRatio, minf);
2778       }
2779     // -Xss
2780     } else if (match_option(option, "-Xss", &amp;tail)) {
2781       julong long_ThreadStackSize = 0;
2782       ArgsRange errcode = parse_memory_size(tail, &amp;long_ThreadStackSize, 1000);
2783       if (errcode != arg_in_range) {
2784         jio_fprintf(defaultStream::error_stream(),
2785                     "Invalid thread stack size: %s\n", option-&gt;optionString);
2786         describe_range_error(errcode);
2787         return JNI_EINVAL;
2788       }
2789       // Internally track ThreadStackSize in units of 1024 bytes.
2790       FLAG_SET_CMDLINE(intx, ThreadStackSize,
2791                               round_to((int)long_ThreadStackSize, K) / K);
2792     // -Xoss
2793     } else if (match_option(option, "-Xoss", &amp;tail)) {
2794           // HotSpot does not have separate native and Java stacks, ignore silently for compatibility
2795     } else if (match_option(option, "-XX:CodeCacheExpansionSize=", &amp;tail)) {
2796       julong long_CodeCacheExpansionSize = 0;
2797       ArgsRange errcode = parse_memory_size(tail, &amp;long_CodeCacheExpansionSize, os::vm_page_size());
2798       if (errcode != arg_in_range) {
2799         jio_fprintf(defaultStream::error_stream(),
2800                    "Invalid argument: %s. Must be at least %luK.\n", option-&gt;optionString,
2801                    os::vm_page_size()/K);
2802         return JNI_EINVAL;
2803       }
2804       FLAG_SET_CMDLINE(uintx, CodeCacheExpansionSize, (uintx)long_CodeCacheExpansionSize);
2805     } else if (match_option(option, "-Xmaxjitcodesize", &amp;tail) ||
2806                match_option(option, "-XX:ReservedCodeCacheSize=", &amp;tail)) {
2807       julong long_ReservedCodeCacheSize = 0;
2808 
2809       ArgsRange errcode = parse_memory_size(tail, &amp;long_ReservedCodeCacheSize, 1);
2810       if (errcode != arg_in_range) {
2811         jio_fprintf(defaultStream::error_stream(),
2812                     "Invalid maximum code cache size: %s.\n", option-&gt;optionString);
2813         return JNI_EINVAL;
2814       }
2815       FLAG_SET_CMDLINE(uintx, ReservedCodeCacheSize, (uintx)long_ReservedCodeCacheSize);
2816       //-XX:IncreaseFirstTierCompileThresholdAt=
2817       } else if (match_option(option, "-XX:IncreaseFirstTierCompileThresholdAt=", &amp;tail)) {
2818         uintx uint_IncreaseFirstTierCompileThresholdAt = 0;
2819         if (!parse_uintx(tail, &amp;uint_IncreaseFirstTierCompileThresholdAt, 0) || uint_IncreaseFirstTierCompileThresholdAt &gt; 99) {
2820           jio_fprintf(defaultStream::error_stream(),
2821                       "Invalid value for IncreaseFirstTierCompileThresholdAt: %s. Should be between 0 and 99.\n",
2822                       option-&gt;optionString);
2823           return JNI_EINVAL;
2824         }
2825         FLAG_SET_CMDLINE(uintx, IncreaseFirstTierCompileThresholdAt, (uintx)uint_IncreaseFirstTierCompileThresholdAt);
2826     // -green
2827     } else if (match_option(option, "-green", &amp;tail)) {
2828       jio_fprintf(defaultStream::error_stream(),
2829                   "Green threads support not available\n");
2830           return JNI_EINVAL;
2831     // -native
2832     } else if (match_option(option, "-native", &amp;tail)) {
2833           // HotSpot always uses native threads, ignore silently for compatibility
2834     // -Xsqnopause
2835     } else if (match_option(option, "-Xsqnopause", &amp;tail)) {
2836           // EVM option, ignore silently for compatibility
2837     // -Xrs
2838     } else if (match_option(option, "-Xrs", &amp;tail)) {
2839           // Classic/EVM option, new functionality
2840       FLAG_SET_CMDLINE(bool, ReduceSignalUsage, true);
2841     } else if (match_option(option, "-Xusealtsigs", &amp;tail)) {
2842           // change default internal VM signals used - lower case for back compat
2843       FLAG_SET_CMDLINE(bool, UseAltSigs, true);
2844     // -Xoptimize
2845     } else if (match_option(option, "-Xoptimize", &amp;tail)) {
2846           // EVM option, ignore silently for compatibility
2847     // -Xprof
2848     } else if (match_option(option, "-Xprof", &amp;tail)) {
2849 #if INCLUDE_FPROF
2850       _has_profile = true;
2851 #else // INCLUDE_FPROF
2852       jio_fprintf(defaultStream::error_stream(),
2853         "Flat profiling is not supported in this VM.\n");
2854       return JNI_ERR;
2855 #endif // INCLUDE_FPROF
2856     // -Xconcurrentio
2857     } else if (match_option(option, "-Xconcurrentio", &amp;tail)) {
2858       FLAG_SET_CMDLINE(bool, UseLWPSynchronization, true);
2859       FLAG_SET_CMDLINE(bool, BackgroundCompilation, false);
2860       FLAG_SET_CMDLINE(intx, DeferThrSuspendLoopCount, 1);
2861       FLAG_SET_CMDLINE(bool, UseTLAB, false);
2862       FLAG_SET_CMDLINE(uintx, NewSizeThreadIncrease, 16 * K);  // 20Kb per thread added to new generation
2863 
2864       // -Xinternalversion
2865     } else if (match_option(option, "-Xinternalversion", &amp;tail)) {
2866       jio_fprintf(defaultStream::output_stream(), "%s\n",
2867                   VM_Version::internal_vm_info_string());
2868       vm_exit(0);
2869 #ifndef PRODUCT
2870     // -Xprintflags
2871     } else if (match_option(option, "-Xprintflags", &amp;tail)) {
2872       CommandLineFlags::printFlags(tty, false);
2873       vm_exit(0);
2874 #endif
2875     // -D
2876     } else if (match_option(option, "-D", &amp;tail)) {
2877       if (!add_property(tail)) {
2878         return JNI_ENOMEM;
2879       }
2880       // Out of the box management support
2881       if (match_option(option, "-Dcom.sun.management", &amp;tail)) {
2882 #if INCLUDE_MANAGEMENT
2883         FLAG_SET_CMDLINE(bool, ManagementServer, true);
2884 #else
2885         jio_fprintf(defaultStream::output_stream(),
2886           "-Dcom.sun.management is not supported in this VM.\n");
2887         return JNI_ERR;
2888 #endif
2889       }
2890     // -Xint
2891     } else if (match_option(option, "-Xint", &amp;tail)) {
2892           set_mode_flags(_int);
2893     // -Xmixed
2894     } else if (match_option(option, "-Xmixed", &amp;tail)) {
2895           set_mode_flags(_mixed);
2896     // -Xcomp
2897     } else if (match_option(option, "-Xcomp", &amp;tail)) {
2898       // for testing the compiler; turn off all flags that inhibit compilation
2899           set_mode_flags(_comp);
2900     // -Xshare:dump
2901     } else if (match_option(option, "-Xshare:dump", &amp;tail)) {
2902       FLAG_SET_CMDLINE(bool, DumpSharedSpaces, true);
2903       set_mode_flags(_int);     // Prevent compilation, which creates objects
2904     // -Xshare:on
2905     } else if (match_option(option, "-Xshare:on", &amp;tail)) {
2906       FLAG_SET_CMDLINE(bool, UseSharedSpaces, true);
2907       FLAG_SET_CMDLINE(bool, RequireSharedSpaces, true);
2908     // -Xshare:auto
2909     } else if (match_option(option, "-Xshare:auto", &amp;tail)) {
2910       FLAG_SET_CMDLINE(bool, UseSharedSpaces, true);
2911       FLAG_SET_CMDLINE(bool, RequireSharedSpaces, false);
2912     // -Xshare:off
2913     } else if (match_option(option, "-Xshare:off", &amp;tail)) {
2914       FLAG_SET_CMDLINE(bool, UseSharedSpaces, false);
2915       FLAG_SET_CMDLINE(bool, RequireSharedSpaces, false);
2916     // -Xverify
2917     } else if (match_option(option, "-Xverify", &amp;tail)) {
2918       if (strcmp(tail, ":all") == 0 || strcmp(tail, "") == 0) {
2919         FLAG_SET_CMDLINE(bool, BytecodeVerificationLocal, true);
2920         FLAG_SET_CMDLINE(bool, BytecodeVerificationRemote, true);
2921       } else if (strcmp(tail, ":remote") == 0) {
2922         FLAG_SET_CMDLINE(bool, BytecodeVerificationLocal, false);
2923         FLAG_SET_CMDLINE(bool, BytecodeVerificationRemote, true);
2924       } else if (strcmp(tail, ":none") == 0) {
2925         FLAG_SET_CMDLINE(bool, BytecodeVerificationLocal, false);
2926         FLAG_SET_CMDLINE(bool, BytecodeVerificationRemote, false);
2927       } else if (is_bad_option(option, args-&gt;ignoreUnrecognized, "verification")) {
2928         return JNI_EINVAL;
2929       }
2930     // -Xdebug
2931     } else if (match_option(option, "-Xdebug", &amp;tail)) {
2932       // note this flag has been used, then ignore
2933       set_xdebug_mode(true);
2934     // -Xnoagent
2935     } else if (match_option(option, "-Xnoagent", &amp;tail)) {
2936       // For compatibility with classic. HotSpot refuses to load the old style agent.dll.
2937     } else if (match_option(option, "-Xboundthreads", &amp;tail)) {
2938       // Bind user level threads to kernel threads (Solaris only)
2939       FLAG_SET_CMDLINE(bool, UseBoundThreads, true);
2940     } else if (match_option(option, "-Xloggc:", &amp;tail)) {
2941       // Redirect GC output to the file. -Xloggc:&lt;filename&gt;
2942       // ostream_init_log(), when called will use this filename
2943       // to initialize a fileStream.
2944       _gc_log_filename = strdup(tail);
2945      if (!is_filename_valid(_gc_log_filename)) {
2946        jio_fprintf(defaultStream::output_stream(),
2947                   "Invalid file name for use with -Xloggc: Filename can only contain the "
2948                   "characters [A-Z][a-z][0-9]-_.%%[p|t] but it has been %s\n"
2949                   "Note %%p or %%t can only be used once\n", _gc_log_filename);
2950         return JNI_EINVAL;
2951       }
2952       FLAG_SET_CMDLINE(bool, PrintGC, true);
2953       FLAG_SET_CMDLINE(bool, PrintGCTimeStamps, true);
2954 
2955     // JNI hooks
2956     } else if (match_option(option, "-Xcheck", &amp;tail)) {
2957       if (!strcmp(tail, ":jni")) {
2958 #if !INCLUDE_JNI_CHECK
2959         warning("JNI CHECKING is not supported in this VM");
2960 #else
2961         CheckJNICalls = true;
2962 #endif // INCLUDE_JNI_CHECK
2963       } else if (is_bad_option(option, args-&gt;ignoreUnrecognized,
2964                                      "check")) {
2965         return JNI_EINVAL;
2966       }
2967     } else if (match_option(option, "vfprintf", &amp;tail)) {
2968       _vfprintf_hook = CAST_TO_FN_PTR(vfprintf_hook_t, option-&gt;extraInfo);
2969     } else if (match_option(option, "exit", &amp;tail)) {
2970       _exit_hook = CAST_TO_FN_PTR(exit_hook_t, option-&gt;extraInfo);
2971     } else if (match_option(option, "abort", &amp;tail)) {
2972       _abort_hook = CAST_TO_FN_PTR(abort_hook_t, option-&gt;extraInfo);
2973     // -XX:+AggressiveHeap
2974     } else if (match_option(option, "-XX:+AggressiveHeap", &amp;tail)) {
2975 
2976       // This option inspects the machine and attempts to set various
2977       // parameters to be optimal for long-running, memory allocation
2978       // intensive jobs.  It is intended for machines with large
2979       // amounts of cpu and memory.
2980 
2981       // initHeapSize is needed since _initial_heap_size is 4 bytes on a 32 bit
2982       // VM, but we may not be able to represent the total physical memory
2983       // available (like having 8gb of memory on a box but using a 32bit VM).
2984       // Thus, we need to make sure we're using a julong for intermediate
2985       // calculations.
2986       julong initHeapSize;
2987       julong total_memory = os::physical_memory();
2988 
2989       if (total_memory &lt; (julong)256*M) {
2990         jio_fprintf(defaultStream::error_stream(),
2991                     "You need at least 256mb of memory to use -XX:+AggressiveHeap\n");
2992         vm_exit(1);
2993       }
2994 
2995       // The heap size is half of available memory, or (at most)
2996       // all of possible memory less 160mb (leaving room for the OS
2997       // when using ISM).  This is the maximum; because adaptive sizing
2998       // is turned on below, the actual space used may be smaller.
2999 
3000       initHeapSize = MIN2(total_memory / (julong)2,
3001                           total_memory - (julong)160*M);
3002 
3003       initHeapSize = limit_by_allocatable_memory(initHeapSize);
3004 
3005       if (FLAG_IS_DEFAULT(MaxHeapSize)) {
3006          FLAG_SET_CMDLINE(uintx, MaxHeapSize, initHeapSize);
3007          FLAG_SET_CMDLINE(uintx, InitialHeapSize, initHeapSize);
3008          // Currently the minimum size and the initial heap sizes are the same.
3009          set_min_heap_size(initHeapSize);
3010       }
3011       if (FLAG_IS_DEFAULT(NewSize)) {
3012          // Make the young generation 3/8ths of the total heap.
3013          FLAG_SET_CMDLINE(uintx, NewSize,
3014                                 ((julong)MaxHeapSize / (julong)8) * (julong)3);
3015          FLAG_SET_CMDLINE(uintx, MaxNewSize, NewSize);
3016       }
3017 
3018 #ifndef _ALLBSD_SOURCE  // UseLargePages is not yet supported on BSD.
3019       FLAG_SET_DEFAULT(UseLargePages, true);
3020 #endif
3021 
3022       // Increase some data structure sizes for efficiency
3023       FLAG_SET_CMDLINE(uintx, BaseFootPrintEstimate, MaxHeapSize);
3024       FLAG_SET_CMDLINE(bool, ResizeTLAB, false);
3025       FLAG_SET_CMDLINE(uintx, TLABSize, 256*K);
3026 
3027       // See the OldPLABSize comment below, but replace 'after promotion'
3028       // with 'after copying'.  YoungPLABSize is the size of the survivor
3029       // space per-gc-thread buffers.  The default is 4kw.
3030       FLAG_SET_CMDLINE(uintx, YoungPLABSize, 256*K);      // Note: this is in words
3031 
3032       // OldPLABSize is the size of the buffers in the old gen that
3033       // UseParallelGC uses to promote live data that doesn't fit in the
3034       // survivor spaces.  At any given time, there's one for each gc thread.
3035       // The default size is 1kw. These buffers are rarely used, since the
3036       // survivor spaces are usually big enough.  For specjbb, however, there
3037       // are occasions when there's lots of live data in the young gen
3038       // and we end up promoting some of it.  We don't have a definite
3039       // explanation for why bumping OldPLABSize helps, but the theory
3040       // is that a bigger PLAB results in retaining something like the
3041       // original allocation order after promotion, which improves mutator
3042       // locality.  A minor effect may be that larger PLABs reduce the
3043       // number of PLAB allocation events during gc.  The value of 8kw
3044       // was arrived at by experimenting with specjbb.
3045       FLAG_SET_CMDLINE(uintx, OldPLABSize, 8*K);  // Note: this is in words
3046 
3047       // Enable parallel GC and adaptive generation sizing
3048       FLAG_SET_CMDLINE(bool, UseParallelGC, true);
3049       FLAG_SET_DEFAULT(ParallelGCThreads,
3050                        Abstract_VM_Version::parallel_worker_threads());
3051 
3052       // Encourage steady state memory management
3053       FLAG_SET_CMDLINE(uintx, ThresholdTolerance, 100);
3054 
3055       // This appears to improve mutator locality
3056       FLAG_SET_CMDLINE(bool, ScavengeBeforeFullGC, false);
3057 
3058       // Get around early Solaris scheduling bug
3059       // (affinity vs other jobs on system)
3060       // but disallow DR and offlining (5008695).
3061       FLAG_SET_CMDLINE(bool, BindGCTaskThreadsToCPUs, true);
3062 
3063     // Need to keep consistency of MaxTenuringThreshold and AlwaysTenure/NeverTenure;
3064     // and the last option wins.
3065     } else if (match_option(option, "-XX:+NeverTenure", &amp;tail)) {
3066       FLAG_SET_CMDLINE(bool, NeverTenure, true);
3067       FLAG_SET_CMDLINE(bool, AlwaysTenure, false);
3068       FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, markOopDesc::max_age + 1);
3069     } else if (match_option(option, "-XX:+AlwaysTenure", &amp;tail)) {
3070       FLAG_SET_CMDLINE(bool, NeverTenure, false);
3071       FLAG_SET_CMDLINE(bool, AlwaysTenure, true);
3072       FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, 0);
3073     } else if (match_option(option, "-XX:MaxTenuringThreshold=", &amp;tail)) {
3074       uintx max_tenuring_thresh = 0;
3075       if(!parse_uintx(tail, &amp;max_tenuring_thresh, 0)) {
3076         jio_fprintf(defaultStream::error_stream(),
3077                     "Invalid MaxTenuringThreshold: %s\n", option-&gt;optionString);
3078       }
3079       FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, max_tenuring_thresh);
3080 
3081       if (MaxTenuringThreshold == 0) {
3082         FLAG_SET_CMDLINE(bool, NeverTenure, false);
3083         FLAG_SET_CMDLINE(bool, AlwaysTenure, true);
3084       } else {
3085         FLAG_SET_CMDLINE(bool, NeverTenure, false);
3086         FLAG_SET_CMDLINE(bool, AlwaysTenure, false);
3087       }
3088     } else if (match_option(option, "-XX:+CMSPermGenSweepingEnabled", &amp;tail) ||
3089                match_option(option, "-XX:-CMSPermGenSweepingEnabled", &amp;tail)) {
3090       jio_fprintf(defaultStream::error_stream(),
3091         "Please use CMSClassUnloadingEnabled in place of "
3092         "CMSPermGenSweepingEnabled in the future\n");
3093     } else if (match_option(option, "-XX:+UseGCTimeLimit", &amp;tail)) {
3094       FLAG_SET_CMDLINE(bool, UseGCOverheadLimit, true);
3095       jio_fprintf(defaultStream::error_stream(),
3096         "Please use -XX:+UseGCOverheadLimit in place of "
3097         "-XX:+UseGCTimeLimit in the future\n");
3098     } else if (match_option(option, "-XX:-UseGCTimeLimit", &amp;tail)) {
3099       FLAG_SET_CMDLINE(bool, UseGCOverheadLimit, false);
3100       jio_fprintf(defaultStream::error_stream(),
3101         "Please use -XX:-UseGCOverheadLimit in place of "
3102         "-XX:-UseGCTimeLimit in the future\n");
3103     // The TLE options are for compatibility with 1.3 and will be
3104     // removed without notice in a future release.  These options
3105     // are not to be documented.
3106     } else if (match_option(option, "-XX:MaxTLERatio=", &amp;tail)) {
3107       // No longer used.
3108     } else if (match_option(option, "-XX:+ResizeTLE", &amp;tail)) {
3109       FLAG_SET_CMDLINE(bool, ResizeTLAB, true);
3110     } else if (match_option(option, "-XX:-ResizeTLE", &amp;tail)) {
3111       FLAG_SET_CMDLINE(bool, ResizeTLAB, false);
3112     } else if (match_option(option, "-XX:+PrintTLE", &amp;tail)) {
3113       FLAG_SET_CMDLINE(bool, PrintTLAB, true);
3114     } else if (match_option(option, "-XX:-PrintTLE", &amp;tail)) {
3115       FLAG_SET_CMDLINE(bool, PrintTLAB, false);
3116     } else if (match_option(option, "-XX:TLEFragmentationRatio=", &amp;tail)) {
3117       // No longer used.
3118     } else if (match_option(option, "-XX:TLESize=", &amp;tail)) {
3119       julong long_tlab_size = 0;
3120       ArgsRange errcode = parse_memory_size(tail, &amp;long_tlab_size, 1);
3121       if (errcode != arg_in_range) {
3122         jio_fprintf(defaultStream::error_stream(),
3123                     "Invalid TLAB size: %s\n", option-&gt;optionString);
3124         describe_range_error(errcode);
3125         return JNI_EINVAL;
3126       }
3127       FLAG_SET_CMDLINE(uintx, TLABSize, long_tlab_size);
3128     } else if (match_option(option, "-XX:TLEThreadRatio=", &amp;tail)) {
3129       // No longer used.
3130     } else if (match_option(option, "-XX:+UseTLE", &amp;tail)) {
3131       FLAG_SET_CMDLINE(bool, UseTLAB, true);
3132     } else if (match_option(option, "-XX:-UseTLE", &amp;tail)) {
3133       FLAG_SET_CMDLINE(bool, UseTLAB, false);
3134     } else if (match_option(option, "-XX:+DisplayVMOutputToStderr", &amp;tail)) {
3135       FLAG_SET_CMDLINE(bool, DisplayVMOutputToStdout, false);
3136       FLAG_SET_CMDLINE(bool, DisplayVMOutputToStderr, true);
3137     } else if (match_option(option, "-XX:+DisplayVMOutputToStdout", &amp;tail)) {
3138       FLAG_SET_CMDLINE(bool, DisplayVMOutputToStderr, false);
3139       FLAG_SET_CMDLINE(bool, DisplayVMOutputToStdout, true);
3140     } else if (match_option(option, "-XX:+ExtendedDTraceProbes", &amp;tail)) {
3141 #if defined(DTRACE_ENABLED)
3142       FLAG_SET_CMDLINE(bool, ExtendedDTraceProbes, true);
3143       FLAG_SET_CMDLINE(bool, DTraceMethodProbes, true);
3144       FLAG_SET_CMDLINE(bool, DTraceAllocProbes, true);
3145       FLAG_SET_CMDLINE(bool, DTraceMonitorProbes, true);
3146 #else // defined(DTRACE_ENABLED)
3147       jio_fprintf(defaultStream::error_stream(),
3148                   "ExtendedDTraceProbes flag is not applicable for this configuration\n");
3149       return JNI_EINVAL;
3150 #endif // defined(DTRACE_ENABLED)
3151 #ifdef ASSERT
3152     } else if (match_option(option, "-XX:+FullGCALot", &amp;tail)) {
3153       FLAG_SET_CMDLINE(bool, FullGCALot, true);
3154       // disable scavenge before parallel mark-compact
3155       FLAG_SET_CMDLINE(bool, ScavengeBeforeFullGC, false);
3156 #endif
3157     } else if (match_option(option, "-XX:CMSParPromoteBlocksToClaim=", &amp;tail)) {
3158       julong cms_blocks_to_claim = (julong)atol(tail);
3159       FLAG_SET_CMDLINE(uintx, CMSParPromoteBlocksToClaim, cms_blocks_to_claim);
3160       jio_fprintf(defaultStream::error_stream(),
3161         "Please use -XX:OldPLABSize in place of "
3162         "-XX:CMSParPromoteBlocksToClaim in the future\n");
3163     } else if (match_option(option, "-XX:ParCMSPromoteBlocksToClaim=", &amp;tail)) {
3164       julong cms_blocks_to_claim = (julong)atol(tail);
3165       FLAG_SET_CMDLINE(uintx, CMSParPromoteBlocksToClaim, cms_blocks_to_claim);
3166       jio_fprintf(defaultStream::error_stream(),
3167         "Please use -XX:OldPLABSize in place of "
3168         "-XX:ParCMSPromoteBlocksToClaim in the future\n");
3169     } else if (match_option(option, "-XX:ParallelGCOldGenAllocBufferSize=", &amp;tail)) {
3170       julong old_plab_size = 0;
3171       ArgsRange errcode = parse_memory_size(tail, &amp;old_plab_size, 1);
3172       if (errcode != arg_in_range) {
3173         jio_fprintf(defaultStream::error_stream(),
3174                     "Invalid old PLAB size: %s\n", option-&gt;optionString);
3175         describe_range_error(errcode);
3176         return JNI_EINVAL;
3177       }
3178       FLAG_SET_CMDLINE(uintx, OldPLABSize, old_plab_size);
3179       jio_fprintf(defaultStream::error_stream(),
3180                   "Please use -XX:OldPLABSize in place of "
3181                   "-XX:ParallelGCOldGenAllocBufferSize in the future\n");
3182     } else if (match_option(option, "-XX:ParallelGCToSpaceAllocBufferSize=", &amp;tail)) {
3183       julong young_plab_size = 0;
3184       ArgsRange errcode = parse_memory_size(tail, &amp;young_plab_size, 1);
3185       if (errcode != arg_in_range) {
3186         jio_fprintf(defaultStream::error_stream(),
3187                     "Invalid young PLAB size: %s\n", option-&gt;optionString);
3188         describe_range_error(errcode);
3189         return JNI_EINVAL;
3190       }
3191       FLAG_SET_CMDLINE(uintx, YoungPLABSize, young_plab_size);
3192       jio_fprintf(defaultStream::error_stream(),
3193                   "Please use -XX:YoungPLABSize in place of "
3194                   "-XX:ParallelGCToSpaceAllocBufferSize in the future\n");
3195     } else if (match_option(option, "-XX:CMSMarkStackSize=", &amp;tail) ||
3196                match_option(option, "-XX:G1MarkStackSize=", &amp;tail)) {
3197       julong stack_size = 0;
3198       ArgsRange errcode = parse_memory_size(tail, &amp;stack_size, 1);
3199       if (errcode != arg_in_range) {
3200         jio_fprintf(defaultStream::error_stream(),
3201                     "Invalid mark stack size: %s\n", option-&gt;optionString);
3202         describe_range_error(errcode);
3203         return JNI_EINVAL;
3204       }
3205       FLAG_SET_CMDLINE(uintx, MarkStackSize, stack_size);
3206     } else if (match_option(option, "-XX:CMSMarkStackSizeMax=", &amp;tail)) {
3207       julong max_stack_size = 0;
3208       ArgsRange errcode = parse_memory_size(tail, &amp;max_stack_size, 1);
3209       if (errcode != arg_in_range) {
3210         jio_fprintf(defaultStream::error_stream(),
3211                     "Invalid maximum mark stack size: %s\n",
3212                     option-&gt;optionString);
3213         describe_range_error(errcode);
3214         return JNI_EINVAL;
3215       }
3216       FLAG_SET_CMDLINE(uintx, MarkStackSizeMax, max_stack_size);
3217     } else if (match_option(option, "-XX:ParallelMarkingThreads=", &amp;tail) ||
3218                match_option(option, "-XX:ParallelCMSThreads=", &amp;tail)) {
3219       uintx conc_threads = 0;
3220       if (!parse_uintx(tail, &amp;conc_threads, 1)) {
3221         jio_fprintf(defaultStream::error_stream(),
3222                     "Invalid concurrent threads: %s\n", option-&gt;optionString);
3223         return JNI_EINVAL;
3224       }
3225       FLAG_SET_CMDLINE(uintx, ConcGCThreads, conc_threads);
3226     } else if (match_option(option, "-XX:MaxDirectMemorySize=", &amp;tail)) {
3227       julong max_direct_memory_size = 0;
3228       ArgsRange errcode = parse_memory_size(tail, &amp;max_direct_memory_size, 0);
3229       if (errcode != arg_in_range) {
3230         jio_fprintf(defaultStream::error_stream(),
3231                     "Invalid maximum direct memory size: %s\n",
3232                     option-&gt;optionString);
3233         describe_range_error(errcode);
3234         return JNI_EINVAL;
3235       }
3236       FLAG_SET_CMDLINE(uintx, MaxDirectMemorySize, max_direct_memory_size);
3237 #if !INCLUDE_MANAGEMENT
3238     } else if (match_option(option, "-XX:+ManagementServer", &amp;tail)) {
3239         jio_fprintf(defaultStream::error_stream(),
3240           "ManagementServer is not supported in this VM.\n");
3241         return JNI_ERR;
3242 #endif // INCLUDE_MANAGEMENT
3243     } else if (match_option(option, "-XX:", &amp;tail)) { // -XX:xxxx
3244       // Skip -XX:Flags= since that case has already been handled
3245       if (strncmp(tail, "Flags=", strlen("Flags=")) != 0) {
3246         if (!process_argument(tail, args-&gt;ignoreUnrecognized, origin)) {
3247           return JNI_EINVAL;
3248         }
3249       }
3250     // Unknown option
3251     } else if (is_bad_option(option, args-&gt;ignoreUnrecognized)) {
3252       return JNI_ERR;
3253     }
3254   }
3255 
3256   // Change the default value for flags  which have different default values
3257   // when working with older JDKs.
3258 #ifdef LINUX
3259  if (JDK_Version::current().compare_major(6) &lt;= 0 &amp;&amp;
3260       FLAG_IS_DEFAULT(UseLinuxPosixThreadCPUClocks)) {
3261     FLAG_SET_DEFAULT(UseLinuxPosixThreadCPUClocks, false);
3262   }
3263 #endif // LINUX
3264   return JNI_OK;
3265 }
3266 
3267 jint Arguments::finalize_vm_init_args(SysClassPath* scp_p, bool scp_assembly_required) {
3268   // This must be done after all -D arguments have been processed.
3269   scp_p-&gt;expand_endorsed();
3270 
3271   if (scp_assembly_required || scp_p-&gt;get_endorsed() != NULL) {
3272     // Assemble the bootclasspath elements into the final path.
3273     Arguments::set_sysclasspath(scp_p-&gt;combined_path());
3274   }
3275 
3276   // This must be done after all arguments have been processed.
3277   // java_compiler() true means set to "NONE" or empty.
3278   if (java_compiler() &amp;&amp; !xdebug_mode()) {
3279     // For backwards compatibility, we switch to interpreted mode if
3280     // -Djava.compiler="NONE" or "" is specified AND "-Xdebug" was
3281     // not specified.
3282     set_mode_flags(_int);
3283   }
3284   if (CompileThreshold == 0) {
3285     set_mode_flags(_int);
3286   }
3287 
3288   // eventually fix up InitialTenuringThreshold if only MaxTenuringThreshold is set
3289   if (FLAG_IS_DEFAULT(InitialTenuringThreshold) &amp;&amp; (InitialTenuringThreshold &gt; MaxTenuringThreshold)) {
3290     FLAG_SET_ERGO(uintx, InitialTenuringThreshold, MaxTenuringThreshold);
3291   }
3292 
3293 #ifndef COMPILER2
3294   // Don't degrade server performance for footprint
3295   if (FLAG_IS_DEFAULT(UseLargePages) &amp;&amp;
3296       MaxHeapSize &lt; LargePageHeapSizeThreshold) {
3297     // No need for large granularity pages w/small heaps.
3298     // Note that large pages are enabled/disabled for both the
3299     // Java heap and the code cache.
3300     FLAG_SET_DEFAULT(UseLargePages, false);
3301   }
3302 
3303 #else
3304   if (!FLAG_IS_DEFAULT(OptoLoopAlignment) &amp;&amp; FLAG_IS_DEFAULT(MaxLoopPad)) {
3305     FLAG_SET_DEFAULT(MaxLoopPad, OptoLoopAlignment-1);
3306   }
3307 #endif
3308 
3309 #ifndef TIERED
3310   // Tiered compilation is undefined.
3311   UNSUPPORTED_OPTION(TieredCompilation, "TieredCompilation");
3312 #endif
3313 
3314   // If we are running in a headless jre, force java.awt.headless property
3315   // to be true unless the property has already been set.
3316   // Also allow the OS environment variable JAVA_AWT_HEADLESS to set headless state.
3317   if (os::is_headless_jre()) {
3318     const char* headless = Arguments::get_property("java.awt.headless");
3319     if (headless == NULL) {
3320       char envbuffer[128];
3321       if (!os::getenv("JAVA_AWT_HEADLESS", envbuffer, sizeof(envbuffer))) {
3322         if (!add_property("java.awt.headless=true")) {
3323           return JNI_ENOMEM;
3324         }
3325       } else {
3326         char buffer[256];
3327         strcpy(buffer, "java.awt.headless=");
3328         strcat(buffer, envbuffer);
3329         if (!add_property(buffer)) {
3330           return JNI_ENOMEM;
3331         }
3332       }
3333     }
3334   }
3335 
3336   if (!check_vm_args_consistency()) {
3337     return JNI_ERR;
3338   }
3339 
3340   return JNI_OK;
3341 }
3342 
3343 jint Arguments::parse_java_options_environment_variable(SysClassPath* scp_p, bool* scp_assembly_required_p) {
3344   return parse_options_environment_variable("_JAVA_OPTIONS", scp_p,
3345                                             scp_assembly_required_p);
3346 }
3347 
3348 jint Arguments::parse_java_tool_options_environment_variable(SysClassPath* scp_p, bool* scp_assembly_required_p) {
3349   return parse_options_environment_variable("JAVA_TOOL_OPTIONS", scp_p,
3350                                             scp_assembly_required_p);
3351 }
3352 
3353 jint Arguments::parse_options_environment_variable(const char* name, SysClassPath* scp_p, bool* scp_assembly_required_p) {
3354   const int N_MAX_OPTIONS = 64;
3355   const int OPTION_BUFFER_SIZE = 1024;
3356   char buffer[OPTION_BUFFER_SIZE];
3357 
3358   // The variable will be ignored if it exceeds the length of the buffer.
3359   // Don't check this variable if user has special privileges
3360   // (e.g. unix su command).
3361   if (os::getenv(name, buffer, sizeof(buffer)) &amp;&amp;
3362       !os::have_special_privileges()) {
3363     JavaVMOption options[N_MAX_OPTIONS];      // Construct option array
3364     jio_fprintf(defaultStream::error_stream(),
3365                 "Picked up %s: %s\n", name, buffer);
3366     char* rd = buffer;                        // pointer to the input string (rd)
3367     int i;
3368     for (i = 0; i &lt; N_MAX_OPTIONS;) {         // repeat for all options in the input string
3369       while (isspace(*rd)) rd++;              // skip whitespace
3370       if (*rd == 0) break;                    // we re done when the input string is read completely
3371 
3372       // The output, option string, overwrites the input string.
3373       // Because of quoting, the pointer to the option string (wrt) may lag the pointer to
3374       // input string (rd).
3375       char* wrt = rd;
3376 
3377       options[i++].optionString = wrt;        // Fill in option
3378       while (*rd != 0 &amp;&amp; !isspace(*rd)) {     // unquoted strings terminate with a space or NULL
3379         if (*rd == '\'' || *rd == '"') {      // handle a quoted string
3380           int quote = *rd;                    // matching quote to look for
3381           rd++;                               // don't copy open quote
3382           while (*rd != quote) {              // include everything (even spaces) up until quote
3383             if (*rd == 0) {                   // string termination means unmatched string
3384               jio_fprintf(defaultStream::error_stream(),
3385                           "Unmatched quote in %s\n", name);
3386               return JNI_ERR;
3387             }
3388             *wrt++ = *rd++;                   // copy to option string
3389           }
3390           rd++;                               // don't copy close quote
3391         } else {
3392           *wrt++ = *rd++;                     // copy to option string
3393         }
3394       }
3395       // Need to check if we're done before writing a NULL,
3396       // because the write could be to the byte that rd is pointing to.
3397       if (*rd++ == 0) {
3398         *wrt = 0;
3399         break;
3400       }
3401       *wrt = 0;                               // Zero terminate option
3402     }
3403     // Construct JavaVMInitArgs structure and parse as if it was part of the command line
3404     JavaVMInitArgs vm_args;
3405     vm_args.version = JNI_VERSION_1_2;
3406     vm_args.options = options;
3407     vm_args.nOptions = i;
3408     vm_args.ignoreUnrecognized = IgnoreUnrecognizedVMOptions;
3409 
3410     if (PrintVMOptions) {
3411       const char* tail;
3412       for (int i = 0; i &lt; vm_args.nOptions; i++) {
3413         const JavaVMOption *option = vm_args.options + i;
3414         if (match_option(option, "-XX:", &amp;tail)) {
3415           logOption(tail);
3416         }
3417       }
3418     }
3419 
3420     return(parse_each_vm_init_arg(&amp;vm_args, scp_p, scp_assembly_required_p, Flag::ENVIRON_VAR));
3421   }
3422   return JNI_OK;
3423 }
3424 
3425 void Arguments::set_shared_spaces_flags() {
3426   if (DumpSharedSpaces) {
3427     if (RequireSharedSpaces) {
3428       warning("cannot dump shared archive while using shared archive");
3429     }
3430     UseSharedSpaces = false;
3431 #ifdef _LP64
3432     if (!UseCompressedOops || !UseCompressedClassPointers) {
3433       vm_exit_during_initialization(
3434         "Cannot dump shared archive when UseCompressedOops or UseCompressedClassPointers is off.", NULL);
3435     }
3436   } else {
3437     // UseCompressedOops and UseCompressedClassPointers must be on for UseSharedSpaces.
3438     if (!UseCompressedOops || !UseCompressedClassPointers) {
3439       no_shared_spaces();
3440     }
3441 #endif
3442   }
3443 }
3444 
3445 #if !INCLUDE_ALL_GCS
3446 static void force_serial_gc() {
3447   FLAG_SET_DEFAULT(UseSerialGC, true);
3448   FLAG_SET_DEFAULT(CMSIncrementalMode, false);  // special CMS suboption
3449   UNSUPPORTED_GC_OPTION(UseG1GC);
3450   UNSUPPORTED_GC_OPTION(UseParallelGC);
3451   UNSUPPORTED_GC_OPTION(UseParallelOldGC);
3452   UNSUPPORTED_GC_OPTION(UseConcMarkSweepGC);
3453   UNSUPPORTED_GC_OPTION(UseParNewGC);
3454 }
3455 #endif // INCLUDE_ALL_GCS
3456 
3457 // Sharing support
3458 // Construct the path to the archive
3459 static char* get_shared_archive_path() {
3460   char *shared_archive_path;
3461   if (SharedArchiveFile == NULL) {
3462     char jvm_path[JVM_MAXPATHLEN];
3463     os::jvm_path(jvm_path, sizeof(jvm_path));
3464     char *end = strrchr(jvm_path, *os::file_separator());
3465     if (end != NULL) *end = '\0';
3466     size_t jvm_path_len = strlen(jvm_path);
3467     size_t file_sep_len = strlen(os::file_separator());
3468     shared_archive_path = NEW_C_HEAP_ARRAY(char, jvm_path_len +
3469         file_sep_len + 20, mtInternal);
3470     if (shared_archive_path != NULL) {
3471       strncpy(shared_archive_path, jvm_path, jvm_path_len + 1);
3472       strncat(shared_archive_path, os::file_separator(), file_sep_len);
3473       strncat(shared_archive_path, "classes.jsa", 11);
3474     }
3475   } else {
3476     shared_archive_path = NEW_C_HEAP_ARRAY(char, strlen(SharedArchiveFile) + 1, mtInternal);
3477     if (shared_archive_path != NULL) {
3478       strncpy(shared_archive_path, SharedArchiveFile, strlen(SharedArchiveFile) + 1);
3479     }
3480   }
3481   return shared_archive_path;
3482 }
3483 
3484 #ifndef PRODUCT
3485 // Determine whether LogVMOutput should be implicitly turned on.
3486 static bool use_vm_log() {
3487   if (LogCompilation || !FLAG_IS_DEFAULT(LogFile) ||
3488       PrintCompilation || PrintInlining || PrintDependencies || PrintNativeNMethods ||
3489       PrintDebugInfo || PrintRelocations || PrintNMethods || PrintExceptionHandlers ||
3490       PrintAssembly || TraceDeoptimization || TraceDependencies ||
3491       (VerifyDependencies &amp;&amp; FLAG_IS_CMDLINE(VerifyDependencies))) {
3492     return true;
3493   }
3494 
3495 #ifdef COMPILER1
3496   if (PrintC1Statistics) {
3497     return true;
3498   }
3499 #endif // COMPILER1
3500 
3501 #ifdef COMPILER2
3502   if (PrintOptoAssembly || PrintOptoStatistics) {
3503     return true;
3504   }
3505 #endif // COMPILER2
3506 
3507   return false;
3508 }
3509 #endif // PRODUCT
3510 
3511 // Parse entry point called from JNI_CreateJavaVM
3512 
3513 jint Arguments::parse(const JavaVMInitArgs* args) {
3514 
3515   // Remaining part of option string
3516   const char* tail;
3517 
3518   // If flag "-XX:Flags=flags-file" is used it will be the first option to be processed.
3519   const char* hotspotrc = ".hotspotrc";
3520   bool settings_file_specified = false;
3521   bool needs_hotspotrc_warning = false;
3522 
3523   const char* flags_file;
3524   int index;
3525   for (index = 0; index &lt; args-&gt;nOptions; index++) {
3526     const JavaVMOption *option = args-&gt;options + index;
3527     if (match_option(option, "-XX:Flags=", &amp;tail)) {
3528       flags_file = tail;
3529       settings_file_specified = true;
3530     }
3531     if (match_option(option, "-XX:+PrintVMOptions", &amp;tail)) {
3532       PrintVMOptions = true;
3533     }
3534     if (match_option(option, "-XX:-PrintVMOptions", &amp;tail)) {
3535       PrintVMOptions = false;
3536     }
3537     if (match_option(option, "-XX:+IgnoreUnrecognizedVMOptions", &amp;tail)) {
3538       IgnoreUnrecognizedVMOptions = true;
3539     }
3540     if (match_option(option, "-XX:-IgnoreUnrecognizedVMOptions", &amp;tail)) {
3541       IgnoreUnrecognizedVMOptions = false;
3542     }
3543     if (match_option(option, "-XX:+PrintFlagsInitial", &amp;tail)) {
3544       CommandLineFlags::printFlags(tty, false);
3545       vm_exit(0);
3546     }
3547     if (match_option(option, "-XX:NativeMemoryTracking", &amp;tail)) {
3548 #if INCLUDE_NMT
3549       MemTracker::init_tracking_options(tail);
3550 #else
3551       jio_fprintf(defaultStream::error_stream(),
3552         "Native Memory Tracking is not supported in this VM\n");
3553       return JNI_ERR;
3554 #endif
3555     }
3556 
3557 
3558 #ifndef PRODUCT
3559     if (match_option(option, "-XX:+PrintFlagsWithComments", &amp;tail)) {
3560       CommandLineFlags::printFlags(tty, true);
3561       vm_exit(0);
3562     }
3563 #endif
3564   }
3565 
3566   if (IgnoreUnrecognizedVMOptions) {
3567     // uncast const to modify the flag args-&gt;ignoreUnrecognized
3568     *(jboolean*)(&amp;args-&gt;ignoreUnrecognized) = true;
3569   }
3570 
3571   // Parse specified settings file
3572   if (settings_file_specified) {
3573     if (!process_settings_file(flags_file, true, args-&gt;ignoreUnrecognized)) {
3574       return JNI_EINVAL;
3575     }
3576   } else {
3577 #ifdef ASSERT
3578     // Parse default .hotspotrc settings file
3579     if (!process_settings_file(".hotspotrc", false, args-&gt;ignoreUnrecognized)) {
3580       return JNI_EINVAL;
3581     }
3582 #else
3583     struct stat buf;
3584     if (os::stat(hotspotrc, &amp;buf) == 0) {
3585       needs_hotspotrc_warning = true;
3586     }
3587 #endif
3588   }
3589 
3590   if (PrintVMOptions) {
3591     for (index = 0; index &lt; args-&gt;nOptions; index++) {
3592       const JavaVMOption *option = args-&gt;options + index;
3593       if (match_option(option, "-XX:", &amp;tail)) {
3594         logOption(tail);
3595       }
3596     }
3597   }
3598 
3599   // Parse JavaVMInitArgs structure passed in, as well as JAVA_TOOL_OPTIONS and _JAVA_OPTIONS
3600   jint result = parse_vm_init_args(args);
3601   if (result != JNI_OK) {
3602     return result;
3603   }
3604 
3605   // Call get_shared_archive_path() here, after possible SharedArchiveFile option got parsed.
3606   SharedArchivePath = get_shared_archive_path();
3607   if (SharedArchivePath == NULL) {
3608     return JNI_ENOMEM;
3609   }
3610 
3611   // Delay warning until here so that we've had a chance to process
3612   // the -XX:-PrintWarnings flag
3613   if (needs_hotspotrc_warning) {
3614     warning("%s file is present but has been ignored.  "
3615             "Run with -XX:Flags=%s to load the file.",
3616             hotspotrc, hotspotrc);
3617   }
3618 
3619 #ifdef _ALLBSD_SOURCE  // UseLargePages is not yet supported on BSD.
3620   UNSUPPORTED_OPTION(UseLargePages, "-XX:+UseLargePages");
3621 #endif
3622 
3623 #if INCLUDE_ALL_GCS
3624   #if (defined JAVASE_EMBEDDED || defined ARM)
3625     UNSUPPORTED_OPTION(UseG1GC, "G1 GC");
3626   #endif
3627 #endif
3628 
3629 #ifndef PRODUCT
3630   if (TraceBytecodesAt != 0) {
3631     TraceBytecodes = true;
3632   }
3633   if (CountCompiledCalls) {
3634     if (UseCounterDecay) {
3635       warning("UseCounterDecay disabled because CountCalls is set");
3636       UseCounterDecay = false;
3637     }
3638   }
3639 #endif // PRODUCT
3640 
3641   // JSR 292 is not supported before 1.7
3642   if (!JDK_Version::is_gte_jdk17x_version()) {
3643     if (EnableInvokeDynamic) {
3644       if (!FLAG_IS_DEFAULT(EnableInvokeDynamic)) {
3645         warning("JSR 292 is not supported before 1.7.  Disabling support.");
3646       }
3647       EnableInvokeDynamic = false;
3648     }
3649   }
3650 
3651   if (EnableInvokeDynamic &amp;&amp; ScavengeRootsInCode == 0) {
3652     if (!FLAG_IS_DEFAULT(ScavengeRootsInCode)) {
3653       warning("forcing ScavengeRootsInCode non-zero because EnableInvokeDynamic is true");
3654     }
3655     ScavengeRootsInCode = 1;
3656   }
3657 
3658   if (PrintGCDetails) {
3659     // Turn on -verbose:gc options as well
3660     PrintGC = true;
3661   }
3662 
3663   if (!JDK_Version::is_gte_jdk18x_version()) {
3664     // To avoid changing the log format for 7 updates this flag is only
3665     // true by default in JDK8 and above.
3666     if (FLAG_IS_DEFAULT(PrintGCCause)) {
3667       FLAG_SET_DEFAULT(PrintGCCause, false);
3668     }
3669   }
3670 
3671   // Set object alignment values.
3672   set_object_alignment();
3673 
3674 #if !INCLUDE_ALL_GCS
3675   force_serial_gc();
3676 #endif // INCLUDE_ALL_GCS
3677 #if !INCLUDE_CDS
3678   if (DumpSharedSpaces || RequireSharedSpaces) {
3679     jio_fprintf(defaultStream::error_stream(),
3680       "Shared spaces are not supported in this VM\n");
3681     return JNI_ERR;
3682   }
3683   if ((UseSharedSpaces &amp;&amp; FLAG_IS_CMDLINE(UseSharedSpaces)) || PrintSharedSpaces) {
3684     warning("Shared spaces are not supported in this VM");
3685     FLAG_SET_DEFAULT(UseSharedSpaces, false);
3686     FLAG_SET_DEFAULT(PrintSharedSpaces, false);
3687   }
3688   no_shared_spaces();
3689 #endif // INCLUDE_CDS
3690 
3691   return JNI_OK;
3692 }
3693 
3694 jint Arguments::apply_ergo() {
3695 
3696   // Set flags based on ergonomics.
3697   set_ergonomics_flags();
3698 
3699   set_shared_spaces_flags();
3700 
3701   // Check the GC selections again.
3702   if (!check_gc_consistency()) {
3703     return JNI_EINVAL;
3704   }
3705 
3706   if (TieredCompilation) {
3707     set_tiered_flags();
3708   } else {
3709     // Check if the policy is valid. Policies 0 and 1 are valid for non-tiered setup.
3710     if (CompilationPolicyChoice &gt;= 2) {
3711       vm_exit_during_initialization(
3712         "Incompatible compilation policy selected", NULL);
3713     }
3714   }
3715   // Set NmethodSweepFraction after the size of the code cache is adapted (in case of tiered)
3716   if (FLAG_IS_DEFAULT(NmethodSweepFraction)) {
3717     FLAG_SET_DEFAULT(NmethodSweepFraction, 1 + ReservedCodeCacheSize / (16 * M));
3718   }
3719 
3720 
3721   // Set heap size based on available physical memory
3722   set_heap_size();
3723 
3724 #if INCLUDE_ALL_GCS
3725   // Set per-collector flags
3726   if (UseParallelGC || UseParallelOldGC) {
3727     set_parallel_gc_flags();
3728   } else if (UseConcMarkSweepGC) { // Should be done before ParNew check below
3729     set_cms_and_parnew_gc_flags();
3730   } else if (UseParNewGC) {  // Skipped if CMS is set above
3731     set_parnew_gc_flags();
3732   } else if (UseG1GC) {
3733     set_g1_gc_flags();
3734   }
3735   check_deprecated_gcs();
3736   check_deprecated_gc_flags();
3737   if (AssumeMP &amp;&amp; !UseSerialGC) {
3738     if (FLAG_IS_DEFAULT(ParallelGCThreads) &amp;&amp; ParallelGCThreads == 1) {
3739       warning("If the number of processors is expected to increase from one, then"
3740               " you should configure the number of parallel GC threads appropriately"
3741               " using -XX:ParallelGCThreads=N");
3742     }
3743   }
3744   if (MinHeapFreeRatio == 100) {
3745     // Keeping the heap 100% free is hard ;-) so limit it to 99%.
3746     FLAG_SET_ERGO(uintx, MinHeapFreeRatio, 99);
3747   }
3748 #else // INCLUDE_ALL_GCS
3749   assert(verify_serial_gc_flags(), "SerialGC unset");
3750 #endif // INCLUDE_ALL_GCS
3751 
3752   // Initialize Metaspace flags and alignments
3753   Metaspace::ergo_initialize();
3754 
3755   // Set bytecode rewriting flags
3756   set_bytecode_flags();
3757 
3758   // Set flags if Aggressive optimization flags (-XX:+AggressiveOpts) enabled
3759   set_aggressive_opts_flags();
3760 
3761   // Turn off biased locking for locking debug mode flags,
3762   // which are subtly different from each other but neither works with
3763   // biased locking
3764   if (UseHeavyMonitors
3765 #ifdef COMPILER1
3766       || !UseFastLocking
3767 #endif // COMPILER1
3768     ) {
3769     if (!FLAG_IS_DEFAULT(UseBiasedLocking) &amp;&amp; UseBiasedLocking) {
3770       // flag set to true on command line; warn the user that they
3771       // can't enable biased locking here
3772       warning("Biased Locking is not supported with locking debug flags"
3773               "; ignoring UseBiasedLocking flag." );
3774     }
3775     UseBiasedLocking = false;
3776   }
3777 
3778 #ifdef ZERO
3779   // Clear flags not supported on zero.
3780   FLAG_SET_DEFAULT(ProfileInterpreter, false);
3781   FLAG_SET_DEFAULT(UseBiasedLocking, false);
3782   LP64_ONLY(FLAG_SET_DEFAULT(UseCompressedOops, false));
3783   LP64_ONLY(FLAG_SET_DEFAULT(UseCompressedClassPointers, false));
3784 #endif // CC_INTERP
3785 
3786 #ifdef COMPILER2
3787   if (!EliminateLocks) {
3788     EliminateNestedLocks = false;
3789   }
3790   if (!Inline) {
3791     IncrementalInline = false;
3792   }
3793 #ifndef PRODUCT
3794   if (!IncrementalInline) {
3795     AlwaysIncrementalInline = false;
3796   }
3797 #endif
3798   if (!UseTypeSpeculation &amp;&amp; FLAG_IS_DEFAULT(TypeProfileLevel)) {
3799     // nothing to use the profiling, turn if off
3800     FLAG_SET_DEFAULT(TypeProfileLevel, 0);
3801   }
3802   if (UseTypeSpeculation &amp;&amp; FLAG_IS_DEFAULT(ReplaceInParentMaps)) {
3803     // Doing the replace in parent maps helps speculation
3804     FLAG_SET_DEFAULT(ReplaceInParentMaps, true);
3805   }
3806 #endif
3807 
3808   if (PrintAssembly &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
3809     warning("PrintAssembly is enabled; turning on DebugNonSafepoints to gain additional output");
3810     DebugNonSafepoints = true;
3811   }
3812 
3813   if (FLAG_IS_CMDLINE(CompressedClassSpaceSize) &amp;&amp; !UseCompressedClassPointers) {
3814     warning("Setting CompressedClassSpaceSize has no effect when compressed class pointers are not used");
3815   }
3816 
3817 #ifndef PRODUCT
3818   if (CompileTheWorld) {
3819     // Force NmethodSweeper to sweep whole CodeCache each time.
3820     if (FLAG_IS_DEFAULT(NmethodSweepFraction)) {
3821       NmethodSweepFraction = 1;
3822     }
3823   }
3824 
3825   if (!LogVMOutput &amp;&amp; FLAG_IS_DEFAULT(LogVMOutput)) {
3826     if (use_vm_log()) {
3827       LogVMOutput = true;
3828     }
3829   }
3830 #endif // PRODUCT
3831 
3832   if (PrintCommandLineFlags) {
3833     CommandLineFlags::printSetFlags(tty);
3834   }
3835 
3836   // Apply CPU specific policy for the BiasedLocking
3837   if (UseBiasedLocking) {
3838     if (!VM_Version::use_biased_locking() &amp;&amp;
3839         !(FLAG_IS_CMDLINE(UseBiasedLocking))) {
3840       UseBiasedLocking = false;
3841     }
3842   }
3843 #ifdef COMPILER2
3844   if (!UseBiasedLocking || EmitSync != 0) {
3845     UseOptoBiasInlining = false;
3846   }
3847 #endif
3848 
3849   return JNI_OK;
3850 }
3851 
3852 jint Arguments::adjust_after_os() {
3853   if (UseNUMA) {
3854     if (UseParallelGC || UseParallelOldGC) {
3855       if (FLAG_IS_DEFAULT(MinHeapDeltaBytes)) {
3856          FLAG_SET_DEFAULT(MinHeapDeltaBytes, 64*M);
3857       }
3858     }
3859     // UseNUMAInterleaving is set to ON for all collectors and
3860     // platforms when UseNUMA is set to ON. NUMA-aware collectors
3861     // such as the parallel collector for Linux and Solaris will
3862     // interleave old gen and survivor spaces on top of NUMA
3863     // allocation policy for the eden space.
3864     // Non NUMA-aware collectors such as CMS, G1 and Serial-GC on
3865     // all platforms and ParallelGC on Windows will interleave all
3866     // of the heap spaces across NUMA nodes.
3867     if (FLAG_IS_DEFAULT(UseNUMAInterleaving)) {
3868       FLAG_SET_ERGO(bool, UseNUMAInterleaving, true);
3869     }
3870   }
3871   return JNI_OK;
3872 }
3873 
3874 int Arguments::PropertyList_count(SystemProperty* pl) {
3875   int count = 0;
3876   while(pl != NULL) {
3877     count++;
3878     pl = pl-&gt;next();
3879   }
3880   return count;
3881 }
3882 
3883 const char* Arguments::PropertyList_get_value(SystemProperty *pl, const char* key) {
3884   assert(key != NULL, "just checking");
3885   SystemProperty* prop;
3886   for (prop = pl; prop != NULL; prop = prop-&gt;next()) {
3887     if (strcmp(key, prop-&gt;key()) == 0) return prop-&gt;value();
3888   }
3889   return NULL;
3890 }
3891 
3892 const char* Arguments::PropertyList_get_key_at(SystemProperty *pl, int index) {
3893   int count = 0;
3894   const char* ret_val = NULL;
3895 
3896   while(pl != NULL) {
3897     if(count &gt;= index) {
3898       ret_val = pl-&gt;key();
3899       break;
3900     }
3901     count++;
3902     pl = pl-&gt;next();
3903   }
3904 
3905   return ret_val;
3906 }
3907 
3908 char* Arguments::PropertyList_get_value_at(SystemProperty* pl, int index) {
3909   int count = 0;
3910   char* ret_val = NULL;
3911 
3912   while(pl != NULL) {
3913     if(count &gt;= index) {
3914       ret_val = pl-&gt;value();
3915       break;
3916     }
3917     count++;
3918     pl = pl-&gt;next();
3919   }
3920 
3921   return ret_val;
3922 }
3923 
3924 void Arguments::PropertyList_add(SystemProperty** plist, SystemProperty *new_p) {
3925   SystemProperty* p = *plist;
3926   if (p == NULL) {
3927     *plist = new_p;
3928   } else {
3929     while (p-&gt;next() != NULL) {
3930       p = p-&gt;next();
3931     }
3932     p-&gt;set_next(new_p);
3933   }
3934 }
3935 
3936 void Arguments::PropertyList_add(SystemProperty** plist, const char* k, char* v) {
3937   if (plist == NULL)
3938     return;
3939 
3940   SystemProperty* new_p = new SystemProperty(k, v, true);
3941   PropertyList_add(plist, new_p);
3942 }
3943 
3944 // This add maintains unique property key in the list.
3945 void Arguments::PropertyList_unique_add(SystemProperty** plist, const char* k, char* v, jboolean append) {
3946   if (plist == NULL)
3947     return;
3948 
3949   // If property key exist then update with new value.
3950   SystemProperty* prop;
3951   for (prop = *plist; prop != NULL; prop = prop-&gt;next()) {
3952     if (strcmp(k, prop-&gt;key()) == 0) {
3953       if (append) {
3954         prop-&gt;append_value(v);
3955       } else {
3956         prop-&gt;set_value(v);
3957       }
3958       return;
3959     }
3960   }
3961 
3962   PropertyList_add(plist, k, v);
3963 }
3964 
3965 // Copies src into buf, replacing "%%" with "%" and "%p" with pid
3966 // Returns true if all of the source pointed by src has been copied over to
3967 // the destination buffer pointed by buf. Otherwise, returns false.
3968 // Notes:
3969 // 1. If the length (buflen) of the destination buffer excluding the
3970 // NULL terminator character is not long enough for holding the expanded
3971 // pid characters, it also returns false instead of returning the partially
3972 // expanded one.
3973 // 2. The passed in "buflen" should be large enough to hold the null terminator.
3974 bool Arguments::copy_expand_pid(const char* src, size_t srclen,
3975                                 char* buf, size_t buflen) {
3976   const char* p = src;
3977   char* b = buf;
3978   const char* src_end = &amp;src[srclen];
3979   char* buf_end = &amp;buf[buflen - 1];
3980 
3981   while (p &lt; src_end &amp;&amp; b &lt; buf_end) {
3982     if (*p == '%') {
3983       switch (*(++p)) {
3984       case '%':         // "%%" ==&gt; "%"
3985         *b++ = *p++;
3986         break;
3987       case 'p':  {       //  "%p" ==&gt; current process id
3988         // buf_end points to the character before the last character so
3989         // that we could write '\0' to the end of the buffer.
3990         size_t buf_sz = buf_end - b + 1;
3991         int ret = jio_snprintf(b, buf_sz, "%d", os::current_process_id());
3992 
3993         // if jio_snprintf fails or the buffer is not long enough to hold
3994         // the expanded pid, returns false.
3995         if (ret &lt; 0 || ret &gt;= (int)buf_sz) {
3996           return false;
3997         } else {
3998           b += ret;
3999           assert(*b == '\0', "fail in copy_expand_pid");
4000           if (p == src_end &amp;&amp; b == buf_end + 1) {
4001             // reach the end of the buffer.
4002             return true;
4003           }
4004         }
4005         p++;
4006         break;
4007       }
4008       default :
4009         *b++ = '%';
4010       }
4011     } else {
4012       *b++ = *p++;
4013     }
4014   }
4015   *b = '\0';
4016   return (p == src_end); // return false if not all of the source was copied
4017 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
