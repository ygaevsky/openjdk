<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 #include "classfile/javaClasses.hpp"
  27 #include "classfile/symbolTable.hpp"
  28 #include "classfile/systemDictionary.hpp"
  29 #include "classfile/verifier.hpp"
  30 #include "classfile/vmSymbols.hpp"
  31 #include "interpreter/linkResolver.hpp"
  32 #include "memory/oopFactory.hpp"
  33 #include "memory/resourceArea.hpp"
  34 #include "memory/universe.inline.hpp"
  35 #include "oops/instanceKlass.hpp"
  36 #include "oops/objArrayKlass.hpp"
  37 #include "oops/objArrayOop.hpp"
  38 #include "prims/jvm.h"
  39 #include "prims/jvmtiExport.hpp"
  40 #include "runtime/arguments.hpp"
  41 #include "runtime/handles.inline.hpp"
  42 #include "runtime/javaCalls.hpp"
  43 #include "runtime/reflection.hpp"
  44 #include "runtime/reflectionUtils.hpp"
  45 #include "runtime/signature.hpp"
  46 #include "runtime/vframe.hpp"
  47 
  48 static void trace_class_resolution(Klass* to_class) {
  49   ResourceMark rm;
  50   int line_number = -1;
  51   const char * source_file = NULL;
  52   Klass* caller = NULL;
  53   JavaThread* jthread = JavaThread::current();
  54   if (jthread-&gt;has_last_Java_frame()) {
  55     vframeStream vfst(jthread);
  56     // skip over any frames belonging to java.lang.Class
  57     while (!vfst.at_end() &amp;&amp;
  58            vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class()) {
  59       vfst.next();
  60     }
  61     if (!vfst.at_end()) {
  62       // this frame is a likely suspect
  63       caller = vfst.method()-&gt;method_holder();
  64       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
  65       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
  66       if (s != NULL) {
  67         source_file = s-&gt;as_C_string();
  68       }
  69     }
  70   }
  71   if (caller != NULL) {
  72     const char * from = caller-&gt;external_name();
  73     const char * to = to_class-&gt;external_name();
  74     // print in a single call to reduce interleaving between threads
  75     if (source_file != NULL) {
  76       tty-&gt;print("RESOLVE %s %s %s:%d (reflection)\n", from, to, source_file, line_number);
  77     } else {
  78       tty-&gt;print("RESOLVE %s %s (reflection)\n", from, to);
  79     }
  80   }
  81 }
  82 
  83 
  84 oop Reflection::box(jvalue* value, BasicType type, TRAPS) {
  85   if (type == T_VOID) {
  86     return NULL;
  87   }
  88   if (type == T_OBJECT || type == T_ARRAY) {
  89     // regular objects are not boxed
  90     return (oop) value-&gt;l;
  91   }
  92   oop result = java_lang_boxing_object::create(type, value, CHECK_NULL);
  93   if (result == NULL) {
  94     THROW_(vmSymbols::java_lang_IllegalArgumentException(), result);
  95   }
  96   return result;
  97 }
  98 
  99 
 100 BasicType Reflection::unbox_for_primitive(oop box, jvalue* value, TRAPS) {
 101   if (box == NULL) {
 102     THROW_(vmSymbols::java_lang_IllegalArgumentException(), T_ILLEGAL);
 103   }
 104   return java_lang_boxing_object::get_value(box, value);
 105 }
 106 
 107 BasicType Reflection::unbox_for_regular_object(oop box, jvalue* value) {
 108   // Note:  box is really the unboxed oop.  It might even be a Short, etc.!
 109   value-&gt;l = (jobject) box;
 110   return T_OBJECT;
 111 }
 112 
 113 
 114 void Reflection::widen(jvalue* value, BasicType current_type, BasicType wide_type, TRAPS) {
 115   assert(wide_type != current_type, "widen should not be called with identical types");
 116   switch (wide_type) {
 117     case T_BOOLEAN:
 118     case T_BYTE:
 119     case T_CHAR:
 120       break;  // fail
 121     case T_SHORT:
 122       switch (current_type) {
 123         case T_BYTE:
 124           value-&gt;s = (jshort) value-&gt;b;
 125           return;
 126       }
 127       break;  // fail
 128     case T_INT:
 129       switch (current_type) {
 130         case T_BYTE:
 131           value-&gt;i = (jint) value-&gt;b;
 132           return;
 133         case T_CHAR:
 134           value-&gt;i = (jint) value-&gt;c;
 135           return;
 136         case T_SHORT:
 137           value-&gt;i = (jint) value-&gt;s;
 138           return;
 139       }
 140       break;  // fail
 141     case T_LONG:
 142       switch (current_type) {
 143         case T_BYTE:
 144           value-&gt;j = (jlong) value-&gt;b;
 145           return;
 146         case T_CHAR:
 147           value-&gt;j = (jlong) value-&gt;c;
 148           return;
 149         case T_SHORT:
 150           value-&gt;j = (jlong) value-&gt;s;
 151           return;
 152         case T_INT:
 153           value-&gt;j = (jlong) value-&gt;i;
 154           return;
 155       }
 156       break;  // fail
 157     case T_FLOAT:
 158       switch (current_type) {
 159         case T_BYTE:
 160           value-&gt;f = (jfloat) value-&gt;b;
 161           return;
 162         case T_CHAR:
 163           value-&gt;f = (jfloat) value-&gt;c;
 164           return;
 165         case T_SHORT:
 166           value-&gt;f = (jfloat) value-&gt;s;
 167           return;
 168         case T_INT:
 169           value-&gt;f = (jfloat) value-&gt;i;
 170           return;
 171         case T_LONG:
 172           value-&gt;f = (jfloat) value-&gt;j;
 173           return;
 174       }
 175       break;  // fail
 176     case T_DOUBLE:
 177       switch (current_type) {
 178         case T_BYTE:
 179           value-&gt;d = (jdouble) value-&gt;b;
 180           return;
 181         case T_CHAR:
 182           value-&gt;d = (jdouble) value-&gt;c;
 183           return;
 184         case T_SHORT:
 185           value-&gt;d = (jdouble) value-&gt;s;
 186           return;
 187         case T_INT:
 188           value-&gt;d = (jdouble) value-&gt;i;
 189           return;
 190         case T_FLOAT:
 191           value-&gt;d = (jdouble) value-&gt;f;
 192           return;
 193         case T_LONG:
 194           value-&gt;d = (jdouble) value-&gt;j;
 195           return;
 196       }
 197       break;  // fail
 198     default:
 199       break;  // fail
 200   }
 201   THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), "argument type mismatch");
 202 }
 203 
 204 
 205 BasicType Reflection::array_get(jvalue* value, arrayOop a, int index, TRAPS) {
 206   if (!a-&gt;is_within_bounds(index)) {
 207     THROW_(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), T_ILLEGAL);
 208   }
 209   if (a-&gt;is_objArray()) {
 210     value-&gt;l = (jobject) objArrayOop(a)-&gt;obj_at(index);
 211     return T_OBJECT;
 212   } else {
 213     assert(a-&gt;is_typeArray(), "just checking");
 214     BasicType type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
 215     switch (type) {
 216       case T_BOOLEAN:
 217         value-&gt;z = typeArrayOop(a)-&gt;bool_at(index);
 218         break;
 219       case T_CHAR:
 220         value-&gt;c = typeArrayOop(a)-&gt;char_at(index);
 221         break;
 222       case T_FLOAT:
 223         value-&gt;f = typeArrayOop(a)-&gt;float_at(index);
 224         break;
 225       case T_DOUBLE:
 226         value-&gt;d = typeArrayOop(a)-&gt;double_at(index);
 227         break;
 228       case T_BYTE:
 229         value-&gt;b = typeArrayOop(a)-&gt;byte_at(index);
 230         break;
 231       case T_SHORT:
 232         value-&gt;s = typeArrayOop(a)-&gt;short_at(index);
 233         break;
 234       case T_INT:
 235         value-&gt;i = typeArrayOop(a)-&gt;int_at(index);
 236         break;
 237       case T_LONG:
 238         value-&gt;j = typeArrayOop(a)-&gt;long_at(index);
 239         break;
 240       default:
 241         return T_ILLEGAL;
 242     }
 243     return type;
 244   }
 245 }
 246 
 247 
 248 void Reflection::array_set(jvalue* value, arrayOop a, int index, BasicType value_type, TRAPS) {
 249   if (!a-&gt;is_within_bounds(index)) {
 250     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
 251   }
 252   if (a-&gt;is_objArray()) {
 253     if (value_type == T_OBJECT) {
 254       oop obj = (oop) value-&gt;l;
 255       if (obj != NULL) {
 256         Klass* element_klass = ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass();
 257         if (!obj-&gt;is_a(element_klass)) {
 258           THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), "array element type mismatch");
 259         }
 260       }
 261       objArrayOop(a)-&gt;obj_at_put(index, obj);
 262     }
 263   } else {
 264     assert(a-&gt;is_typeArray(), "just checking");
 265     BasicType array_type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
 266     if (array_type != value_type) {
 267       // The widen operation can potentially throw an exception, but cannot block,
 268       // so typeArrayOop a is safe if the call succeeds.
 269       widen(value, value_type, array_type, CHECK);
 270     }
 271     switch (array_type) {
 272       case T_BOOLEAN:
 273         typeArrayOop(a)-&gt;bool_at_put(index, value-&gt;z);
 274         break;
 275       case T_CHAR:
 276         typeArrayOop(a)-&gt;char_at_put(index, value-&gt;c);
 277         break;
 278       case T_FLOAT:
 279         typeArrayOop(a)-&gt;float_at_put(index, value-&gt;f);
 280         break;
 281       case T_DOUBLE:
 282         typeArrayOop(a)-&gt;double_at_put(index, value-&gt;d);
 283         break;
 284       case T_BYTE:
 285         typeArrayOop(a)-&gt;byte_at_put(index, value-&gt;b);
 286         break;
 287       case T_SHORT:
 288         typeArrayOop(a)-&gt;short_at_put(index, value-&gt;s);
 289         break;
 290       case T_INT:
 291         typeArrayOop(a)-&gt;int_at_put(index, value-&gt;i);
 292         break;
 293       case T_LONG:
 294         typeArrayOop(a)-&gt;long_at_put(index, value-&gt;j);
 295         break;
 296       default:
 297         THROW(vmSymbols::java_lang_IllegalArgumentException());
 298     }
 299   }
 300 }
 301 
 302 
 303 Klass* Reflection::basic_type_mirror_to_arrayklass(oop basic_type_mirror, TRAPS) {
 304   assert(java_lang_Class::is_primitive(basic_type_mirror), "just checking");
 305   BasicType type = java_lang_Class::primitive_type(basic_type_mirror);
 306   if (type == T_VOID) {
 307     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 308   } else {
 309     return Universe::typeArrayKlassObj(type);
 310   }
 311 }
 312 
 313 
 314 oop Reflection:: basic_type_arrayklass_to_mirror(Klass* basic_type_arrayklass, TRAPS) {
 315   BasicType type = TypeArrayKlass::cast(basic_type_arrayklass)-&gt;element_type();
 316   return Universe::java_mirror(type);
 317 }
 318 
 319 
 320 arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) {
 321   if (element_mirror == NULL) {
 322     THROW_0(vmSymbols::java_lang_NullPointerException());
 323   }
 324   if (length &lt; 0) {
 325     THROW_0(vmSymbols::java_lang_NegativeArraySizeException());
 326   }
 327   if (java_lang_Class::is_primitive(element_mirror)) {
 328     Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
 329     return TypeArrayKlass::cast(tak)-&gt;allocate(length, THREAD);
 330   } else {
 331     Klass* k = java_lang_Class::as_Klass(element_mirror);
 332     if (k-&gt;oop_is_array() &amp;&amp; ArrayKlass::cast(k)-&gt;dimension() &gt;= MAX_DIM) {
 333       THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 334     }
 335     return oopFactory::new_objArray(k, length, THREAD);
 336   }
 337 }
 338 
 339 
 340 arrayOop Reflection::reflect_new_multi_array(oop element_mirror, typeArrayOop dim_array, TRAPS) {
 341   assert(dim_array-&gt;is_typeArray(), "just checking");
 342   assert(TypeArrayKlass::cast(dim_array-&gt;klass())-&gt;element_type() == T_INT, "just checking");
 343 
 344   if (element_mirror == NULL) {
 345     THROW_0(vmSymbols::java_lang_NullPointerException());
 346   }
 347 
 348   int len = dim_array-&gt;length();
 349   if (len &lt;= 0 || len &gt; MAX_DIM) {
 350     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 351   }
 352 
 353   jint dimensions[MAX_DIM];   // C array copy of intArrayOop
 354   for (int i = 0; i &lt; len; i++) {
 355     int d = dim_array-&gt;int_at(i);
 356     if (d &lt; 0) {
 357       THROW_0(vmSymbols::java_lang_NegativeArraySizeException());
 358     }
 359     dimensions[i] = d;
 360   }
 361 
 362   Klass* klass;
 363   int dim = len;
 364   if (java_lang_Class::is_primitive(element_mirror)) {
 365     klass = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
 366   } else {
 367     klass = java_lang_Class::as_Klass(element_mirror);
 368     if (klass-&gt;oop_is_array()) {
 369       int k_dim = ArrayKlass::cast(klass)-&gt;dimension();
 370       if (k_dim + len &gt; MAX_DIM) {
 371         THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 372       }
 373       dim += k_dim;
 374     }
 375   }
 376   klass = klass-&gt;array_klass(dim, CHECK_NULL);
 377   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(len, dimensions, CHECK_NULL);
 378   assert(obj-&gt;is_array(), "just checking");
 379   return arrayOop(obj);
 380 }
 381 
 382 
 383 oop Reflection::array_component_type(oop mirror, TRAPS) {
 384   if (java_lang_Class::is_primitive(mirror)) {
 385     return NULL;
 386   }
 387 
 388   Klass* klass = java_lang_Class::as_Klass(mirror);
 389   if (!klass-&gt;oop_is_array()) {
 390     return NULL;
 391   }
 392 
 393   oop result = ArrayKlass::cast(klass)-&gt;component_mirror();
 394 #ifdef ASSERT
 395   oop result2 = NULL;
 396   if (ArrayKlass::cast(klass)-&gt;dimension() == 1) {
 397     if (klass-&gt;oop_is_typeArray()) {
 398       result2 = basic_type_arrayklass_to_mirror(klass, CHECK_NULL);
 399     } else {
 400       result2 = ObjArrayKlass::cast(klass)-&gt;element_klass()-&gt;java_mirror();
 401     }
 402   } else {
 403     Klass* lower_dim = ArrayKlass::cast(klass)-&gt;lower_dimension();
 404     assert(lower_dim-&gt;oop_is_array(), "just checking");
 405     result2 = lower_dim-&gt;java_mirror();
 406   }
 407   assert(result == result2, "results must be consistent");
 408 #endif //ASSERT
 409   return result;
 410 }
 411 
 412 
 413 bool Reflection::reflect_check_access(Klass* field_class, AccessFlags acc, Klass* target_class, bool is_method_invoke, TRAPS) {
 414   // field_class  : declaring class
 415   // acc          : declared field access
 416   // target_class : for protected
 417 
 418   // Check if field or method is accessible to client.  Throw an
 419   // IllegalAccessException and return false if not.
 420 
 421   // The "client" is the class associated with the nearest real frame
 422   // getCallerClass already skips Method.invoke frames, so pass 0 in
 423   // that case (same as classic).
 424   ResourceMark rm(THREAD);
 425   assert(THREAD-&gt;is_Java_thread(), "sanity check");
 426   Klass* client_class = ((JavaThread *)THREAD)-&gt;security_get_caller_class(is_method_invoke ? 0 : 1);
 427 
 428   if (client_class != field_class) {
 429     if (!verify_class_access(client_class, field_class, false)
 430         || !verify_field_access(client_class,
 431                                 field_class,
 432                                 field_class,
 433                                 acc,
 434                                 false)) {
 435       THROW_(vmSymbols::java_lang_IllegalAccessException(), false);
 436     }
 437   }
 438 
 439   // Additional test for protected members: JLS 6.6.2
 440 
 441   if (acc.is_protected()) {
 442     if (target_class != client_class) {
 443       if (!is_same_class_package(client_class, field_class)) {
 444         if (!target_class-&gt;is_subclass_of(client_class)) {
 445           THROW_(vmSymbols::java_lang_IllegalAccessException(), false);
 446         }
 447       }
 448     }
 449   }
 450 
 451   // Passed all tests
 452   return true;
 453 }
 454 
 455 
 456 bool Reflection::verify_class_access(Klass* current_class, Klass* new_class, bool classloader_only) {
 457   // Verify that current_class can access new_class.  If the classloader_only
 458   // flag is set, we automatically allow any accesses in which current_class
 459   // doesn't have a classloader.
 460   if ((current_class == NULL) ||
 461       (current_class == new_class) ||
 462       (new_class-&gt;is_public()) ||
 463       is_same_class_package(current_class, new_class)) {
 464     return true;
 465   }
 466   // New (1.4) reflection implementation. Allow all accesses from
 467   // sun/reflect/MagicAccessorImpl subclasses to succeed trivially.
 468   if (   JDK_Version::is_gte_jdk14x_version()
<a name="1" id="anc1"></a><span class="removed"> 469       &amp;&amp; UseNewReflection</span>
 470       &amp;&amp; current_class-&gt;is_subclass_of(SystemDictionary::reflect_MagicAccessorImpl_klass())) {
 471     return true;
 472   }
 473 
 474   return can_relax_access_check_for(current_class, new_class, classloader_only);
 475 }
 476 
 477 static bool under_host_klass(InstanceKlass* ik, Klass* host_klass) {
 478   DEBUG_ONLY(int inf_loop_check = 1000 * 1000 * 1000);
 479   for (;;) {
 480     Klass* hc = (Klass*) ik-&gt;host_klass();
 481     if (hc == NULL)        return false;
 482     if (hc == host_klass)  return true;
 483     ik = InstanceKlass::cast(hc);
 484 
 485     // There's no way to make a host class loop short of patching memory.
 486     // Therefore there cannot be a loop here unless there's another bug.
 487     // Still, let's check for it.
 488     assert(--inf_loop_check &gt; 0, "no host_klass loop");
 489   }
 490 }
 491 
 492 bool Reflection::can_relax_access_check_for(
 493     Klass* accessor, Klass* accessee, bool classloader_only) {
 494   InstanceKlass* accessor_ik = InstanceKlass::cast(accessor);
 495   InstanceKlass* accessee_ik  = InstanceKlass::cast(accessee);
 496 
 497   // If either is on the other's host_klass chain, access is OK,
 498   // because one is inside the other.
 499   if (under_host_klass(accessor_ik, accessee) ||
 500       under_host_klass(accessee_ik, accessor))
 501     return true;
 502 
 503   if ((RelaxAccessControlCheck &amp;&amp;
 504         accessor_ik-&gt;major_version() &lt; Verifier::NO_RELAX_ACCESS_CTRL_CHECK_VERSION &amp;&amp;
 505         accessee_ik-&gt;major_version() &lt; Verifier::NO_RELAX_ACCESS_CTRL_CHECK_VERSION) ||
 506       (accessor_ik-&gt;major_version() &lt; Verifier::STRICTER_ACCESS_CTRL_CHECK_VERSION &amp;&amp;
 507        accessee_ik-&gt;major_version() &lt; Verifier::STRICTER_ACCESS_CTRL_CHECK_VERSION)) {
 508     return classloader_only &amp;&amp;
 509       Verifier::relax_verify_for(accessor_ik-&gt;class_loader()) &amp;&amp;
 510       accessor_ik-&gt;protection_domain() == accessee_ik-&gt;protection_domain() &amp;&amp;
 511       accessor_ik-&gt;class_loader() == accessee_ik-&gt;class_loader();
 512   } else {
 513     return false;
 514   }
 515 }
 516 
 517 bool Reflection::verify_field_access(Klass* current_class,
 518                                      Klass* resolved_class,
 519                                      Klass* field_class,
 520                                      AccessFlags access,
 521                                      bool classloader_only,
 522                                      bool protected_restriction) {
 523   // Verify that current_class can access a field of field_class, where that
 524   // field's access bits are "access".  We assume that we've already verified
 525   // that current_class can access field_class.
 526   //
 527   // If the classloader_only flag is set, we automatically allow any accesses
 528   // in which current_class doesn't have a classloader.
 529   //
 530   // "resolved_class" is the runtime type of "field_class". Sometimes we don't
 531   // need this distinction (e.g. if all we have is the runtime type, or during
 532   // class file parsing when we only care about the static type); in that case
 533   // callers should ensure that resolved_class == field_class.
 534   //
 535   if ((current_class == NULL) ||
 536       (current_class == field_class) ||
 537       access.is_public()) {
 538     return true;
 539   }
 540 
 541   Klass* host_class = current_class;
 542   while (host_class-&gt;oop_is_instance() &amp;&amp;
 543          InstanceKlass::cast(host_class)-&gt;is_anonymous()) {
 544     Klass* next_host_class = InstanceKlass::cast(host_class)-&gt;host_klass();
 545     if (next_host_class == NULL)  break;
 546     host_class = next_host_class;
 547   }
 548   if (host_class == field_class) {
 549     return true;
 550   }
 551 
 552   if (access.is_protected()) {
 553     if (!protected_restriction) {
 554       // See if current_class (or outermost host class) is a subclass of field_class
 555       if (host_class-&gt;is_subclass_of(field_class)) {
 556         if (access.is_static() || // static fields are ok, see 6622385
 557             current_class == resolved_class ||
 558             field_class == resolved_class ||
 559             host_class-&gt;is_subclass_of(resolved_class) ||
 560             resolved_class-&gt;is_subclass_of(host_class)) {
 561           return true;
 562         }
 563       }
 564     }
 565   }
 566 
 567   if (!access.is_private() &amp;&amp; is_same_class_package(current_class, field_class)) {
 568     return true;
 569   }
 570 
 571   // New (1.4) reflection implementation. Allow all accesses from
 572   // sun/reflect/MagicAccessorImpl subclasses to succeed trivially.
 573   if (   JDK_Version::is_gte_jdk14x_version()
<a name="2" id="anc2"></a><span class="removed"> 574       &amp;&amp; UseNewReflection</span>
 575       &amp;&amp; current_class-&gt;is_subclass_of(SystemDictionary::reflect_MagicAccessorImpl_klass())) {
 576     return true;
 577   }
 578 
 579   return can_relax_access_check_for(
 580     current_class, field_class, classloader_only);
 581 }
 582 
 583 
 584 bool Reflection::is_same_class_package(Klass* class1, Klass* class2) {
 585   return InstanceKlass::cast(class1)-&gt;is_same_class_package(class2);
 586 }
 587 
 588 bool Reflection::is_same_package_member(Klass* class1, Klass* class2, TRAPS) {
 589   return InstanceKlass::cast(class1)-&gt;is_same_package_member(class2, THREAD);
 590 }
 591 
 592 
 593 // Checks that the 'outer' klass has declared 'inner' as being an inner klass. If not,
 594 // throw an incompatible class change exception
 595 // If inner_is_member, require the inner to be a member of the outer.
 596 // If !inner_is_member, require the inner to be anonymous (a non-member).
 597 // Caller is responsible for figuring out in advance which case must be true.
 598 void Reflection::check_for_inner_class(instanceKlassHandle outer, instanceKlassHandle inner,
 599                                        bool inner_is_member, TRAPS) {
 600   InnerClassesIterator iter(outer);
 601   constantPoolHandle cp   (THREAD, outer-&gt;constants());
 602   for (; !iter.done(); iter.next()) {
 603      int ioff = iter.inner_class_info_index();
 604      int ooff = iter.outer_class_info_index();
 605 
 606      if (inner_is_member &amp;&amp; ioff != 0 &amp;&amp; ooff != 0) {
 607         Klass* o = cp-&gt;klass_at(ooff, CHECK);
 608         if (o == outer()) {
 609           Klass* i = cp-&gt;klass_at(ioff, CHECK);
 610           if (i == inner()) {
 611             return;
 612           }
 613         }
 614      }
 615      if (!inner_is_member &amp;&amp; ioff != 0 &amp;&amp; ooff == 0 &amp;&amp;
 616          cp-&gt;klass_name_at_matches(inner, ioff)) {
 617         Klass* i = cp-&gt;klass_at(ioff, CHECK);
 618         if (i == inner()) {
 619           return;
 620         }
 621      }
 622   }
 623 
 624   // 'inner' not declared as an inner klass in outer
 625   ResourceMark rm(THREAD);
 626   Exceptions::fthrow(
 627     THREAD_AND_LOCATION,
 628     vmSymbols::java_lang_IncompatibleClassChangeError(),
 629     "%s and %s disagree on InnerClasses attribute",
 630     outer-&gt;external_name(),
 631     inner-&gt;external_name()
 632   );
 633 }
 634 
 635 // Utility method converting a single SignatureStream element into java.lang.Class instance
 636 
 637 oop get_mirror_from_signature(methodHandle method, SignatureStream* ss, TRAPS) {
 638   switch (ss-&gt;type()) {
 639     default:
 640       assert(ss-&gt;type() != T_VOID || ss-&gt;at_return_type(), "T_VOID should only appear as return type");
 641       return java_lang_Class::primitive_mirror(ss-&gt;type());
 642     case T_OBJECT:
 643     case T_ARRAY:
 644       Symbol* name        = ss-&gt;as_symbol(CHECK_NULL);
 645       oop loader            = method-&gt;method_holder()-&gt;class_loader();
 646       oop protection_domain = method-&gt;method_holder()-&gt;protection_domain();
 647       Klass* k = SystemDictionary::resolve_or_fail(
 648                                        name,
 649                                        Handle(THREAD, loader),
 650                                        Handle(THREAD, protection_domain),
 651                                        true, CHECK_NULL);
 652       if (TraceClassResolution) {
 653         trace_class_resolution(k);
 654       }
 655       return k-&gt;java_mirror();
 656   };
 657 }
 658 
 659 
 660 objArrayHandle Reflection::get_parameter_types(methodHandle method, int parameter_count, oop* return_type, TRAPS) {
 661   // Allocate array holding parameter types (java.lang.Class instances)
 662   objArrayOop m = oopFactory::new_objArray(SystemDictionary::Class_klass(), parameter_count, CHECK_(objArrayHandle()));
 663   objArrayHandle mirrors (THREAD, m);
 664   int index = 0;
 665   // Collect parameter types
 666   ResourceMark rm(THREAD);
 667   Symbol*  signature  = method-&gt;signature();
 668   SignatureStream ss(signature);
 669   while (!ss.at_return_type()) {
 670     oop mirror = get_mirror_from_signature(method, &amp;ss, CHECK_(objArrayHandle()));
 671     mirrors-&gt;obj_at_put(index++, mirror);
 672     ss.next();
 673   }
 674   assert(index == parameter_count, "invalid parameter count");
 675   if (return_type != NULL) {
 676     // Collect return type as well
 677     assert(ss.at_return_type(), "return type should be present");
 678     *return_type = get_mirror_from_signature(method, &amp;ss, CHECK_(objArrayHandle()));
 679   }
 680   return mirrors;
 681 }
 682 
 683 objArrayHandle Reflection::get_exception_types(methodHandle method, TRAPS) {
 684   return method-&gt;resolved_checked_exceptions(CHECK_(objArrayHandle()));
 685 }
 686 
 687 
 688 Handle Reflection::new_type(Symbol* signature, KlassHandle k, TRAPS) {
 689   // Basic types
 690   BasicType type = vmSymbols::signature_type(signature);
 691   if (type != T_OBJECT) {
 692     return Handle(THREAD, Universe::java_mirror(type));
 693   }
 694 
 695   oop loader = InstanceKlass::cast(k())-&gt;class_loader();
 696   oop protection_domain = k()-&gt;protection_domain();
 697   Klass* result = SystemDictionary::resolve_or_fail(signature,
 698                                     Handle(THREAD, loader),
 699                                     Handle(THREAD, protection_domain),
 700                                     true, CHECK_(Handle()));
 701 
 702   if (TraceClassResolution) {
 703     trace_class_resolution(result);
 704   }
 705 
 706   oop nt = result-&gt;java_mirror();
 707   return Handle(THREAD, nt);
 708 }
 709 
 710 
<a name="3" id="anc3"></a><span class="changed"> 711 oop Reflection::new_method(methodHandle method, bool intern_name, bool for_constant_pool_access, TRAPS) {</span>
 712   // In jdk1.2.x, getMethods on an interface erroneously includes &lt;clinit&gt;, thus the complicated assert.
 713   // Also allow sun.reflect.ConstantPool to refer to &lt;clinit&gt; methods as java.lang.reflect.Methods.
 714   assert(!method()-&gt;is_initializer() ||
 715          (for_constant_pool_access &amp;&amp; method()-&gt;is_static()) ||
 716          (method()-&gt;name() == vmSymbols::class_initializer_name()
 717     &amp;&amp; method()-&gt;method_holder()-&gt;is_interface() &amp;&amp; JDK_Version::is_jdk12x_version()), "should call new_constructor instead");
 718   instanceKlassHandle holder (THREAD, method-&gt;method_holder());
 719   int slot = method-&gt;method_idnum();
 720 
 721   Symbol*  signature  = method-&gt;signature();
 722   int parameter_count = ArgumentCount(signature).size();
 723   oop return_type_oop = NULL;
 724   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, &amp;return_type_oop, CHECK_NULL);
 725   if (parameter_types.is_null() || return_type_oop == NULL) return NULL;
 726 
 727   Handle return_type(THREAD, return_type_oop);
 728 
 729   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 730 
 731   if (exception_types.is_null()) return NULL;
 732 
 733   Symbol*  method_name = method-&gt;name();
<a name="4" id="anc4"></a><span class="removed"> 734   Handle name;</span>
<span class="removed"> 735   if (intern_name) {</span>
<span class="removed"> 736     // intern_name is only true with UseNewReflection</span>
 737     oop name_oop = StringTable::intern(method_name, CHECK_NULL);
<a name="5" id="anc5"></a><span class="changed"> 738     name = Handle(THREAD, name_oop);</span>
<span class="changed"> 739   } else {</span>
<span class="changed"> 740     name = java_lang_String::create_from_symbol(method_name, CHECK_NULL);</span>
<span class="changed"> 741   }</span>
 742   if (name == NULL) return NULL;
 743 
 744   int modifiers = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
 745 
 746   Handle mh = java_lang_reflect_Method::create(CHECK_NULL);
 747 
 748   java_lang_reflect_Method::set_clazz(mh(), holder-&gt;java_mirror());
 749   java_lang_reflect_Method::set_slot(mh(), slot);
 750   java_lang_reflect_Method::set_name(mh(), name());
 751   java_lang_reflect_Method::set_return_type(mh(), return_type());
 752   java_lang_reflect_Method::set_parameter_types(mh(), parameter_types());
 753   java_lang_reflect_Method::set_exception_types(mh(), exception_types());
 754   java_lang_reflect_Method::set_modifiers(mh(), modifiers);
 755   java_lang_reflect_Method::set_override(mh(), false);
 756   if (java_lang_reflect_Method::has_signature_field() &amp;&amp;
 757       method-&gt;generic_signature() != NULL) {
 758     Symbol*  gs = method-&gt;generic_signature();
 759     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 760     java_lang_reflect_Method::set_signature(mh(), sig());
 761   }
 762   if (java_lang_reflect_Method::has_annotations_field()) {
 763     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotations(), CHECK_NULL);
 764     java_lang_reflect_Method::set_annotations(mh(), an_oop);
 765   }
 766   if (java_lang_reflect_Method::has_parameter_annotations_field()) {
 767     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 768     java_lang_reflect_Method::set_parameter_annotations(mh(), an_oop);
 769   }
 770   if (java_lang_reflect_Method::has_annotation_default_field()) {
 771     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotation_default(), CHECK_NULL);
 772     java_lang_reflect_Method::set_annotation_default(mh(), an_oop);
 773   }
 774   if (java_lang_reflect_Method::has_type_annotations_field()) {
 775     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;type_annotations(), CHECK_NULL);
 776     java_lang_reflect_Method::set_type_annotations(mh(), an_oop);
 777   }
 778   return mh();
 779 }
 780 
 781 
 782 oop Reflection::new_constructor(methodHandle method, TRAPS) {
 783   assert(method()-&gt;is_initializer(), "should call new_method instead");
 784 
 785   instanceKlassHandle  holder (THREAD, method-&gt;method_holder());
 786   int slot = method-&gt;method_idnum();
 787 
 788   Symbol*  signature  = method-&gt;signature();
 789   int parameter_count = ArgumentCount(signature).size();
 790   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, NULL, CHECK_NULL);
 791   if (parameter_types.is_null()) return NULL;
 792 
 793   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 794   if (exception_types.is_null()) return NULL;
 795 
 796   int modifiers = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
 797 
 798   Handle ch = java_lang_reflect_Constructor::create(CHECK_NULL);
 799 
 800   java_lang_reflect_Constructor::set_clazz(ch(), holder-&gt;java_mirror());
 801   java_lang_reflect_Constructor::set_slot(ch(), slot);
 802   java_lang_reflect_Constructor::set_parameter_types(ch(), parameter_types());
 803   java_lang_reflect_Constructor::set_exception_types(ch(), exception_types());
 804   java_lang_reflect_Constructor::set_modifiers(ch(), modifiers);
 805   java_lang_reflect_Constructor::set_override(ch(), false);
 806   if (java_lang_reflect_Constructor::has_signature_field() &amp;&amp;
 807       method-&gt;generic_signature() != NULL) {
 808     Symbol*  gs = method-&gt;generic_signature();
 809     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 810     java_lang_reflect_Constructor::set_signature(ch(), sig());
 811   }
 812   if (java_lang_reflect_Constructor::has_annotations_field()) {
 813     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotations(), CHECK_NULL);
 814     java_lang_reflect_Constructor::set_annotations(ch(), an_oop);
 815   }
 816   if (java_lang_reflect_Constructor::has_parameter_annotations_field()) {
 817     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 818     java_lang_reflect_Constructor::set_parameter_annotations(ch(), an_oop);
 819   }
 820   if (java_lang_reflect_Constructor::has_type_annotations_field()) {
 821     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;type_annotations(), CHECK_NULL);
 822     java_lang_reflect_Constructor::set_type_annotations(ch(), an_oop);
 823   }
 824   return ch();
 825 }
 826 
 827 
<a name="6" id="anc6"></a><span class="changed"> 828 oop Reflection::new_field(fieldDescriptor* fd, bool intern_name, TRAPS) {</span>
 829   Symbol*  field_name = fd-&gt;name();
<a name="7" id="anc7"></a><span class="removed"> 830   Handle name;</span>
<span class="removed"> 831   if (intern_name) {</span>
<span class="removed"> 832     // intern_name is only true with UseNewReflection</span>
 833     oop name_oop = StringTable::intern(field_name, CHECK_NULL);
<a name="8" id="anc8"></a><span class="changed"> 834     name = Handle(THREAD, name_oop);</span>
<span class="changed"> 835   } else {</span>
<span class="changed"> 836     name = java_lang_String::create_from_symbol(field_name, CHECK_NULL);</span>
<span class="changed"> 837   }</span>
 838   Symbol*  signature  = fd-&gt;signature();
 839   instanceKlassHandle  holder    (THREAD, fd-&gt;field_holder());
 840   Handle type = new_type(signature, holder, CHECK_NULL);
 841   Handle rh  = java_lang_reflect_Field::create(CHECK_NULL);
 842 
 843   java_lang_reflect_Field::set_clazz(rh(), fd-&gt;field_holder()-&gt;java_mirror());
 844   java_lang_reflect_Field::set_slot(rh(), fd-&gt;index());
 845   java_lang_reflect_Field::set_name(rh(), name());
 846   java_lang_reflect_Field::set_type(rh(), type());
 847   // Note the ACC_ANNOTATION bit, which is a per-class access flag, is never set here.
 848   java_lang_reflect_Field::set_modifiers(rh(), fd-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS);
 849   java_lang_reflect_Field::set_override(rh(), false);
 850   if (java_lang_reflect_Field::has_signature_field() &amp;&amp;
 851       fd-&gt;has_generic_signature()) {
 852     Symbol*  gs = fd-&gt;generic_signature();
 853     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 854     java_lang_reflect_Field::set_signature(rh(), sig());
 855   }
 856   if (java_lang_reflect_Field::has_annotations_field()) {
 857     typeArrayOop an_oop = Annotations::make_java_array(fd-&gt;annotations(), CHECK_NULL);
 858     java_lang_reflect_Field::set_annotations(rh(), an_oop);
 859   }
 860   if (java_lang_reflect_Field::has_type_annotations_field()) {
 861     typeArrayOop an_oop = Annotations::make_java_array(fd-&gt;type_annotations(), CHECK_NULL);
 862     java_lang_reflect_Field::set_type_annotations(rh(), an_oop);
 863   }
 864   return rh();
 865 }
 866 
 867 oop Reflection::new_parameter(Handle method, int index, Symbol* sym,
 868                               int flags, TRAPS) {
 869   Handle name;
 870 
 871   // A null symbol here translates to the empty string
 872   if(NULL != sym) {
 873     name = java_lang_String::create_from_symbol(sym, CHECK_NULL);
 874   } else {
 875     name = java_lang_String::create_from_str("", CHECK_NULL);
 876   }
 877 
 878   Handle rh = java_lang_reflect_Parameter::create(CHECK_NULL);
 879   java_lang_reflect_Parameter::set_name(rh(), name());
 880   java_lang_reflect_Parameter::set_modifiers(rh(), flags);
 881   java_lang_reflect_Parameter::set_executable(rh(), method());
 882   java_lang_reflect_Parameter::set_index(rh(), index);
 883   return rh();
 884 }
 885 
 886 
 887 methodHandle Reflection::resolve_interface_call(instanceKlassHandle klass, methodHandle method,
 888                                                 KlassHandle recv_klass, Handle receiver, TRAPS) {
 889   assert(!method.is_null() , "method should not be null");
 890 
 891   CallInfo info;
 892   Symbol*  signature  = method-&gt;signature();
 893   Symbol*  name       = method-&gt;name();
 894   LinkResolver::resolve_interface_call(info, receiver, recv_klass, klass,
 895                                        name, signature,
 896                                        KlassHandle(), false, true,
 897                                        CHECK_(methodHandle()));
 898   return info.selected_method();
 899 }
 900 
 901 
 902 oop Reflection::invoke(instanceKlassHandle klass, methodHandle reflected_method,
 903                        Handle receiver, bool override, objArrayHandle ptypes,
 904                        BasicType rtype, objArrayHandle args, bool is_method_invoke, TRAPS) {
 905   ResourceMark rm(THREAD);
 906 
 907   methodHandle method;      // actual method to invoke
 908   KlassHandle target_klass; // target klass, receiver's klass for non-static
 909 
 910   // Ensure klass is initialized
 911   klass-&gt;initialize(CHECK_NULL);
 912 
 913   bool is_static = reflected_method-&gt;is_static();
 914   if (is_static) {
 915     // ignore receiver argument
 916     method = reflected_method;
 917     target_klass = klass;
 918   } else {
 919     // check for null receiver
 920     if (receiver.is_null()) {
 921       THROW_0(vmSymbols::java_lang_NullPointerException());
 922     }
 923     // Check class of receiver against class declaring method
 924     if (!receiver-&gt;is_a(klass())) {
 925       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "object is not an instance of declaring class");
 926     }
 927     // target klass is receiver's klass
 928     target_klass = KlassHandle(THREAD, receiver-&gt;klass());
 929     // no need to resolve if method is private or &lt;init&gt;
 930     if (reflected_method-&gt;is_private() || reflected_method-&gt;name() == vmSymbols::object_initializer_name()) {
 931       method = reflected_method;
 932     } else {
 933       // resolve based on the receiver
 934       if (reflected_method-&gt;method_holder()-&gt;is_interface()) {
 935         // resolve interface call
<a name="9" id="anc9"></a><span class="changed"> 936         if (ReflectionWrapResolutionErrors) {</span>
<span class="changed"> 937           // new default: 6531596</span>
 938           // Match resolution errors with those thrown due to reflection inlining
 939           // Linktime resolution &amp; IllegalAccessCheck already done by Class.getMethod()
 940           method = resolve_interface_call(klass, reflected_method, target_klass, receiver, THREAD);
 941           if (HAS_PENDING_EXCEPTION) {
 942           // Method resolution threw an exception; wrap it in an InvocationTargetException
 943             oop resolution_exception = PENDING_EXCEPTION;
 944             CLEAR_PENDING_EXCEPTION;
 945             // JVMTI has already reported the pending exception
 946             // JVMTI internal flag reset is needed in order to report InvocationTargetException
 947             if (THREAD-&gt;is_Java_thread()) {
 948               JvmtiExport::clear_detected_exception((JavaThread*) THREAD);
 949             }
 950             JavaCallArguments args(Handle(THREAD, resolution_exception));
 951             THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
 952                 vmSymbols::throwable_void_signature(),
 953                 &amp;args);
 954           }
 955         } else {
<a name="10" id="anc10"></a><span class="removed"> 956           method = resolve_interface_call(klass, reflected_method, target_klass, receiver, CHECK_(NULL));</span>
<span class="removed"> 957         }</span>
<span class="removed"> 958       }  else {</span>
 959         // if the method can be overridden, we resolve using the vtable index.
 960         assert(!reflected_method-&gt;has_itable_index(), "");
 961         int index = reflected_method-&gt;vtable_index();
 962         method = reflected_method;
 963         if (index != Method::nonvirtual_vtable_index) {
 964           // target_klass might be an arrayKlassOop but all vtables start at
 965           // the same place. The cast is to avoid virtual call and assertion.
 966           InstanceKlass* inst = (InstanceKlass*)target_klass();
 967           method = methodHandle(THREAD, inst-&gt;method_at_vtable(index));
 968         }
 969         if (!method.is_null()) {
 970           // Check for abstract methods as well
 971           if (method-&gt;is_abstract()) {
 972             // new default: 6531596
<a name="11" id="anc11"></a><span class="removed"> 973             if (ReflectionWrapResolutionErrors) {</span>
 974               ResourceMark rm(THREAD);
 975               Handle h_origexception = Exceptions::new_exception(THREAD,
 976                      vmSymbols::java_lang_AbstractMethodError(),
 977                      Method::name_and_sig_as_C_string(target_klass(),
 978                      method-&gt;name(),
 979                      method-&gt;signature()));
 980               JavaCallArguments args(h_origexception);
 981               THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
 982                 vmSymbols::throwable_void_signature(),
 983                 &amp;args);
<a name="12" id="anc12"></a><span class="removed"> 984             } else {</span>
<span class="removed"> 985               ResourceMark rm(THREAD);</span>
<span class="removed"> 986               THROW_MSG_0(vmSymbols::java_lang_AbstractMethodError(),</span>
<span class="removed"> 987                         Method::name_and_sig_as_C_string(target_klass(),</span>
<span class="removed"> 988                                                                 method-&gt;name(),</span>
<span class="removed"> 989                                                                 method-&gt;signature()));</span>
<span class="removed"> 990             }</span>
 991           }
 992         }
 993       }
 994     }
 995   }
 996 
 997   // I believe this is a ShouldNotGetHere case which requires
 998   // an internal vtable bug. If you ever get this please let Karen know.
 999   if (method.is_null()) {
1000     ResourceMark rm(THREAD);
1001     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(),
1002                 Method::name_and_sig_as_C_string(klass(),
1003                                                         reflected_method-&gt;name(),
1004                                                         reflected_method-&gt;signature()));
1005   }
1006 
1007   // In the JDK 1.4 reflection implementation, the security check is
1008   // done at the Java level
<a name="13" id="anc13"></a><span class="changed">1009   if (!(JDK_Version::is_gte_jdk14x_version() &amp;&amp; UseNewReflection)) {</span>
1010 
1011   // Access checking (unless overridden by Method)
1012   if (!override) {
1013     if (!(klass-&gt;is_public() &amp;&amp; reflected_method-&gt;is_public())) {
1014       bool access = Reflection::reflect_check_access(klass(), reflected_method-&gt;access_flags(), target_klass(), is_method_invoke, CHECK_NULL);
1015       if (!access) {
1016         return NULL; // exception
1017       }
1018     }
1019   }
1020 
<a name="14" id="anc14"></a><span class="changed">1021   } // !(Universe::is_gte_jdk14x_version() &amp;&amp; UseNewReflection)</span>
1022 
1023   assert(ptypes-&gt;is_objArray(), "just checking");
1024   int args_len = args.is_null() ? 0 : args-&gt;length();
1025   // Check number of arguments
1026   if (ptypes-&gt;length() != args_len) {
1027     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "wrong number of arguments");
1028   }
1029 
1030   // Create object to contain parameters for the JavaCall
1031   JavaCallArguments java_args(method-&gt;size_of_parameters());
1032 
1033   if (!is_static) {
1034     java_args.push_oop(receiver);
1035   }
1036 
1037   for (int i = 0; i &lt; args_len; i++) {
1038     oop type_mirror = ptypes-&gt;obj_at(i);
1039     oop arg = args-&gt;obj_at(i);
1040     if (java_lang_Class::is_primitive(type_mirror)) {
1041       jvalue value;
1042       BasicType ptype = basic_type_mirror_to_basic_type(type_mirror, CHECK_NULL);
1043       BasicType atype = unbox_for_primitive(arg, &amp;value, CHECK_NULL);
1044       if (ptype != atype) {
1045         widen(&amp;value, atype, ptype, CHECK_NULL);
1046       }
1047       switch (ptype) {
1048         case T_BOOLEAN:     java_args.push_int(value.z);    break;
1049         case T_CHAR:        java_args.push_int(value.c);    break;
1050         case T_BYTE:        java_args.push_int(value.b);    break;
1051         case T_SHORT:       java_args.push_int(value.s);    break;
1052         case T_INT:         java_args.push_int(value.i);    break;
1053         case T_LONG:        java_args.push_long(value.j);   break;
1054         case T_FLOAT:       java_args.push_float(value.f);  break;
1055         case T_DOUBLE:      java_args.push_double(value.d); break;
1056         default:
1057           THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "argument type mismatch");
1058       }
1059     } else {
1060       if (arg != NULL) {
1061         Klass* k = java_lang_Class::as_Klass(type_mirror);
1062         if (!arg-&gt;is_a(k)) {
1063           THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "argument type mismatch");
1064         }
1065       }
1066       Handle arg_handle(THREAD, arg);         // Create handle for argument
1067       java_args.push_oop(arg_handle); // Push handle
1068     }
1069   }
1070 
1071   assert(java_args.size_of_parameters() == method-&gt;size_of_parameters(), "just checking");
1072 
1073   // All oops (including receiver) is passed in as Handles. An potential oop is returned as an
1074   // oop (i.e., NOT as an handle)
1075   JavaValue result(rtype);
1076   JavaCalls::call(&amp;result, method, &amp;java_args, THREAD);
1077 
1078   if (HAS_PENDING_EXCEPTION) {
1079     // Method threw an exception; wrap it in an InvocationTargetException
1080     oop target_exception = PENDING_EXCEPTION;
1081     CLEAR_PENDING_EXCEPTION;
1082     // JVMTI has already reported the pending exception
1083     // JVMTI internal flag reset is needed in order to report InvocationTargetException
1084     if (THREAD-&gt;is_Java_thread()) {
1085       JvmtiExport::clear_detected_exception((JavaThread*) THREAD);
1086     }
1087 
1088     JavaCallArguments args(Handle(THREAD, target_exception));
1089     THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1090                 vmSymbols::throwable_void_signature(),
1091                 &amp;args);
1092   } else {
1093     if (rtype == T_BOOLEAN || rtype == T_BYTE || rtype == T_CHAR || rtype == T_SHORT)
1094       narrow((jvalue*) result.get_value_addr(), rtype, CHECK_NULL);
1095     return box((jvalue*) result.get_value_addr(), rtype, CHECK_NULL);
1096   }
1097 }
1098 
1099 
1100 void Reflection::narrow(jvalue* value, BasicType narrow_type, TRAPS) {
1101   switch (narrow_type) {
1102     case T_BOOLEAN:
1103      value-&gt;z = (jboolean) value-&gt;i;
1104      return;
1105     case T_BYTE:
1106      value-&gt;b = (jbyte) value-&gt;i;
1107      return;
1108     case T_CHAR:
1109      value-&gt;c = (jchar) value-&gt;i;
1110      return;
1111     case T_SHORT:
1112      value-&gt;s = (jshort) value-&gt;i;
1113      return;
1114     default:
1115       break; // fail
1116    }
1117   THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), "argument type mismatch");
1118 }
1119 
1120 
1121 BasicType Reflection::basic_type_mirror_to_basic_type(oop basic_type_mirror, TRAPS) {
1122   assert(java_lang_Class::is_primitive(basic_type_mirror), "just checking");
1123   return java_lang_Class::primitive_type(basic_type_mirror);
1124 }
1125 
1126 // This would be nicer if, say, java.lang.reflect.Method was a subclass
1127 // of java.lang.reflect.Constructor
1128 
1129 oop Reflection::invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS) {
1130   oop mirror             = java_lang_reflect_Method::clazz(method_mirror);
1131   int slot               = java_lang_reflect_Method::slot(method_mirror);
1132   bool override          = java_lang_reflect_Method::override(method_mirror) != 0;
1133   objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)));
1134 
1135   oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);
1136   BasicType rtype;
1137   if (java_lang_Class::is_primitive(return_type_mirror)) {
1138     rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);
1139   } else {
1140     rtype = T_OBJECT;
1141   }
1142 
1143   instanceKlassHandle klass(THREAD, java_lang_Class::as_Klass(mirror));
1144   Method* m = klass-&gt;method_with_idnum(slot);
1145   if (m == NULL) {
1146     THROW_MSG_0(vmSymbols::java_lang_InternalError(), "invoke");
1147   }
1148   methodHandle method(THREAD, m);
1149 
1150   return invoke(klass, method, receiver, override, ptypes, rtype, args, true, THREAD);
1151 }
1152 
1153 
1154 oop Reflection::invoke_constructor(oop constructor_mirror, objArrayHandle args, TRAPS) {
1155   oop mirror             = java_lang_reflect_Constructor::clazz(constructor_mirror);
1156   int slot               = java_lang_reflect_Constructor::slot(constructor_mirror);
1157   bool override          = java_lang_reflect_Constructor::override(constructor_mirror) != 0;
1158   objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Constructor::parameter_types(constructor_mirror)));
1159 
1160   instanceKlassHandle klass(THREAD, java_lang_Class::as_Klass(mirror));
1161   Method* m = klass-&gt;method_with_idnum(slot);
1162   if (m == NULL) {
1163     THROW_MSG_0(vmSymbols::java_lang_InternalError(), "invoke");
1164   }
1165   methodHandle method(THREAD, m);
1166   assert(method-&gt;name() == vmSymbols::object_initializer_name(), "invalid constructor");
1167 
1168   // Make sure klass gets initialize
1169   klass-&gt;initialize(CHECK_NULL);
1170 
1171   // Create new instance (the receiver)
1172   klass-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1173   Handle receiver = klass-&gt;allocate_instance_handle(CHECK_NULL);
1174 
1175   // Ignore result from call and return receiver
1176   invoke(klass, method, receiver, override, ptypes, T_VOID, args, false, CHECK_NULL);
1177   return receiver();
1178 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="15" type="hidden" /></form></body></html>
