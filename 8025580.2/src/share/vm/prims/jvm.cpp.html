<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/share/vm/prims/jvm.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 #include "classfile/classLoader.hpp"
  27 #include "classfile/javaAssertions.hpp"
  28 #include "classfile/javaClasses.hpp"
  29 #include "classfile/symbolTable.hpp"
  30 #include "classfile/systemDictionary.hpp"
  31 #include "classfile/vmSymbols.hpp"
  32 #include "gc_interface/collectedHeap.inline.hpp"
  33 #include "interpreter/bytecode.hpp"
  34 #include "memory/oopFactory.hpp"
  35 #include "memory/universe.inline.hpp"
  36 #include "oops/fieldStreams.hpp"
  37 #include "oops/instanceKlass.hpp"
  38 #include "oops/objArrayKlass.hpp"
  39 #include "oops/method.hpp"
  40 #include "prims/jvm.h"
  41 #include "prims/jvm_misc.hpp"
  42 #include "prims/jvmtiExport.hpp"
  43 #include "prims/jvmtiThreadState.hpp"
  44 #include "prims/nativeLookup.hpp"
  45 #include "prims/privilegedStack.hpp"
  46 #include "runtime/arguments.hpp"
  47 #include "runtime/dtraceJSDT.hpp"
  48 #include "runtime/handles.inline.hpp"
  49 #include "runtime/init.hpp"
  50 #include "runtime/interfaceSupport.hpp"
  51 #include "runtime/java.hpp"
  52 #include "runtime/javaCalls.hpp"
  53 #include "runtime/jfieldIDWorkaround.hpp"
  54 #include "runtime/os.hpp"
  55 #include "runtime/perfData.hpp"
  56 #include "runtime/reflection.hpp"
  57 #include "runtime/vframe.hpp"
  58 #include "runtime/vm_operations.hpp"
  59 #include "services/attachListener.hpp"
  60 #include "services/management.hpp"
  61 #include "services/threadService.hpp"
  62 #include "trace/tracing.hpp"
  63 #include "utilities/copy.hpp"
  64 #include "utilities/defaultStream.hpp"
  65 #include "utilities/dtrace.hpp"
  66 #include "utilities/events.hpp"
  67 #include "utilities/histogram.hpp"
  68 #include "utilities/top.hpp"
  69 #include "utilities/utf8.hpp"
  70 #ifdef TARGET_OS_FAMILY_linux
  71 # include "jvm_linux.h"
  72 #endif
  73 #ifdef TARGET_OS_FAMILY_solaris
  74 # include "jvm_solaris.h"
  75 #endif
  76 #ifdef TARGET_OS_FAMILY_windows
  77 # include "jvm_windows.h"
  78 #endif
  79 #ifdef TARGET_OS_FAMILY_aix
  80 # include "jvm_aix.h"
  81 #endif
  82 #ifdef TARGET_OS_FAMILY_bsd
  83 # include "jvm_bsd.h"
  84 #endif
  85 
  86 #include &lt;errno.h&gt;
  87 
  88 /*
  89   NOTE about use of any ctor or function call that can trigger a safepoint/GC:
  90   such ctors and calls MUST NOT come between an oop declaration/init and its
  91   usage because if objects are move this may cause various memory stomps, bus
  92   errors and segfaults. Here is a cookbook for causing so called "naked oop
  93   failures":
  94 
  95       JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields&lt;etc&gt; {
  96           JVMWrapper("JVM_GetClassDeclaredFields");
  97 
  98           // Object address to be held directly in mirror &amp; not visible to GC
  99           oop mirror = JNIHandles::resolve_non_null(ofClass);
 100 
 101           // If this ctor can hit a safepoint, moving objects around, then
 102           ComplexConstructor foo;
 103 
 104           // Boom! mirror may point to JUNK instead of the intended object
 105           (some dereference of mirror)
 106 
 107           // Here's another call that may block for GC, making mirror stale
 108           MutexLocker ml(some_lock);
 109 
 110           // And here's an initializer that can result in a stale oop
 111           // all in one step.
 112           oop o = call_that_can_throw_exception(TRAPS);
 113 
 114 
 115   The solution is to keep the oop declaration BELOW the ctor or function
 116   call that might cause a GC, do another resolve to reassign the oop, or
 117   consider use of a Handle instead of an oop so there is immunity from object
 118   motion. But note that the "QUICK" entries below do not have a handlemark
 119   and thus can only support use of handles passed in.
 120 */
 121 
 122 static void trace_class_resolution_impl(Klass* to_class, TRAPS) {
 123   ResourceMark rm;
 124   int line_number = -1;
 125   const char * source_file = NULL;
 126   const char * trace = "explicit";
 127   InstanceKlass* caller = NULL;
 128   JavaThread* jthread = JavaThread::current();
 129   if (jthread-&gt;has_last_Java_frame()) {
 130     vframeStream vfst(jthread);
 131 
 132     // scan up the stack skipping ClassLoader, AccessController and PrivilegedAction frames
 133     TempNewSymbol access_controller = SymbolTable::new_symbol("java/security/AccessController", CHECK);
 134     Klass* access_controller_klass = SystemDictionary::resolve_or_fail(access_controller, false, CHECK);
 135     TempNewSymbol privileged_action = SymbolTable::new_symbol("java/security/PrivilegedAction", CHECK);
 136     Klass* privileged_action_klass = SystemDictionary::resolve_or_fail(privileged_action, false, CHECK);
 137 
 138     Method* last_caller = NULL;
 139 
 140     while (!vfst.at_end()) {
 141       Method* m = vfst.method();
 142       if (!vfst.method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass())&amp;&amp;
 143           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(access_controller_klass) &amp;&amp;
 144           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(privileged_action_klass)) {
 145         break;
 146       }
 147       last_caller = m;
 148       vfst.next();
 149     }
 150     // if this is called from Class.forName0 and that is called from Class.forName,
 151     // then print the caller of Class.forName.  If this is Class.loadClass, then print
 152     // that caller, otherwise keep quiet since this should be picked up elsewhere.
 153     bool found_it = false;
 154     if (!vfst.at_end() &amp;&amp;
 155         vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 156         vfst.method()-&gt;name() == vmSymbols::forName0_name()) {
 157       vfst.next();
 158       if (!vfst.at_end() &amp;&amp;
 159           vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 160           vfst.method()-&gt;name() == vmSymbols::forName_name()) {
 161         vfst.next();
 162         found_it = true;
 163       }
 164     } else if (last_caller != NULL &amp;&amp;
 165                last_caller-&gt;method_holder()-&gt;name() ==
 166                vmSymbols::java_lang_ClassLoader() &amp;&amp;
 167                (last_caller-&gt;name() == vmSymbols::loadClassInternal_name() ||
 168                 last_caller-&gt;name() == vmSymbols::loadClass_name())) {
 169       found_it = true;
 170     } else if (!vfst.at_end()) {
 171       if (vfst.method()-&gt;is_native()) {
 172         // JNI call
 173         found_it = true;
 174       }
 175     }
 176     if (found_it &amp;&amp; !vfst.at_end()) {
 177       // found the caller
 178       caller = vfst.method()-&gt;method_holder();
 179       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
 180       if (line_number == -1) {
 181         // show method name if it's a native method
 182         trace = vfst.method()-&gt;name_and_sig_as_C_string();
 183       }
 184       Symbol* s = caller-&gt;source_file_name();
 185       if (s != NULL) {
 186         source_file = s-&gt;as_C_string();
 187       }
 188     }
 189   }
 190   if (caller != NULL) {
 191     if (to_class != caller) {
 192       const char * from = caller-&gt;external_name();
 193       const char * to = to_class-&gt;external_name();
 194       // print in a single call to reduce interleaving between threads
 195       if (source_file != NULL) {
 196         tty-&gt;print("RESOLVE %s %s %s:%d (%s)\n", from, to, source_file, line_number, trace);
 197       } else {
 198         tty-&gt;print("RESOLVE %s %s (%s)\n", from, to, trace);
 199       }
 200     }
 201   }
 202 }
 203 
 204 void trace_class_resolution(Klass* to_class) {
 205   EXCEPTION_MARK;
 206   trace_class_resolution_impl(to_class, THREAD);
 207   if (HAS_PENDING_EXCEPTION) {
 208     CLEAR_PENDING_EXCEPTION;
 209   }
 210 }
 211 
 212 // Wrapper to trace JVM functions
 213 
 214 #ifdef ASSERT
 215   class JVMTraceWrapper : public StackObj {
 216    public:
 217     JVMTraceWrapper(const char* format, ...) {
 218       if (TraceJVMCalls) {
 219         va_list ap;
 220         va_start(ap, format);
 221         tty-&gt;print("JVM ");
 222         tty-&gt;vprint_cr(format, ap);
 223         va_end(ap);
 224       }
 225     }
 226   };
 227 
 228   Histogram* JVMHistogram;
 229   volatile jint JVMHistogram_lock = 0;
 230 
 231   class JVMHistogramElement : public HistogramElement {
 232     public:
 233      JVMHistogramElement(const char* name);
 234   };
 235 
 236   JVMHistogramElement::JVMHistogramElement(const char* elementName) {
 237     _name = elementName;
 238     uintx count = 0;
 239 
 240     while (Atomic::cmpxchg(1, &amp;JVMHistogram_lock, 0) != 0) {
 241       while (OrderAccess::load_acquire(&amp;JVMHistogram_lock) != 0) {
 242         count +=1;
 243         if ( (WarnOnStalledSpinLock &gt; 0)
 244           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 245           warning("JVMHistogram_lock seems to be stalled");
 246         }
 247       }
 248      }
 249 
 250     if(JVMHistogram == NULL)
 251       JVMHistogram = new Histogram("JVM Call Counts",100);
 252 
 253     JVMHistogram-&gt;add_element(this);
 254     Atomic::dec(&amp;JVMHistogram_lock);
 255   }
 256 
 257   #define JVMCountWrapper(arg) \
 258       static JVMHistogramElement* e = new JVMHistogramElement(arg); \
 259       if (e != NULL) e-&gt;increment_count();  // Due to bug in VC++, we need a NULL check here eventhough it should never happen!
 260 
 261   #define JVMWrapper(arg1)                    JVMCountWrapper(arg1); JVMTraceWrapper(arg1)
 262   #define JVMWrapper2(arg1, arg2)             JVMCountWrapper(arg1); JVMTraceWrapper(arg1, arg2)
 263   #define JVMWrapper3(arg1, arg2, arg3)       JVMCountWrapper(arg1); JVMTraceWrapper(arg1, arg2, arg3)
 264   #define JVMWrapper4(arg1, arg2, arg3, arg4) JVMCountWrapper(arg1); JVMTraceWrapper(arg1, arg2, arg3, arg4)
 265 #else
 266   #define JVMWrapper(arg1)
 267   #define JVMWrapper2(arg1, arg2)
 268   #define JVMWrapper3(arg1, arg2, arg3)
 269   #define JVMWrapper4(arg1, arg2, arg3, arg4)
 270 #endif
 271 
 272 
 273 // Interface version /////////////////////////////////////////////////////////////////////
 274 
 275 
 276 JVM_LEAF(jint, JVM_GetInterfaceVersion())
 277   return JVM_INTERFACE_VERSION;
 278 JVM_END
 279 
 280 
 281 // java.lang.System //////////////////////////////////////////////////////////////////////
 282 
 283 
 284 JVM_LEAF(jlong, JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored))
 285   JVMWrapper("JVM_CurrentTimeMillis");
 286   return os::javaTimeMillis();
 287 JVM_END
 288 
 289 JVM_LEAF(jlong, JVM_NanoTime(JNIEnv *env, jclass ignored))
 290   JVMWrapper("JVM_NanoTime");
 291   return os::javaTimeNanos();
 292 JVM_END
 293 
 294 
 295 JVM_ENTRY(void, JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 296                                jobject dst, jint dst_pos, jint length))
 297   JVMWrapper("JVM_ArrayCopy");
 298   // Check if we have null pointers
 299   if (src == NULL || dst == NULL) {
 300     THROW(vmSymbols::java_lang_NullPointerException());
 301   }
 302   arrayOop s = arrayOop(JNIHandles::resolve_non_null(src));
 303   arrayOop d = arrayOop(JNIHandles::resolve_non_null(dst));
 304   assert(s-&gt;is_oop(), "JVM_ArrayCopy: src not an oop");
 305   assert(d-&gt;is_oop(), "JVM_ArrayCopy: dst not an oop");
 306   // Do copy
 307   s-&gt;klass()-&gt;copy_array(s, src_pos, d, dst_pos, length, thread);
 308 JVM_END
 309 
 310 
 311 static void set_property(Handle props, const char* key, const char* value, TRAPS) {
 312   JavaValue r(T_OBJECT);
 313   // public synchronized Object put(Object key, Object value);
 314   HandleMark hm(THREAD);
 315   Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK);
 316   Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : ""), CHECK);
 317   JavaCalls::call_virtual(&amp;r,
 318                           props,
 319                           KlassHandle(THREAD, SystemDictionary::Properties_klass()),
 320                           vmSymbols::put_name(),
 321                           vmSymbols::object_object_object_signature(),
 322                           key_str,
 323                           value_str,
 324                           THREAD);
 325 }
 326 
 327 
 328 #define PUTPROP(props, name, value) set_property((props), (name), (value), CHECK_(properties));
 329 
 330 
 331 JVM_ENTRY(jobject, JVM_InitProperties(JNIEnv *env, jobject properties))
 332   JVMWrapper("JVM_InitProperties");
 333   ResourceMark rm;
 334 
 335   Handle props(THREAD, JNIHandles::resolve_non_null(properties));
 336 
 337   // System property list includes both user set via -D option and
 338   // jvm system specific properties.
 339   for (SystemProperty* p = Arguments::system_properties(); p != NULL; p = p-&gt;next()) {
 340     PUTPROP(props, p-&gt;key(), p-&gt;value());
 341   }
 342 
 343   // Convert the -XX:MaxDirectMemorySize= command line flag
 344   // to the sun.nio.MaxDirectMemorySize property.
 345   // Do this after setting user properties to prevent people
 346   // from setting the value with a -D option, as requested.
 347   {
 348     if (FLAG_IS_DEFAULT(MaxDirectMemorySize)) {
 349       PUTPROP(props, "sun.nio.MaxDirectMemorySize", "-1");
 350     } else {
 351       char as_chars[256];
 352       jio_snprintf(as_chars, sizeof(as_chars), UINTX_FORMAT, MaxDirectMemorySize);
 353       PUTPROP(props, "sun.nio.MaxDirectMemorySize", as_chars);
 354     }
 355   }
 356 
 357   // JVM monitoring and management support
 358   // Add the sun.management.compiler property for the compiler's name
 359   {
 360 #undef CSIZE
 361 #if defined(_LP64) || defined(_WIN64)
 362   #define CSIZE "64-Bit "
 363 #else
 364   #define CSIZE
 365 #endif // 64bit
 366 
 367 #ifdef TIERED
 368     const char* compiler_name = "HotSpot " CSIZE "Tiered Compilers";
 369 #else
 370 #if defined(COMPILER1)
 371     const char* compiler_name = "HotSpot " CSIZE "Client Compiler";
 372 #elif defined(COMPILER2)
 373     const char* compiler_name = "HotSpot " CSIZE "Server Compiler";
 374 #else
 375     const char* compiler_name = "";
 376 #endif // compilers
 377 #endif // TIERED
 378 
 379     if (*compiler_name != '\0' &amp;&amp;
 380         (Arguments::mode() != Arguments::_int)) {
 381       PUTPROP(props, "sun.management.compiler", compiler_name);
 382     }
 383   }
 384 
 385   return properties;
 386 JVM_END
 387 
 388 
 389 // java.lang.Runtime /////////////////////////////////////////////////////////////////////////
 390 
 391 extern volatile jint vm_created;
 392 
 393 JVM_ENTRY_NO_ENV(void, JVM_Exit(jint code))
 394   if (vm_created != 0 &amp;&amp; (code == 0)) {
 395     // The VM is about to exit. We call back into Java to check whether finalizers should be run
 396     Universe::run_finalizers_on_exit();
 397   }
 398   before_exit(thread);
 399   vm_exit(code);
 400 JVM_END
 401 
 402 
 403 JVM_ENTRY_NO_ENV(void, JVM_Halt(jint code))
 404   before_exit(thread);
 405   vm_exit(code);
 406 JVM_END
 407 
 408 
 409 JVM_LEAF(void, JVM_OnExit(void (*func)(void)))
 410   register_on_exit_function(func);
 411 JVM_END
 412 
 413 
 414 JVM_ENTRY_NO_ENV(void, JVM_GC(void))
 415   JVMWrapper("JVM_GC");
 416   if (!DisableExplicitGC) {
 417     Universe::heap()-&gt;collect(GCCause::_java_lang_system_gc);
 418   }
 419 JVM_END
 420 
 421 
 422 JVM_LEAF(jlong, JVM_MaxObjectInspectionAge(void))
 423   JVMWrapper("JVM_MaxObjectInspectionAge");
 424   return Universe::heap()-&gt;millis_since_last_gc();
 425 JVM_END
 426 
 427 
 428 JVM_LEAF(void, JVM_TraceInstructions(jboolean on))
 429   if (PrintJVMWarnings) warning("JVM_TraceInstructions not supported");
 430 JVM_END
 431 
 432 
 433 JVM_LEAF(void, JVM_TraceMethodCalls(jboolean on))
 434   if (PrintJVMWarnings) warning("JVM_TraceMethodCalls not supported");
 435 JVM_END
 436 
 437 static inline jlong convert_size_t_to_jlong(size_t val) {
 438   // In the 64-bit vm, a size_t can overflow a jlong (which is signed).
 439   NOT_LP64 (return (jlong)val;)
 440   LP64_ONLY(return (jlong)MIN2(val, (size_t)max_jlong);)
 441 }
 442 
 443 JVM_ENTRY_NO_ENV(jlong, JVM_TotalMemory(void))
 444   JVMWrapper("JVM_TotalMemory");
 445   size_t n = Universe::heap()-&gt;capacity();
 446   return convert_size_t_to_jlong(n);
 447 JVM_END
 448 
 449 
 450 JVM_ENTRY_NO_ENV(jlong, JVM_FreeMemory(void))
 451   JVMWrapper("JVM_FreeMemory");
 452   CollectedHeap* ch = Universe::heap();
 453   size_t n;
 454   {
 455      MutexLocker x(Heap_lock);
 456      n = ch-&gt;capacity() - ch-&gt;used();
 457   }
 458   return convert_size_t_to_jlong(n);
 459 JVM_END
 460 
 461 
 462 JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))
 463   JVMWrapper("JVM_MaxMemory");
 464   size_t n = Universe::heap()-&gt;max_capacity();
 465   return convert_size_t_to_jlong(n);
 466 JVM_END
 467 
 468 
 469 JVM_ENTRY_NO_ENV(jint, JVM_ActiveProcessorCount(void))
 470   JVMWrapper("JVM_ActiveProcessorCount");
 471   return os::active_processor_count();
 472 JVM_END
 473 
 474 
 475 
 476 // java.lang.Throwable //////////////////////////////////////////////////////
 477 
 478 
 479 JVM_ENTRY(void, JVM_FillInStackTrace(JNIEnv *env, jobject receiver))
 480   JVMWrapper("JVM_FillInStackTrace");
 481   Handle exception(thread, JNIHandles::resolve_non_null(receiver));
 482   java_lang_Throwable::fill_in_stack_trace(exception);
 483 JVM_END
 484 
 485 
 486 JVM_ENTRY(jint, JVM_GetStackTraceDepth(JNIEnv *env, jobject throwable))
 487   JVMWrapper("JVM_GetStackTraceDepth");
 488   oop exception = JNIHandles::resolve(throwable);
 489   return java_lang_Throwable::get_stack_trace_depth(exception, THREAD);
 490 JVM_END
 491 
 492 
 493 JVM_ENTRY(jobject, JVM_GetStackTraceElement(JNIEnv *env, jobject throwable, jint index))
 494   JVMWrapper("JVM_GetStackTraceElement");
 495   JvmtiVMObjectAllocEventCollector oam; // This ctor (throughout this module) may trigger a safepoint/GC
 496   oop exception = JNIHandles::resolve(throwable);
 497   oop element = java_lang_Throwable::get_stack_trace_element(exception, index, CHECK_NULL);
 498   return JNIHandles::make_local(env, element);
 499 JVM_END
 500 
 501 
 502 // java.lang.Object ///////////////////////////////////////////////
 503 
 504 
 505 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
 506   JVMWrapper("JVM_IHashCode");
 507   // as implemented in the classic virtual machine; return 0 if object is NULL
 508   return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;
 509 JVM_END
 510 
 511 
 512 JVM_ENTRY(void, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))
 513   JVMWrapper("JVM_MonitorWait");
 514   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 515   JavaThreadInObjectWaitState jtiows(thread, ms != 0);
 516   if (JvmtiExport::should_post_monitor_wait()) {
 517     JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);
 518 
 519     // The current thread already owns the monitor and it has not yet
 520     // been added to the wait queue so the current thread cannot be
 521     // made the successor. This means that the JVMTI_EVENT_MONITOR_WAIT
 522     // event handler cannot accidentally consume an unpark() meant for
 523     // the ParkEvent associated with this ObjectMonitor.
 524   }
 525   ObjectSynchronizer::wait(obj, ms, CHECK);
 526 JVM_END
 527 
 528 
 529 JVM_ENTRY(void, JVM_MonitorNotify(JNIEnv* env, jobject handle))
 530   JVMWrapper("JVM_MonitorNotify");
 531   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 532   ObjectSynchronizer::notify(obj, CHECK);
 533 JVM_END
 534 
 535 
 536 JVM_ENTRY(void, JVM_MonitorNotifyAll(JNIEnv* env, jobject handle))
 537   JVMWrapper("JVM_MonitorNotifyAll");
 538   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 539   ObjectSynchronizer::notifyall(obj, CHECK);
 540 JVM_END
 541 
 542 
 543 JVM_ENTRY(jobject, JVM_Clone(JNIEnv* env, jobject handle))
 544   JVMWrapper("JVM_Clone");
 545   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 546   const KlassHandle klass (THREAD, obj-&gt;klass());
 547   JvmtiVMObjectAllocEventCollector oam;
 548 
 549 #ifdef ASSERT
 550   // Just checking that the cloneable flag is set correct
 551   if (obj-&gt;is_array()) {
 552     guarantee(klass-&gt;is_cloneable(), "all arrays are cloneable");
 553   } else {
 554     guarantee(obj-&gt;is_instance(), "should be instanceOop");
 555     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 556     guarantee(cloneable == klass-&gt;is_cloneable(), "incorrect cloneable flag");
 557   }
 558 #endif
 559 
 560   // Check if class of obj supports the Cloneable interface.
 561   // All arrays are considered to be cloneable (See JLS 20.1.5)
 562   if (!klass-&gt;is_cloneable()) {
 563     ResourceMark rm(THREAD);
 564     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 565   }
 566 
 567   // Make shallow object copy
 568   const int size = obj-&gt;size();
 569   oop new_obj = NULL;
 570   if (obj-&gt;is_array()) {
 571     const int length = ((arrayOop)obj())-&gt;length();
 572     new_obj = CollectedHeap::array_allocate(klass, size, length, CHECK_NULL);
 573   } else {
 574     new_obj = CollectedHeap::obj_allocate(klass, size, CHECK_NULL);
 575   }
 576   // 4839641 (4840070): We must do an oop-atomic copy, because if another thread
 577   // is modifying a reference field in the clonee, a non-oop-atomic copy might
 578   // be suspended in the middle of copying the pointer and end up with parts
 579   // of two different pointers in the field.  Subsequent dereferences will crash.
 580   // 4846409: an oop-copy of objects with long or double fields or arrays of same
 581   // won't copy the longs/doubles atomically in 32-bit vm's, so we copy jlongs instead
 582   // of oops.  We know objects are aligned on a minimum of an jlong boundary.
 583   // The same is true of StubRoutines::object_copy and the various oop_copy
 584   // variants, and of the code generated by the inline_native_clone intrinsic.
 585   assert(MinObjAlignmentInBytes &gt;= BytesPerLong, "objects misaligned");
 586   Copy::conjoint_jlongs_atomic((jlong*)obj(), (jlong*)new_obj,
 587                                (size_t)align_object_size(size) / HeapWordsPerLong);
 588   // Clear the header
 589   new_obj-&gt;init_mark();
 590 
 591   // Store check (mark entire object and let gc sort it out)
 592   BarrierSet* bs = Universe::heap()-&gt;barrier_set();
 593   assert(bs-&gt;has_write_region_opt(), "Barrier set does not have write_region");
 594   bs-&gt;write_region(MemRegion((HeapWord*)new_obj, size));
 595 
 596   // Caution: this involves a java upcall, so the clone should be
 597   // "gc-robust" by this stage.
 598   if (klass-&gt;has_finalizer()) {
 599     assert(obj-&gt;is_instance(), "should be instanceOop");
 600     new_obj = InstanceKlass::register_finalizer(instanceOop(new_obj), CHECK_NULL);
 601   }
 602 
 603   return JNIHandles::make_local(env, oop(new_obj));
 604 JVM_END
 605 
 606 // java.lang.Compiler ////////////////////////////////////////////////////
 607 
 608 // The initial cuts of the HotSpot VM will not support JITs, and all existing
 609 // JITs would need extensive changes to work with HotSpot.  The JIT-related JVM
 610 // functions are all silently ignored unless JVM warnings are printed.
 611 
 612 JVM_LEAF(void, JVM_InitializeCompiler (JNIEnv *env, jclass compCls))
 613   if (PrintJVMWarnings) warning("JVM_InitializeCompiler not supported");
 614 JVM_END
 615 
 616 
 617 JVM_LEAF(jboolean, JVM_IsSilentCompiler(JNIEnv *env, jclass compCls))
 618   if (PrintJVMWarnings) warning("JVM_IsSilentCompiler not supported");
 619   return JNI_FALSE;
 620 JVM_END
 621 
 622 
 623 JVM_LEAF(jboolean, JVM_CompileClass(JNIEnv *env, jclass compCls, jclass cls))
 624   if (PrintJVMWarnings) warning("JVM_CompileClass not supported");
 625   return JNI_FALSE;
 626 JVM_END
 627 
 628 
 629 JVM_LEAF(jboolean, JVM_CompileClasses(JNIEnv *env, jclass cls, jstring jname))
 630   if (PrintJVMWarnings) warning("JVM_CompileClasses not supported");
 631   return JNI_FALSE;
 632 JVM_END
 633 
 634 
 635 JVM_LEAF(jobject, JVM_CompilerCommand(JNIEnv *env, jclass compCls, jobject arg))
 636   if (PrintJVMWarnings) warning("JVM_CompilerCommand not supported");
 637   return NULL;
 638 JVM_END
 639 
 640 
 641 JVM_LEAF(void, JVM_EnableCompiler(JNIEnv *env, jclass compCls))
 642   if (PrintJVMWarnings) warning("JVM_EnableCompiler not supported");
 643 JVM_END
 644 
 645 
 646 JVM_LEAF(void, JVM_DisableCompiler(JNIEnv *env, jclass compCls))
 647   if (PrintJVMWarnings) warning("JVM_DisableCompiler not supported");
 648 JVM_END
 649 
 650 
 651 
 652 // Error message support //////////////////////////////////////////////////////
 653 
 654 JVM_LEAF(jint, JVM_GetLastErrorString(char *buf, int len))
 655   JVMWrapper("JVM_GetLastErrorString");
 656   return (jint)os::lasterror(buf, len);
 657 JVM_END
 658 
 659 
 660 // java.io.File ///////////////////////////////////////////////////////////////
 661 
 662 JVM_LEAF(char*, JVM_NativePath(char* path))
 663   JVMWrapper2("JVM_NativePath (%s)", path);
 664   return os::native_path(path);
 665 JVM_END
 666 
 667 
 668 // Misc. class handling ///////////////////////////////////////////////////////////
 669 
 670 
 671 JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env, int depth))
 672   JVMWrapper("JVM_GetCallerClass");
 673 
 674   // Pre-JDK 8 and early builds of JDK 8 don't have a CallerSensitive annotation; or
 675   // sun.reflect.Reflection.getCallerClass with a depth parameter is provided
 676   // temporarily for existing code to use until a replacement API is defined.
 677   if (SystemDictionary::reflect_CallerSensitive_klass() == NULL || depth != JVM_CALLER_DEPTH) {
 678     Klass* k = thread-&gt;security_get_caller_class(depth);
 679     return (k == NULL) ? NULL : (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 680   }
 681 
 682   // Getting the class of the caller frame.
 683   //
 684   // The call stack at this point looks something like this:
 685   //
 686   // [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ]
 687   // [1] [ @CallerSensitive API.method                                   ]
 688   // [.] [ (skipped intermediate frames)                                 ]
 689   // [n] [ caller                                                        ]
 690   vframeStream vfst(thread);
 691   // Cf. LibraryCallKit::inline_native_Reflection_getCallerClass
 692   for (int n = 0; !vfst.at_end(); vfst.security_next(), n++) {
 693     Method* m = vfst.method();
 694     assert(m != NULL, "sanity");
 695     switch (n) {
 696     case 0:
 697       // This must only be called from Reflection.getCallerClass
 698       if (m-&gt;intrinsic_id() != vmIntrinsics::_getCallerClass) {
 699         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), "JVM_GetCallerClass must only be called from Reflection.getCallerClass");
 700       }
 701       // fall-through
 702     case 1:
 703       // Frame 0 and 1 must be caller sensitive.
 704       if (!m-&gt;caller_sensitive()) {
 705         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg("CallerSensitive annotation expected at frame %d", n));
 706       }
 707       break;
 708     default:
 709       if (!m-&gt;is_ignored_by_security_stack_walk()) {
 710         // We have reached the desired frame; return the holder class.
 711         return (jclass) JNIHandles::make_local(env, m-&gt;method_holder()-&gt;java_mirror());
 712       }
 713       break;
 714     }
 715   }
 716   return NULL;
 717 JVM_END
 718 
 719 
 720 JVM_ENTRY(jclass, JVM_FindPrimitiveClass(JNIEnv* env, const char* utf))
 721   JVMWrapper("JVM_FindPrimitiveClass");
 722   oop mirror = NULL;
 723   BasicType t = name2type(utf);
 724   if (t != T_ILLEGAL &amp;&amp; t != T_OBJECT &amp;&amp; t != T_ARRAY) {
 725     mirror = Universe::java_mirror(t);
 726   }
 727   if (mirror == NULL) {
 728     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), (char*) utf);
 729   } else {
 730     return (jclass) JNIHandles::make_local(env, mirror);
 731   }
 732 JVM_END
 733 
 734 
 735 JVM_ENTRY(void, JVM_ResolveClass(JNIEnv* env, jclass cls))
 736   JVMWrapper("JVM_ResolveClass");
 737   if (PrintJVMWarnings) warning("JVM_ResolveClass not implemented");
 738 JVM_END
 739 
 740 
 741 // Returns a class loaded by the bootstrap class loader; or null
 742 // if not found.  ClassNotFoundException is not thrown.
 743 //
 744 // Rationale behind JVM_FindClassFromBootLoader
 745 // a&gt; JVM_FindClassFromClassLoader was never exported in the export tables.
 746 // b&gt; because of (a) java.dll has a direct dependecy on the  unexported
 747 //    private symbol "_JVM_FindClassFromClassLoader@20".
 748 // c&gt; the launcher cannot use the private symbol as it dynamically opens
 749 //    the entry point, so if something changes, the launcher will fail
 750 //    unexpectedly at runtime, it is safest for the launcher to dlopen a
 751 //    stable exported interface.
 752 // d&gt; re-exporting JVM_FindClassFromClassLoader as public, will cause its
 753 //    signature to change from _JVM_FindClassFromClassLoader@20 to
 754 //    JVM_FindClassFromClassLoader and will not be backward compatible
 755 //    with older JDKs.
 756 // Thus a public/stable exported entry point is the right solution,
 757 // public here means public in linker semantics, and is exported only
 758 // to the JDK, and is not intended to be a public API.
 759 
 760 JVM_ENTRY(jclass, JVM_FindClassFromBootLoader(JNIEnv* env,
 761                                               const char* name))
 762   JVMWrapper2("JVM_FindClassFromBootLoader %s", name);
 763 
 764   // Java libraries should ensure that name is never null...
 765   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 766     // It's impossible to create this class;  the name cannot fit
 767     // into the constant pool.
 768     return NULL;
 769   }
 770 
 771   TempNewSymbol h_name = SymbolTable::new_symbol(name, CHECK_NULL);
 772   Klass* k = SystemDictionary::resolve_or_null(h_name, CHECK_NULL);
 773   if (k == NULL) {
 774     return NULL;
 775   }
 776 
 777   if (TraceClassResolution) {
 778     trace_class_resolution(k);
 779   }
 780   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 781 JVM_END
 782 
 783 JVM_ENTRY(jclass, JVM_FindClassFromClassLoader(JNIEnv* env, const char* name,
 784                                                jboolean init, jobject loader,
 785                                                jboolean throwError))
 786   JVMWrapper3("JVM_FindClassFromClassLoader %s throw %s", name,
 787                throwError ? "error" : "exception");
 788   // Java libraries should ensure that name is never null...
 789   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 790     // It's impossible to create this class;  the name cannot fit
 791     // into the constant pool.
 792     if (throwError) {
 793       THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), name);
 794     } else {
 795       THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), name);
 796     }
 797   }
 798   TempNewSymbol h_name = SymbolTable::new_symbol(name, CHECK_NULL);
 799   Handle h_loader(THREAD, JNIHandles::resolve(loader));
 800   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 801                                                Handle(), throwError, THREAD);
 802 
 803   if (TraceClassResolution &amp;&amp; result != NULL) {
 804     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 805   }
 806   return result;
 807 JVM_END
 808 
 809 
 810 JVM_ENTRY(jclass, JVM_FindClassFromClass(JNIEnv *env, const char *name,
 811                                          jboolean init, jclass from))
 812   JVMWrapper2("JVM_FindClassFromClass %s", name);
 813   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 814     // It's impossible to create this class;  the name cannot fit
 815     // into the constant pool.
 816     THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), name);
 817   }
 818   TempNewSymbol h_name = SymbolTable::new_symbol(name, CHECK_NULL);
 819   oop from_class_oop = JNIHandles::resolve(from);
 820   Klass* from_class = (from_class_oop == NULL)
 821                            ? (Klass*)NULL
 822                            : java_lang_Class::as_Klass(from_class_oop);
 823   oop class_loader = NULL;
 824   oop protection_domain = NULL;
 825   if (from_class != NULL) {
 826     class_loader = from_class-&gt;class_loader();
 827     protection_domain = from_class-&gt;protection_domain();
 828   }
 829   Handle h_loader(THREAD, class_loader);
 830   Handle h_prot  (THREAD, protection_domain);
 831   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 832                                                h_prot, true, thread);
 833 
 834   if (TraceClassResolution &amp;&amp; result != NULL) {
 835     // this function is generally only used for class loading during verification.
 836     ResourceMark rm;
 837     oop from_mirror = JNIHandles::resolve_non_null(from);
 838     Klass* from_class = java_lang_Class::as_Klass(from_mirror);
 839     const char * from_name = from_class-&gt;external_name();
 840 
 841     oop mirror = JNIHandles::resolve_non_null(result);
 842     Klass* to_class = java_lang_Class::as_Klass(mirror);
 843     const char * to = to_class-&gt;external_name();
 844     tty-&gt;print("RESOLVE %s %s (verification)\n", from_name, to);
 845   }
 846 
 847   return result;
 848 JVM_END
 849 
 850 static void is_lock_held_by_thread(Handle loader, PerfCounter* counter, TRAPS) {
 851   if (loader.is_null()) {
 852     return;
 853   }
 854 
 855   // check whether the current caller thread holds the lock or not.
 856   // If not, increment the corresponding counter
 857   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader) !=
 858       ObjectSynchronizer::owner_self) {
 859     counter-&gt;inc();
 860   }
 861 }
 862 
 863 // common code for JVM_DefineClass() and JVM_DefineClassWithSource()
 864 // and JVM_DefineClassWithSourceCond()
 865 static jclass jvm_define_class_common(JNIEnv *env, const char *name,
 866                                       jobject loader, const jbyte *buf,
 867                                       jsize len, jobject pd, const char *source,
 868                                       jboolean verify, TRAPS) {
 869   if (source == NULL)  source = "__JVM_DefineClass__";
 870 
 871   assert(THREAD-&gt;is_Java_thread(), "must be a JavaThread");
 872   JavaThread* jt = (JavaThread*) THREAD;
 873 
 874   PerfClassTraceTime vmtimer(ClassLoader::perf_define_appclass_time(),
 875                              ClassLoader::perf_define_appclass_selftime(),
 876                              ClassLoader::perf_define_appclasses(),
 877                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 878                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 879                              PerfClassTraceTime::DEFINE_CLASS);
 880 
 881   if (UsePerfData) {
 882     ClassLoader::perf_app_classfile_bytes_read()-&gt;inc(len);
 883   }
 884 
 885   // Since exceptions can be thrown, class initialization can take place
 886   // if name is NULL no check for class name in .class stream has to be made.
 887   TempNewSymbol class_name = NULL;
 888   if (name != NULL) {
 889     const int str_len = (int)strlen(name);
 890     if (str_len &gt; Symbol::max_length()) {
 891       // It's impossible to create this class;  the name cannot fit
 892       // into the constant pool.
 893       THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), name);
 894     }
 895     class_name = SymbolTable::new_symbol(name, str_len, CHECK_NULL);
 896   }
 897 
 898   ResourceMark rm(THREAD);
 899   ClassFileStream st((u1*) buf, len, (char *)source);
 900   Handle class_loader (THREAD, JNIHandles::resolve(loader));
 901   if (UsePerfData) {
 902     is_lock_held_by_thread(class_loader,
 903                            ClassLoader::sync_JVMDefineClassLockFreeCounter(),
 904                            THREAD);
 905   }
 906   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
 907   Klass* k = SystemDictionary::resolve_from_stream(class_name, class_loader,
 908                                                      protection_domain, &amp;st,
 909                                                      verify != 0,
 910                                                      CHECK_NULL);
 911 
 912   if (TraceClassResolution &amp;&amp; k != NULL) {
 913     trace_class_resolution(k);
 914   }
 915 
 916   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 917 }
 918 
 919 
 920 JVM_ENTRY(jclass, JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd))
 921   JVMWrapper2("JVM_DefineClass %s", name);
 922 
 923   return jvm_define_class_common(env, name, loader, buf, len, pd, NULL, true, THREAD);
 924 JVM_END
 925 
 926 
 927 JVM_ENTRY(jclass, JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd, const char *source))
 928   JVMWrapper2("JVM_DefineClassWithSource %s", name);
 929 
 930   return jvm_define_class_common(env, name, loader, buf, len, pd, source, true, THREAD);
 931 JVM_END
 932 
 933 JVM_ENTRY(jclass, JVM_DefineClassWithSourceCond(JNIEnv *env, const char *name,
 934                                                 jobject loader, const jbyte *buf,
 935                                                 jsize len, jobject pd,
 936                                                 const char *source, jboolean verify))
 937   JVMWrapper2("JVM_DefineClassWithSourceCond %s", name);
 938 
 939   return jvm_define_class_common(env, name, loader, buf, len, pd, source, verify, THREAD);
 940 JVM_END
 941 
 942 JVM_ENTRY(jclass, JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name))
 943   JVMWrapper("JVM_FindLoadedClass");
 944   ResourceMark rm(THREAD);
 945 
 946   Handle h_name (THREAD, JNIHandles::resolve_non_null(name));
 947   Handle string = java_lang_String::internalize_classname(h_name, CHECK_NULL);
 948 
 949   const char* str   = java_lang_String::as_utf8_string(string());
 950   // Sanity check, don't expect null
 951   if (str == NULL) return NULL;
 952 
 953   const int str_len = (int)strlen(str);
 954   if (str_len &gt; Symbol::max_length()) {
 955     // It's impossible to create this class;  the name cannot fit
 956     // into the constant pool.
 957     return NULL;
 958   }
 959   TempNewSymbol klass_name = SymbolTable::new_symbol(str, str_len, CHECK_NULL);
 960 
 961   // Security Note:
 962   //   The Java level wrapper will perform the necessary security check allowing
 963   //   us to pass the NULL as the initiating class loader.
 964   Handle h_loader(THREAD, JNIHandles::resolve(loader));
 965   if (UsePerfData) {
 966     is_lock_held_by_thread(h_loader,
 967                            ClassLoader::sync_JVMFindLoadedClassLockFreeCounter(),
 968                            THREAD);
 969   }
 970 
 971   Klass* k = SystemDictionary::find_instance_or_array_klass(klass_name,
 972                                                               h_loader,
 973                                                               Handle(),
 974                                                               CHECK_NULL);
 975 
 976   return (k == NULL) ? NULL :
 977             (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 978 JVM_END
 979 
 980 
 981 // Reflection support //////////////////////////////////////////////////////////////////////////////
 982 
 983 JVM_ENTRY(jstring, JVM_GetClassName(JNIEnv *env, jclass cls))
 984   assert (cls != NULL, "illegal class");
 985   JVMWrapper("JVM_GetClassName");
 986   JvmtiVMObjectAllocEventCollector oam;
 987   ResourceMark rm(THREAD);
 988   const char* name;
 989   if (java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
 990     name = type2name(java_lang_Class::primitive_type(JNIHandles::resolve(cls)));
 991   } else {
 992     // Consider caching interned string in Klass
 993     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
 994     assert(k-&gt;is_klass(), "just checking");
 995     name = k-&gt;external_name();
 996   }
 997   oop result = StringTable::intern((char*) name, CHECK_NULL);
 998   return (jstring) JNIHandles::make_local(env, result);
 999 JVM_END
1000 
1001 
1002 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1003   JVMWrapper("JVM_GetClassInterfaces");
1004   JvmtiVMObjectAllocEventCollector oam;
1005   oop mirror = JNIHandles::resolve_non_null(cls);
1006 
1007   // Special handling for primitive objects
1008   if (java_lang_Class::is_primitive(mirror)) {
1009     // Primitive objects does not have any interfaces
1010     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1011     return (jobjectArray) JNIHandles::make_local(env, r);
1012   }
1013 
1014   KlassHandle klass(thread, java_lang_Class::as_Klass(mirror));
1015   // Figure size of result array
1016   int size;
1017   if (klass-&gt;oop_is_instance()) {
1018     size = InstanceKlass::cast(klass())-&gt;local_interfaces()-&gt;length();
1019   } else {
1020     assert(klass-&gt;oop_is_objArray() || klass-&gt;oop_is_typeArray(), "Illegal mirror klass");
1021     size = 2;
1022   }
1023 
1024   // Allocate result array
1025   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1026   objArrayHandle result (THREAD, r);
1027   // Fill in result
1028   if (klass-&gt;oop_is_instance()) {
1029     // Regular instance klass, fill in all local interfaces
1030     for (int index = 0; index &lt; size; index++) {
1031       Klass* k = InstanceKlass::cast(klass())-&gt;local_interfaces()-&gt;at(index);
1032       result-&gt;obj_at_put(index, k-&gt;java_mirror());
1033     }
1034   } else {
1035     // All arrays implement java.lang.Cloneable and java.io.Serializable
1036     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1037     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
1038   }
1039   return (jobjectArray) JNIHandles::make_local(env, result());
1040 JVM_END
1041 
1042 
1043 JVM_ENTRY(jobject, JVM_GetClassLoader(JNIEnv *env, jclass cls))
1044   JVMWrapper("JVM_GetClassLoader");
1045   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1046     return NULL;
1047   }
1048   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1049   oop loader = k-&gt;class_loader();
1050   return JNIHandles::make_local(env, loader);
1051 JVM_END
1052 
1053 
1054 JVM_QUICK_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1055   JVMWrapper("JVM_IsInterface");
1056   oop mirror = JNIHandles::resolve_non_null(cls);
1057   if (java_lang_Class::is_primitive(mirror)) {
1058     return JNI_FALSE;
1059   }
1060   Klass* k = java_lang_Class::as_Klass(mirror);
1061   jboolean result = k-&gt;is_interface();
1062   assert(!result || k-&gt;oop_is_instance(),
1063          "all interfaces are instance types");
1064   // The compiler intrinsic for isInterface tests the
1065   // Klass::_access_flags bits in the same way.
1066   return result;
1067 JVM_END
1068 
1069 
1070 JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))
1071   JVMWrapper("JVM_GetClassSigners");
1072   JvmtiVMObjectAllocEventCollector oam;
1073   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1074     // There are no signers for primitive types
1075     return NULL;
1076   }
1077 
1078   objArrayOop signers = java_lang_Class::signers(JNIHandles::resolve_non_null(cls));
1079 
1080   // If there are no signers set in the class, or if the class
1081   // is an array, return NULL.
1082   if (signers == NULL) return NULL;
1083 
1084   // copy of the signers array
1085   Klass* element = ObjArrayKlass::cast(signers-&gt;klass())-&gt;element_klass();
1086   objArrayOop signers_copy = oopFactory::new_objArray(element, signers-&gt;length(), CHECK_NULL);
1087   for (int index = 0; index &lt; signers-&gt;length(); index++) {
1088     signers_copy-&gt;obj_at_put(index, signers-&gt;obj_at(index));
1089   }
1090 
1091   // return the copy
1092   return (jobjectArray) JNIHandles::make_local(env, signers_copy);
1093 JVM_END
1094 
1095 
1096 JVM_ENTRY(void, JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers))
1097   JVMWrapper("JVM_SetClassSigners");
1098   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1099     // This call is ignored for primitive types and arrays.
1100     // Signers are only set once, ClassLoader.java, and thus shouldn't
1101     // be called with an array.  Only the bootstrap loader creates arrays.
1102     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1103     if (k-&gt;oop_is_instance()) {
1104       java_lang_Class::set_signers(k-&gt;java_mirror(), objArrayOop(JNIHandles::resolve(signers)));
1105     }
1106   }
1107 JVM_END
1108 
1109 
1110 JVM_ENTRY(jobject, JVM_GetProtectionDomain(JNIEnv *env, jclass cls))
1111   JVMWrapper("JVM_GetProtectionDomain");
1112   if (JNIHandles::resolve(cls) == NULL) {
1113     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
1114   }
1115 
1116   if (java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1117     // Primitive types does not have a protection domain.
1118     return NULL;
1119   }
1120 
1121   oop pd = java_lang_Class::protection_domain(JNIHandles::resolve(cls));
1122   return (jobject) JNIHandles::make_local(env, pd);
1123 JVM_END
1124 
1125 
1126 static bool is_authorized(Handle context, instanceKlassHandle klass, TRAPS) {
1127   // If there is a security manager and protection domain, check the access
1128   // in the protection domain, otherwise it is authorized.
1129   if (java_lang_System::has_security_manager()) {
1130 
1131     // For bootstrapping, if pd implies method isn't in the JDK, allow
1132     // this context to revert to older behavior.
1133     // In this case the isAuthorized field in AccessControlContext is also not
1134     // present.
1135     if (Universe::protection_domain_implies_method() == NULL) {
1136       return true;
1137     }
1138 
1139     // Whitelist certain access control contexts
1140     if (java_security_AccessControlContext::is_authorized(context)) {
1141       return true;
1142     }
1143 
1144     oop prot = klass-&gt;protection_domain();
1145     if (prot != NULL) {
1146       // Call pd.implies(new SecurityPermission("createAccessControlContext"))
1147       // in the new wrapper.
1148       methodHandle m(THREAD, Universe::protection_domain_implies_method());
1149       Handle h_prot(THREAD, prot);
1150       JavaValue result(T_BOOLEAN);
1151       JavaCallArguments args(h_prot);
1152       JavaCalls::call(&amp;result, m, &amp;args, CHECK_false);
1153       return (result.get_jboolean() != 0);
1154     }
1155   }
1156   return true;
1157 }
1158 
1159 // Create an AccessControlContext with a protection domain with null codesource
1160 // and null permissions - which gives no permissions.
1161 oop create_dummy_access_control_context(TRAPS) {
1162   InstanceKlass* pd_klass = InstanceKlass::cast(SystemDictionary::ProtectionDomain_klass());
1163   Handle obj = pd_klass-&gt;allocate_instance_handle(CHECK_NULL);
1164   // Call constructor ProtectionDomain(null, null);
1165   JavaValue result(T_VOID);
1166   JavaCalls::call_special(&amp;result, obj, KlassHandle(THREAD, pd_klass),
1167                           vmSymbols::object_initializer_name(),
1168                           vmSymbols::codesource_permissioncollection_signature(),
1169                           Handle(), Handle(), CHECK_NULL);
1170 
1171   // new ProtectionDomain[] {pd};
1172   objArrayOop context = oopFactory::new_objArray(pd_klass, 1, CHECK_NULL);
1173   context-&gt;obj_at_put(0, obj());
1174 
1175   // new AccessControlContext(new ProtectionDomain[] {pd})
1176   objArrayHandle h_context(THREAD, context);
1177   oop acc = java_security_AccessControlContext::create(h_context, false, Handle(), CHECK_NULL);
1178   return acc;
1179 }
1180 
1181 JVM_ENTRY(jobject, JVM_DoPrivileged(JNIEnv *env, jclass cls, jobject action, jobject context, jboolean wrapException))
1182   JVMWrapper("JVM_DoPrivileged");
1183 
1184   if (action == NULL) {
1185     THROW_MSG_0(vmSymbols::java_lang_NullPointerException(), "Null action");
1186   }
1187 
1188   // Compute the frame initiating the do privileged operation and setup the privileged stack
1189   vframeStream vfst(thread);
1190   vfst.security_get_caller_frame(1);
1191 
1192   if (vfst.at_end()) {
1193     THROW_MSG_0(vmSymbols::java_lang_InternalError(), "no caller?");
1194   }
1195 
1196   Method* method        = vfst.method();
1197   instanceKlassHandle klass (THREAD, method-&gt;method_holder());
1198 
1199   // Check that action object understands "Object run()"
1200   Handle h_context;
1201   if (context != NULL) {
1202     h_context = Handle(THREAD, JNIHandles::resolve(context));
1203     bool authorized = is_authorized(h_context, klass, CHECK_NULL);
1204     if (!authorized) {
1205       // Create an unprivileged access control object and call it's run function
1206       // instead.
1207       oop noprivs = create_dummy_access_control_context(CHECK_NULL);
1208       h_context = Handle(THREAD, noprivs);
1209     }
1210   }
1211 
1212   // Check that action object understands "Object run()"
1213   Handle object (THREAD, JNIHandles::resolve(action));
1214 
1215   // get run() method
1216   Method* m_oop = object-&gt;klass()-&gt;uncached_lookup_method(
1217                                            vmSymbols::run_method_name(),
1218                                            vmSymbols::void_object_signature(),
1219                                            Klass::normal);
1220   methodHandle m (THREAD, m_oop);
1221   if (m.is_null() || !m-&gt;is_method() || !m()-&gt;is_public() || m()-&gt;is_static()) {
1222     THROW_MSG_0(vmSymbols::java_lang_InternalError(), "No run method");
1223   }
1224 
1225   // Stack allocated list of privileged stack elements
1226   PrivilegedElement pi;
1227   if (!vfst.at_end()) {
1228     pi.initialize(&amp;vfst, h_context(), thread-&gt;privileged_stack_top(), CHECK_NULL);
1229     thread-&gt;set_privileged_stack_top(&amp;pi);
1230   }
1231 
1232 
1233   // invoke the Object run() in the action object. We cannot use call_interface here, since the static type
1234   // is not really known - it is either java.security.PrivilegedAction or java.security.PrivilegedExceptionAction
1235   Handle pending_exception;
1236   JavaValue result(T_OBJECT);
1237   JavaCallArguments args(object);
1238   JavaCalls::call(&amp;result, m, &amp;args, THREAD);
1239 
1240   // done with action, remove ourselves from the list
1241   if (!vfst.at_end()) {
1242     assert(thread-&gt;privileged_stack_top() != NULL &amp;&amp; thread-&gt;privileged_stack_top() == &amp;pi, "wrong top element");
1243     thread-&gt;set_privileged_stack_top(thread-&gt;privileged_stack_top()-&gt;next());
1244   }
1245 
1246   if (HAS_PENDING_EXCEPTION) {
1247     pending_exception = Handle(THREAD, PENDING_EXCEPTION);
1248     CLEAR_PENDING_EXCEPTION;
1249     // JVMTI has already reported the pending exception
1250     // JVMTI internal flag reset is needed in order to report PrivilegedActionException
1251     if (THREAD-&gt;is_Java_thread()) {
1252       JvmtiExport::clear_detected_exception((JavaThread*) THREAD);
1253     }
1254     if ( pending_exception-&gt;is_a(SystemDictionary::Exception_klass()) &amp;&amp;
1255         !pending_exception-&gt;is_a(SystemDictionary::RuntimeException_klass())) {
1256       // Throw a java.security.PrivilegedActionException(Exception e) exception
1257       JavaCallArguments args(pending_exception);
1258       THROW_ARG_0(vmSymbols::java_security_PrivilegedActionException(),
1259                   vmSymbols::exception_void_signature(),
1260                   &amp;args);
1261     }
1262   }
1263 
1264   if (pending_exception.not_null()) THROW_OOP_0(pending_exception());
1265   return JNIHandles::make_local(env, (oop) result.get_jobject());
1266 JVM_END
1267 
1268 
1269 // Returns the inherited_access_control_context field of the running thread.
1270 JVM_ENTRY(jobject, JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls))
1271   JVMWrapper("JVM_GetInheritedAccessControlContext");
1272   oop result = java_lang_Thread::inherited_access_control_context(thread-&gt;threadObj());
1273   return JNIHandles::make_local(env, result);
1274 JVM_END
1275 
1276 class RegisterArrayForGC {
1277  private:
1278   JavaThread *_thread;
1279  public:
1280   RegisterArrayForGC(JavaThread *thread, GrowableArray&lt;oop&gt;* array)  {
1281     _thread = thread;
1282     _thread-&gt;register_array_for_gc(array);
1283   }
1284 
1285   ~RegisterArrayForGC() {
1286     _thread-&gt;register_array_for_gc(NULL);
1287   }
1288 };
1289 
1290 
1291 JVM_ENTRY(jobject, JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls))
1292   JVMWrapper("JVM_GetStackAccessControlContext");
1293   if (!UsePrivilegedStack) return NULL;
1294 
1295   ResourceMark rm(THREAD);
1296   GrowableArray&lt;oop&gt;* local_array = new GrowableArray&lt;oop&gt;(12);
1297   JvmtiVMObjectAllocEventCollector oam;
1298 
1299   // count the protection domains on the execution stack. We collapse
1300   // duplicate consecutive protection domains into a single one, as
1301   // well as stopping when we hit a privileged frame.
1302 
1303   // Use vframeStream to iterate through Java frames
1304   vframeStream vfst(thread);
1305 
1306   oop previous_protection_domain = NULL;
1307   Handle privileged_context(thread, NULL);
1308   bool is_privileged = false;
1309   oop protection_domain = NULL;
1310 
1311   for(; !vfst.at_end(); vfst.next()) {
1312     // get method of frame
1313     Method* method = vfst.method();
1314     intptr_t* frame_id   = vfst.frame_id();
1315 
1316     // check the privileged frames to see if we have a match
1317     if (thread-&gt;privileged_stack_top() &amp;&amp; thread-&gt;privileged_stack_top()-&gt;frame_id() == frame_id) {
1318       // this frame is privileged
1319       is_privileged = true;
1320       privileged_context = Handle(thread, thread-&gt;privileged_stack_top()-&gt;privileged_context());
1321       protection_domain  = thread-&gt;privileged_stack_top()-&gt;protection_domain();
1322     } else {
1323       protection_domain = method-&gt;method_holder()-&gt;protection_domain();
1324     }
1325 
1326     if ((previous_protection_domain != protection_domain) &amp;&amp; (protection_domain != NULL)) {
1327       local_array-&gt;push(protection_domain);
1328       previous_protection_domain = protection_domain;
1329     }
1330 
1331     if (is_privileged) break;
1332   }
1333 
1334 
1335   // either all the domains on the stack were system domains, or
1336   // we had a privileged system domain
1337   if (local_array-&gt;is_empty()) {
1338     if (is_privileged &amp;&amp; privileged_context.is_null()) return NULL;
1339 
1340     oop result = java_security_AccessControlContext::create(objArrayHandle(), is_privileged, privileged_context, CHECK_NULL);
1341     return JNIHandles::make_local(env, result);
1342   }
1343 
1344   // the resource area must be registered in case of a gc
1345   RegisterArrayForGC ragc(thread, local_array);
1346   objArrayOop context = oopFactory::new_objArray(SystemDictionary::ProtectionDomain_klass(),
1347                                                  local_array-&gt;length(), CHECK_NULL);
1348   objArrayHandle h_context(thread, context);
1349   for (int index = 0; index &lt; local_array-&gt;length(); index++) {
1350     h_context-&gt;obj_at_put(index, local_array-&gt;at(index));
1351   }
1352 
1353   oop result = java_security_AccessControlContext::create(h_context, is_privileged, privileged_context, CHECK_NULL);
1354 
1355   return JNIHandles::make_local(env, result);
1356 JVM_END
1357 
1358 
1359 JVM_QUICK_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))
1360   JVMWrapper("JVM_IsArrayClass");
1361   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1362   return (k != NULL) &amp;&amp; k-&gt;oop_is_array() ? true : false;
1363 JVM_END
1364 
1365 
1366 JVM_QUICK_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))
1367   JVMWrapper("JVM_IsPrimitiveClass");
1368   oop mirror = JNIHandles::resolve_non_null(cls);
1369   return (jboolean) java_lang_Class::is_primitive(mirror);
1370 JVM_END
1371 
1372 
1373 JVM_ENTRY(jclass, JVM_GetComponentType(JNIEnv *env, jclass cls))
1374   JVMWrapper("JVM_GetComponentType");
1375   oop mirror = JNIHandles::resolve_non_null(cls);
1376   oop result = Reflection::array_component_type(mirror, CHECK_NULL);
1377   return (jclass) JNIHandles::make_local(env, result);
1378 JVM_END
1379 
1380 
1381 JVM_ENTRY(jint, JVM_GetClassModifiers(JNIEnv *env, jclass cls))
1382   JVMWrapper("JVM_GetClassModifiers");
1383   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1384     // Primitive type
1385     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1386   }
1387 
1388   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1389   debug_only(int computed_modifiers = k-&gt;compute_modifier_flags(CHECK_0));
1390   assert(k-&gt;modifier_flags() == computed_modifiers, "modifiers cache is OK");
1391   return k-&gt;modifier_flags();
1392 JVM_END
1393 
1394 
1395 // Inner class reflection ///////////////////////////////////////////////////////////////////////////////
1396 
1397 JVM_ENTRY(jobjectArray, JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass))
1398   JvmtiVMObjectAllocEventCollector oam;
1399   // ofClass is a reference to a java_lang_Class object. The mirror object
1400   // of an InstanceKlass
1401 
1402   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1403       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;oop_is_instance()) {
1404     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1405     return (jobjectArray)JNIHandles::make_local(env, result);
1406   }
1407 
1408   instanceKlassHandle k(thread, java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1409   InnerClassesIterator iter(k);
1410 
1411   if (iter.length() == 0) {
1412     // Neither an inner nor outer class
1413     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1414     return (jobjectArray)JNIHandles::make_local(env, result);
1415   }
1416 
1417   // find inner class info
1418   constantPoolHandle cp(thread, k-&gt;constants());
1419   int length = iter.length();
1420 
1421   // Allocate temp. result array
1422   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), length/4, CHECK_NULL);
1423   objArrayHandle result (THREAD, r);
1424   int members = 0;
1425 
1426   for (; !iter.done(); iter.next()) {
1427     int ioff = iter.inner_class_info_index();
1428     int ooff = iter.outer_class_info_index();
1429 
1430     if (ioff != 0 &amp;&amp; ooff != 0) {
1431       // Check to see if the name matches the class we're looking for
1432       // before attempting to find the class.
1433       if (cp-&gt;klass_name_at_matches(k, ooff)) {
1434         Klass* outer_klass = cp-&gt;klass_at(ooff, CHECK_NULL);
1435         if (outer_klass == k()) {
1436            Klass* ik = cp-&gt;klass_at(ioff, CHECK_NULL);
1437            instanceKlassHandle inner_klass (THREAD, ik);
1438 
1439            // Throws an exception if outer klass has not declared k as
1440            // an inner klass
1441            Reflection::check_for_inner_class(k, inner_klass, true, CHECK_NULL);
1442 
1443            result-&gt;obj_at_put(members, inner_klass-&gt;java_mirror());
1444            members++;
1445         }
1446       }
1447     }
1448   }
1449 
1450   if (members != length) {
1451     // Return array of right length
1452     objArrayOop res = oopFactory::new_objArray(SystemDictionary::Class_klass(), members, CHECK_NULL);
1453     for(int i = 0; i &lt; members; i++) {
1454       res-&gt;obj_at_put(i, result-&gt;obj_at(i));
1455     }
1456     return (jobjectArray)JNIHandles::make_local(env, res);
1457   }
1458 
1459   return (jobjectArray)JNIHandles::make_local(env, result());
1460 JVM_END
1461 
1462 
1463 JVM_ENTRY(jclass, JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass))
1464 {
1465   // ofClass is a reference to a java_lang_Class object.
1466   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1467       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;oop_is_instance()) {
1468     return NULL;
1469   }
1470 
1471   bool inner_is_member = false;
1472   Klass* outer_klass
1473     = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))
1474                           )-&gt;compute_enclosing_class(&amp;inner_is_member, CHECK_NULL);
1475   if (outer_klass == NULL)  return NULL;  // already a top-level class
1476   if (!inner_is_member)  return NULL;     // an anonymous class (inside a method)
1477   return (jclass) JNIHandles::make_local(env, outer_klass-&gt;java_mirror());
1478 }
1479 JVM_END
1480 
1481 // should be in InstanceKlass.cpp, but is here for historical reasons
1482 Klass* InstanceKlass::compute_enclosing_class_impl(instanceKlassHandle k,
1483                                                      bool* inner_is_member,
1484                                                      TRAPS) {
1485   Thread* thread = THREAD;
1486   InnerClassesIterator iter(k);
1487   if (iter.length() == 0) {
1488     // No inner class info =&gt; no declaring class
1489     return NULL;
1490   }
1491 
1492   constantPoolHandle i_cp(thread, k-&gt;constants());
1493 
1494   bool found = false;
1495   Klass* ok;
1496   instanceKlassHandle outer_klass;
1497   *inner_is_member = false;
1498 
1499   // Find inner_klass attribute
1500   for (; !iter.done() &amp;&amp; !found; iter.next()) {
1501     int ioff = iter.inner_class_info_index();
1502     int ooff = iter.outer_class_info_index();
1503     int noff = iter.inner_name_index();
1504     if (ioff != 0) {
1505       // Check to see if the name matches the class we're looking for
1506       // before attempting to find the class.
1507       if (i_cp-&gt;klass_name_at_matches(k, ioff)) {
1508         Klass* inner_klass = i_cp-&gt;klass_at(ioff, CHECK_NULL);
1509         found = (k() == inner_klass);
1510         if (found &amp;&amp; ooff != 0) {
1511           ok = i_cp-&gt;klass_at(ooff, CHECK_NULL);
1512           outer_klass = instanceKlassHandle(thread, ok);
1513           *inner_is_member = true;
1514         }
1515       }
1516     }
1517   }
1518 
1519   if (found &amp;&amp; outer_klass.is_null()) {
1520     // It may be anonymous; try for that.
1521     int encl_method_class_idx = k-&gt;enclosing_method_class_index();
1522     if (encl_method_class_idx != 0) {
1523       ok = i_cp-&gt;klass_at(encl_method_class_idx, CHECK_NULL);
1524       outer_klass = instanceKlassHandle(thread, ok);
1525       *inner_is_member = false;
1526     }
1527   }
1528 
1529   // If no inner class attribute found for this class.
1530   if (outer_klass.is_null())  return NULL;
1531 
1532   // Throws an exception if outer klass has not declared k as an inner klass
1533   // We need evidence that each klass knows about the other, or else
1534   // the system could allow a spoof of an inner class to gain access rights.
1535   Reflection::check_for_inner_class(outer_klass, k, *inner_is_member, CHECK_NULL);
1536   return outer_klass();
1537 }
1538 
1539 JVM_ENTRY(jstring, JVM_GetClassSignature(JNIEnv *env, jclass cls))
1540   assert (cls != NULL, "illegal class");
1541   JVMWrapper("JVM_GetClassSignature");
1542   JvmtiVMObjectAllocEventCollector oam;
1543   ResourceMark rm(THREAD);
1544   // Return null for arrays and primatives
1545   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1546     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1547     if (k-&gt;oop_is_instance()) {
1548       Symbol* sym = InstanceKlass::cast(k)-&gt;generic_signature();
1549       if (sym == NULL) return NULL;
1550       Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
1551       return (jstring) JNIHandles::make_local(env, str());
1552     }
1553   }
1554   return NULL;
1555 JVM_END
1556 
1557 
1558 JVM_ENTRY(jbyteArray, JVM_GetClassAnnotations(JNIEnv *env, jclass cls))
1559   assert (cls != NULL, "illegal class");
1560   JVMWrapper("JVM_GetClassAnnotations");
1561 
1562   // Return null for arrays and primitives
1563   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1564     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1565     if (k-&gt;oop_is_instance()) {
1566       typeArrayOop a = Annotations::make_java_array(InstanceKlass::cast(k)-&gt;class_annotations(), CHECK_NULL);
1567       return (jbyteArray) JNIHandles::make_local(env, a);
1568     }
1569   }
1570   return NULL;
1571 JVM_END
1572 
1573 
1574 static bool jvm_get_field_common(jobject field, fieldDescriptor&amp; fd, TRAPS) {
1575   // some of this code was adapted from from jni_FromReflectedField
1576 
1577   oop reflected = JNIHandles::resolve_non_null(field);
1578   oop mirror    = java_lang_reflect_Field::clazz(reflected);
1579   Klass* k    = java_lang_Class::as_Klass(mirror);
1580   int slot      = java_lang_reflect_Field::slot(reflected);
1581   int modifiers = java_lang_reflect_Field::modifiers(reflected);
1582 
1583   KlassHandle kh(THREAD, k);
1584   intptr_t offset = InstanceKlass::cast(kh())-&gt;field_offset(slot);
1585 
1586   if (modifiers &amp; JVM_ACC_STATIC) {
1587     // for static fields we only look in the current class
1588     if (!InstanceKlass::cast(kh())-&gt;find_local_field_from_offset(offset, true, &amp;fd)) {
1589       assert(false, "cannot find static field");
1590       return false;
1591     }
1592   } else {
1593     // for instance fields we start with the current class and work
1594     // our way up through the superclass chain
1595     if (!InstanceKlass::cast(kh())-&gt;find_field_from_offset(offset, false, &amp;fd)) {
1596       assert(false, "cannot find instance field");
1597       return false;
1598     }
1599   }
1600   return true;
1601 }
1602 
1603 JVM_ENTRY(jbyteArray, JVM_GetFieldAnnotations(JNIEnv *env, jobject field))
1604   // field is a handle to a java.lang.reflect.Field object
1605   assert(field != NULL, "illegal field");
1606   JVMWrapper("JVM_GetFieldAnnotations");
1607 
1608   fieldDescriptor fd;
1609   bool gotFd = jvm_get_field_common(field, fd, CHECK_NULL);
1610   if (!gotFd) {
1611     return NULL;
1612   }
1613 
1614   return (jbyteArray) JNIHandles::make_local(env, Annotations::make_java_array(fd.annotations(), THREAD));
1615 JVM_END
1616 
1617 
1618 static Method* jvm_get_method_common(jobject method) {
1619   // some of this code was adapted from from jni_FromReflectedMethod
1620 
1621   oop reflected = JNIHandles::resolve_non_null(method);
1622   oop mirror    = NULL;
1623   int slot      = 0;
1624 
1625   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
1626     mirror = java_lang_reflect_Constructor::clazz(reflected);
1627     slot   = java_lang_reflect_Constructor::slot(reflected);
1628   } else {
1629     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(),
1630            "wrong type");
1631     mirror = java_lang_reflect_Method::clazz(reflected);
1632     slot   = java_lang_reflect_Method::slot(reflected);
1633   }
1634   Klass* k = java_lang_Class::as_Klass(mirror);
1635 
1636   Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
1637   assert(m != NULL, "cannot find method");
1638   return m;  // caller has to deal with NULL in product mode
1639 }
1640 
1641 
1642 JVM_ENTRY(jbyteArray, JVM_GetMethodAnnotations(JNIEnv *env, jobject method))
1643   JVMWrapper("JVM_GetMethodAnnotations");
1644 
1645   // method is a handle to a java.lang.reflect.Method object
1646   Method* m = jvm_get_method_common(method);
1647   if (m == NULL) {
1648     return NULL;
1649   }
1650 
1651   return (jbyteArray) JNIHandles::make_local(env,
1652     Annotations::make_java_array(m-&gt;annotations(), THREAD));
1653 JVM_END
1654 
1655 
1656 JVM_ENTRY(jbyteArray, JVM_GetMethodDefaultAnnotationValue(JNIEnv *env, jobject method))
1657   JVMWrapper("JVM_GetMethodDefaultAnnotationValue");
1658 
1659   // method is a handle to a java.lang.reflect.Method object
1660   Method* m = jvm_get_method_common(method);
1661   if (m == NULL) {
1662     return NULL;
1663   }
1664 
1665   return (jbyteArray) JNIHandles::make_local(env,
1666     Annotations::make_java_array(m-&gt;annotation_default(), THREAD));
1667 JVM_END
1668 
1669 
1670 JVM_ENTRY(jbyteArray, JVM_GetMethodParameterAnnotations(JNIEnv *env, jobject method))
1671   JVMWrapper("JVM_GetMethodParameterAnnotations");
1672 
1673   // method is a handle to a java.lang.reflect.Method object
1674   Method* m = jvm_get_method_common(method);
1675   if (m == NULL) {
1676     return NULL;
1677   }
1678 
1679   return (jbyteArray) JNIHandles::make_local(env,
1680     Annotations::make_java_array(m-&gt;parameter_annotations(), THREAD));
1681 JVM_END
1682 
1683 /* Type use annotations support (JDK 1.8) */
1684 
1685 JVM_ENTRY(jbyteArray, JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls))
1686   assert (cls != NULL, "illegal class");
1687   JVMWrapper("JVM_GetClassTypeAnnotations");
1688   ResourceMark rm(THREAD);
1689   // Return null for arrays and primitives
1690   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1691     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1692     if (k-&gt;oop_is_instance()) {
1693       AnnotationArray* type_annotations = InstanceKlass::cast(k)-&gt;class_type_annotations();
1694       if (type_annotations != NULL) {
1695         typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1696         return (jbyteArray) JNIHandles::make_local(env, a);
1697       }
1698     }
1699   }
1700   return NULL;
1701 JVM_END
1702 
1703 JVM_ENTRY(jbyteArray, JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method))
1704   assert (method != NULL, "illegal method");
1705   JVMWrapper("JVM_GetMethodTypeAnnotations");
1706 
1707   // method is a handle to a java.lang.reflect.Method object
1708   Method* m = jvm_get_method_common(method);
1709   if (m == NULL) {
1710     return NULL;
1711   }
1712 
1713   AnnotationArray* type_annotations = m-&gt;type_annotations();
1714   if (type_annotations != NULL) {
1715     typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1716     return (jbyteArray) JNIHandles::make_local(env, a);
1717   }
1718 
1719   return NULL;
1720 JVM_END
1721 
1722 JVM_ENTRY(jbyteArray, JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field))
1723   assert (field != NULL, "illegal field");
1724   JVMWrapper("JVM_GetFieldTypeAnnotations");
1725 
1726   fieldDescriptor fd;
1727   bool gotFd = jvm_get_field_common(field, fd, CHECK_NULL);
1728   if (!gotFd) {
1729     return NULL;
1730   }
1731 
1732   return (jbyteArray) JNIHandles::make_local(env, Annotations::make_java_array(fd.type_annotations(), THREAD));
1733 JVM_END
1734 
1735 static void bounds_check(constantPoolHandle cp, jint index, TRAPS) {
1736   if (!cp-&gt;is_within_bounds(index)) {
1737     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), "Constant pool index out of bounds");
1738   }
1739 }
1740 
1741 JVM_ENTRY(jobjectArray, JVM_GetMethodParameters(JNIEnv *env, jobject method))
1742 {
1743   JVMWrapper("JVM_GetMethodParameters");
1744   // method is a handle to a java.lang.reflect.Method object
1745   Method* method_ptr = jvm_get_method_common(method);
1746   methodHandle mh (THREAD, method_ptr);
1747   Handle reflected_method (THREAD, JNIHandles::resolve_non_null(method));
1748   const int num_params = mh-&gt;method_parameters_length();
1749 
1750   if (0 != num_params) {
1751     // make sure all the symbols are properly formatted
1752     for (int i = 0; i &lt; num_params; i++) {
1753       MethodParametersElement* params = mh-&gt;method_parameters_start();
1754       int index = params[i].name_cp_index;
1755       bounds_check(mh-&gt;constants(), index, CHECK_NULL);
1756 
1757       if (0 != index &amp;&amp; !mh-&gt;constants()-&gt;tag_at(index).is_utf8()) {
1758         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1759                     "Wrong type at constant pool index");
1760       }
1761 
1762     }
1763 
1764     objArrayOop result_oop = oopFactory::new_objArray(SystemDictionary::reflect_Parameter_klass(), num_params, CHECK_NULL);
1765     objArrayHandle result (THREAD, result_oop);
1766 
1767     for (int i = 0; i &lt; num_params; i++) {
1768       MethodParametersElement* params = mh-&gt;method_parameters_start();
1769       // For a 0 index, give a NULL symbol
1770       Symbol* sym = 0 != params[i].name_cp_index ?
1771         mh-&gt;constants()-&gt;symbol_at(params[i].name_cp_index) : NULL;
1772       int flags = params[i].flags;
1773       oop param = Reflection::new_parameter(reflected_method, i, sym,
1774                                             flags, CHECK_NULL);
1775       result-&gt;obj_at_put(i, param);
1776     }
1777     return (jobjectArray)JNIHandles::make_local(env, result());
1778   } else {
1779     return (jobjectArray)NULL;
1780   }
1781 }
1782 JVM_END
1783 
1784 // New (JDK 1.4) reflection implementation /////////////////////////////////////
1785 
1786 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1787 {
1788   JVMWrapper("JVM_GetClassDeclaredFields");
1789   JvmtiVMObjectAllocEventCollector oam;
1790 
1791   // Exclude primitive types and array types
1792   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1793       java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;oop_is_array()) {
1794     // Return empty array
1795     oop res = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), 0, CHECK_NULL);
1796     return (jobjectArray) JNIHandles::make_local(env, res);
1797   }
1798 
1799   instanceKlassHandle k(THREAD, java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1800   constantPoolHandle cp(THREAD, k-&gt;constants());
1801 
1802   // Ensure class is linked
1803   k-&gt;link_class(CHECK_NULL);
1804 
1805   // 4496456 We need to filter out java.lang.Throwable.backtrace
1806   bool skip_backtrace = false;
1807 
1808   // Allocate result
1809   int num_fields;
1810 
1811   if (publicOnly) {
1812     num_fields = 0;
1813     for (JavaFieldStream fs(k()); !fs.done(); fs.next()) {
1814       if (fs.access_flags().is_public()) ++num_fields;
1815     }
1816   } else {
1817     num_fields = k-&gt;java_fields_count();
1818 
1819     if (k() == SystemDictionary::Throwable_klass()) {
1820       num_fields--;
1821       skip_backtrace = true;
1822     }
1823   }
1824 
1825   objArrayOop r = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), num_fields, CHECK_NULL);
1826   objArrayHandle result (THREAD, r);
1827 
1828   int out_idx = 0;
1829   fieldDescriptor fd;
1830   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1831     if (skip_backtrace) {
1832       // 4496456 skip java.lang.Throwable.backtrace
1833       int offset = fs.offset();
1834       if (offset == java_lang_Throwable::get_backtrace_offset()) continue;
1835     }
1836 
1837     if (!publicOnly || fs.access_flags().is_public()) {
1838       fd.reinitialize(k(), fs.index());
1839       oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
1840       result-&gt;obj_at_put(out_idx, field);
1841       ++out_idx;
1842     }
1843   }
1844   assert(out_idx == num_fields, "just checking");
1845   return (jobjectArray) JNIHandles::make_local(env, result());
1846 }
1847 JVM_END
1848 
1849 static bool select_method(methodHandle method, bool want_constructor) {
1850   if (want_constructor) {
1851     return (method-&gt;is_initializer() &amp;&amp; !method-&gt;is_static());
1852   } else {
1853     return  (!method-&gt;is_initializer() &amp;&amp; !method-&gt;is_overpass());
1854   }
1855 }
1856 
1857 static jobjectArray get_class_declared_methods_helper(
1858                                   JNIEnv *env,
1859                                   jclass ofClass, jboolean publicOnly,
1860                                   bool want_constructor,
1861                                   Klass* klass, TRAPS) {
1862 
1863   JvmtiVMObjectAllocEventCollector oam;
1864 
1865   // Exclude primitive types and array types
1866   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1867       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;oop_is_array()) {
1868     // Return empty array
1869     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1870     return (jobjectArray) JNIHandles::make_local(env, res);
1871   }
1872 
1873   instanceKlassHandle k(THREAD, java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1874 
1875   // Ensure class is linked
1876   k-&gt;link_class(CHECK_NULL);
1877 
1878   Array&lt;Method*&gt;* methods = k-&gt;methods();
1879   int methods_length = methods-&gt;length();
1880 
1881   // Save original method_idnum in case of redefinition, which can change
1882   // the idnum of obsolete methods.  The new method will have the same idnum
1883   // but if we refresh the methods array, the counts will be wrong.
1884   ResourceMark rm(THREAD);
1885   GrowableArray&lt;int&gt;* idnums = new GrowableArray&lt;int&gt;(methods_length);
1886   int num_methods = 0;
1887 
1888   for (int i = 0; i &lt; methods_length; i++) {
1889     methodHandle method(THREAD, methods-&gt;at(i));
1890     if (select_method(method, want_constructor)) {
1891       if (!publicOnly || method-&gt;is_public()) {
1892         idnums-&gt;push(method-&gt;method_idnum());
1893         ++num_methods;
1894       }
1895     }
1896   }
1897 
1898   // Allocate result
1899   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1900   objArrayHandle result (THREAD, r);
1901 
1902   // Now just put the methods that we selected above, but go by their idnum
1903   // in case of redefinition.  The methods can be redefined at any safepoint,
1904   // so above when allocating the oop array and below when creating reflect
1905   // objects.
1906   for (int i = 0; i &lt; num_methods; i++) {
1907     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1908     if (method.is_null()) {
1909       // Method may have been deleted and seems this API can handle null
1910       // Otherwise should probably put a method that throws NSME
1911       result-&gt;obj_at_put(i, NULL);
1912     } else {
1913       oop m;
1914       if (want_constructor) {
1915         m = Reflection::new_constructor(method, CHECK_NULL);
1916       } else {
1917         m = Reflection::new_method(method, false, CHECK_NULL);
1918       }
1919       result-&gt;obj_at_put(i, m);
1920     }
1921   }
1922 
1923   return (jobjectArray) JNIHandles::make_local(env, result());
1924 }
1925 
1926 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1927 {
1928   JVMWrapper("JVM_GetClassDeclaredMethods");
1929   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1930                                            /*want_constructor*/ false,
1931                                            SystemDictionary::reflect_Method_klass(), THREAD);
1932 }
1933 JVM_END
1934 
1935 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1936 {
1937   JVMWrapper("JVM_GetClassDeclaredConstructors");
1938   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1939                                            /*want_constructor*/ true,
1940                                            SystemDictionary::reflect_Constructor_klass(), THREAD);
1941 }
1942 JVM_END
1943 
1944 JVM_ENTRY(jint, JVM_GetClassAccessFlags(JNIEnv *env, jclass cls))
1945 {
1946   JVMWrapper("JVM_GetClassAccessFlags");
1947   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1948     // Primitive type
1949     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1950   }
1951 
1952   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1953   return k-&gt;access_flags().as_int() &amp; JVM_ACC_WRITTEN_FLAGS;
1954 }
1955 JVM_END
1956 
1957 
1958 // Constant pool access //////////////////////////////////////////////////////////
1959 
1960 JVM_ENTRY(jobject, JVM_GetClassConstantPool(JNIEnv *env, jclass cls))
1961 {
1962   JVMWrapper("JVM_GetClassConstantPool");
1963   JvmtiVMObjectAllocEventCollector oam;
1964 
1965   // Return null for primitives and arrays
1966   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1967     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1968     if (k-&gt;oop_is_instance()) {
1969       instanceKlassHandle k_h(THREAD, k);
1970       Handle jcp = sun_reflect_ConstantPool::create(CHECK_NULL);
1971       sun_reflect_ConstantPool::set_cp(jcp(), k_h-&gt;constants());
1972       return JNIHandles::make_local(jcp());
1973     }
1974   }
1975   return NULL;
1976 }
1977 JVM_END
1978 
1979 
1980 JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj, jobject unused))
1981 {
1982   JVMWrapper("JVM_ConstantPoolGetSize");
1983   constantPoolHandle cp = constantPoolHandle(THREAD, sun_reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
1984   return cp-&gt;length();
1985 }
1986 JVM_END
1987 
1988 
1989 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAt(JNIEnv *env, jobject obj, jobject unused, jint index))
1990 {
1991   JVMWrapper("JVM_ConstantPoolGetClassAt");
1992   constantPoolHandle cp = constantPoolHandle(THREAD, sun_reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
1993   bounds_check(cp, index, CHECK_NULL);
1994   constantTag tag = cp-&gt;tag_at(index);
1995   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
1996     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Wrong type at constant pool index");
1997   }
1998   Klass* k = cp-&gt;klass_at(index, CHECK_NULL);
1999   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
2000 }
2001 JVM_END
2002 
2003 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2004 {
2005   JVMWrapper("JVM_ConstantPoolGetClassAtIfLoaded");
2006   constantPoolHandle cp = constantPoolHandle(THREAD, sun_reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2007   bounds_check(cp, index, CHECK_NULL);
2008   constantTag tag = cp-&gt;tag_at(index);
2009   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2010     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Wrong type at constant pool index");
2011   }
2012   Klass* k = ConstantPool::klass_at_if_loaded(cp, index);
2013   if (k == NULL) return NULL;
2014   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
2015 }
2016 JVM_END
2017 
2018 static jobject get_method_at_helper(constantPoolHandle cp, jint index, bool force_resolution, TRAPS) {
2019   constantTag tag = cp-&gt;tag_at(index);
2020   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2021     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Wrong type at constant pool index");
2022   }
2023   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2024   Klass* k_o;
2025   if (force_resolution) {
2026     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2027   } else {
2028     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2029     if (k_o == NULL) return NULL;
2030   }
2031   instanceKlassHandle k(THREAD, k_o);
2032   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2033   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2034   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2035   if (m.is_null()) {
2036     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), "Unable to look up method in target class");
2037   }
2038   oop method;
2039   if (!m-&gt;is_initializer() || m-&gt;is_static()) {
2040     method = Reflection::new_method(m, true, CHECK_NULL);
2041   } else {
2042     method = Reflection::new_constructor(m, CHECK_NULL);
2043   }
2044   return JNIHandles::make_local(method);
2045 }
2046 
2047 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2048 {
2049   JVMWrapper("JVM_ConstantPoolGetMethodAt");
2050   JvmtiVMObjectAllocEventCollector oam;
2051   constantPoolHandle cp = constantPoolHandle(THREAD, sun_reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2052   bounds_check(cp, index, CHECK_NULL);
2053   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2054   return res;
2055 }
2056 JVM_END
2057 
2058 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2059 {
2060   JVMWrapper("JVM_ConstantPoolGetMethodAtIfLoaded");
2061   JvmtiVMObjectAllocEventCollector oam;
2062   constantPoolHandle cp = constantPoolHandle(THREAD, sun_reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2063   bounds_check(cp, index, CHECK_NULL);
2064   jobject res = get_method_at_helper(cp, index, false, CHECK_NULL);
2065   return res;
2066 }
2067 JVM_END
2068 
2069 static jobject get_field_at_helper(constantPoolHandle cp, jint index, bool force_resolution, TRAPS) {
2070   constantTag tag = cp-&gt;tag_at(index);
2071   if (!tag.is_field()) {
2072     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Wrong type at constant pool index");
2073   }
2074   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2075   Klass* k_o;
2076   if (force_resolution) {
2077     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2078   } else {
2079     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2080     if (k_o == NULL) return NULL;
2081   }
2082   instanceKlassHandle k(THREAD, k_o);
2083   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2084   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2085   fieldDescriptor fd;
2086   Klass* target_klass = k-&gt;find_field(name, sig, &amp;fd);
2087   if (target_klass == NULL) {
2088     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), "Unable to look up field in target class");
2089   }
2090   oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
2091   return JNIHandles::make_local(field);
2092 }
2093 
2094 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAt(JNIEnv *env, jobject obj, jobject unusedl, jint index))
2095 {
2096   JVMWrapper("JVM_ConstantPoolGetFieldAt");
2097   JvmtiVMObjectAllocEventCollector oam;
2098   constantPoolHandle cp = constantPoolHandle(THREAD, sun_reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2099   bounds_check(cp, index, CHECK_NULL);
2100   jobject res = get_field_at_helper(cp, index, true, CHECK_NULL);
2101   return res;
2102 }
2103 JVM_END
2104 
2105 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2106 {
2107   JVMWrapper("JVM_ConstantPoolGetFieldAtIfLoaded");
2108   JvmtiVMObjectAllocEventCollector oam;
2109   constantPoolHandle cp = constantPoolHandle(THREAD, sun_reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2110   bounds_check(cp, index, CHECK_NULL);
2111   jobject res = get_field_at_helper(cp, index, false, CHECK_NULL);
2112   return res;
2113 }
2114 JVM_END
2115 
2116 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetMemberRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2117 {
2118   JVMWrapper("JVM_ConstantPoolGetMemberRefInfoAt");
2119   JvmtiVMObjectAllocEventCollector oam;
2120   constantPoolHandle cp = constantPoolHandle(THREAD, sun_reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2121   bounds_check(cp, index, CHECK_NULL);
2122   constantTag tag = cp-&gt;tag_at(index);
2123   if (!tag.is_field_or_method()) {
2124     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Wrong type at constant pool index");
2125   }
2126   int klass_ref = cp-&gt;uncached_klass_ref_index_at(index);
2127   Symbol*  klass_name  = cp-&gt;klass_name_at(klass_ref);
2128   Symbol*  member_name = cp-&gt;uncached_name_ref_at(index);
2129   Symbol*  member_sig  = cp-&gt;uncached_signature_ref_at(index);
2130   objArrayOop  dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 3, CHECK_NULL);
2131   objArrayHandle dest(THREAD, dest_o);
2132   Handle str = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);
2133   dest-&gt;obj_at_put(0, str());
2134   str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2135   dest-&gt;obj_at_put(1, str());
2136   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2137   dest-&gt;obj_at_put(2, str());
2138   return (jobjectArray) JNIHandles::make_local(dest());
2139 }
2140 JVM_END
2141 
2142 JVM_ENTRY(jint, JVM_ConstantPoolGetIntAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2143 {
2144   JVMWrapper("JVM_ConstantPoolGetIntAt");
2145   constantPoolHandle cp = constantPoolHandle(THREAD, sun_reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2146   bounds_check(cp, index, CHECK_0);
2147   constantTag tag = cp-&gt;tag_at(index);
2148   if (!tag.is_int()) {
2149     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Wrong type at constant pool index");
2150   }
2151   return cp-&gt;int_at(index);
2152 }
2153 JVM_END
2154 
2155 JVM_ENTRY(jlong, JVM_ConstantPoolGetLongAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2156 {
2157   JVMWrapper("JVM_ConstantPoolGetLongAt");
2158   constantPoolHandle cp = constantPoolHandle(THREAD, sun_reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2159   bounds_check(cp, index, CHECK_(0L));
2160   constantTag tag = cp-&gt;tag_at(index);
2161   if (!tag.is_long()) {
2162     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Wrong type at constant pool index");
2163   }
2164   return cp-&gt;long_at(index);
2165 }
2166 JVM_END
2167 
2168 JVM_ENTRY(jfloat, JVM_ConstantPoolGetFloatAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2169 {
2170   JVMWrapper("JVM_ConstantPoolGetFloatAt");
2171   constantPoolHandle cp = constantPoolHandle(THREAD, sun_reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2172   bounds_check(cp, index, CHECK_(0.0f));
2173   constantTag tag = cp-&gt;tag_at(index);
2174   if (!tag.is_float()) {
2175     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Wrong type at constant pool index");
2176   }
2177   return cp-&gt;float_at(index);
2178 }
2179 JVM_END
2180 
2181 JVM_ENTRY(jdouble, JVM_ConstantPoolGetDoubleAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2182 {
2183   JVMWrapper("JVM_ConstantPoolGetDoubleAt");
2184   constantPoolHandle cp = constantPoolHandle(THREAD, sun_reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2185   bounds_check(cp, index, CHECK_(0.0));
2186   constantTag tag = cp-&gt;tag_at(index);
2187   if (!tag.is_double()) {
2188     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Wrong type at constant pool index");
2189   }
2190   return cp-&gt;double_at(index);
2191 }
2192 JVM_END
2193 
2194 JVM_ENTRY(jstring, JVM_ConstantPoolGetStringAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2195 {
2196   JVMWrapper("JVM_ConstantPoolGetStringAt");
2197   constantPoolHandle cp = constantPoolHandle(THREAD, sun_reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2198   bounds_check(cp, index, CHECK_NULL);
2199   constantTag tag = cp-&gt;tag_at(index);
2200   if (!tag.is_string()) {
2201     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Wrong type at constant pool index");
2202   }
2203   oop str = cp-&gt;string_at(index, CHECK_NULL);
2204   return (jstring) JNIHandles::make_local(str);
2205 }
2206 JVM_END
2207 
2208 JVM_ENTRY(jstring, JVM_ConstantPoolGetUTF8At(JNIEnv *env, jobject obj, jobject unused, jint index))
2209 {
2210   JVMWrapper("JVM_ConstantPoolGetUTF8At");
2211   JvmtiVMObjectAllocEventCollector oam;
2212   constantPoolHandle cp = constantPoolHandle(THREAD, sun_reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2213   bounds_check(cp, index, CHECK_NULL);
2214   constantTag tag = cp-&gt;tag_at(index);
2215   if (!tag.is_symbol()) {
2216     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Wrong type at constant pool index");
2217   }
2218   Symbol* sym = cp-&gt;symbol_at(index);
2219   Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
2220   return (jstring) JNIHandles::make_local(str());
2221 }
2222 JVM_END
2223 
2224 
2225 // Assertion support. //////////////////////////////////////////////////////////
2226 
2227 JVM_ENTRY(jboolean, JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls))
2228   JVMWrapper("JVM_DesiredAssertionStatus");
2229   assert(cls != NULL, "bad class");
2230 
2231   oop r = JNIHandles::resolve(cls);
2232   assert(! java_lang_Class::is_primitive(r), "primitive classes not allowed");
2233   if (java_lang_Class::is_primitive(r)) return false;
2234 
2235   Klass* k = java_lang_Class::as_Klass(r);
2236   assert(k-&gt;oop_is_instance(), "must be an instance klass");
2237   if (! k-&gt;oop_is_instance()) return false;
2238 
2239   ResourceMark rm(THREAD);
2240   const char* name = k-&gt;name()-&gt;as_C_string();
2241   bool system_class = k-&gt;class_loader() == NULL;
2242   return JavaAssertions::enabled(name, system_class);
2243 
2244 JVM_END
2245 
2246 
2247 // Return a new AssertionStatusDirectives object with the fields filled in with
2248 // command-line assertion arguments (i.e., -ea, -da).
2249 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2250   JVMWrapper("JVM_AssertionStatusDirectives");
2251   JvmtiVMObjectAllocEventCollector oam;
2252   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2253   return JNIHandles::make_local(env, asd);
2254 JVM_END
2255 
2256 // Verification ////////////////////////////////////////////////////////////////////////////////
2257 
2258 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2259 
2260 // RedefineClasses support: bug 6214132 caused verification to fail.
2261 // All functions from this section should call the jvmtiThreadSate function:
2262 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2263 // The function returns a Klass* of the _scratch_class if the verifier
2264 // was invoked in the middle of the class redefinition.
2265 // Otherwise it returns its argument value which is the _the_class Klass*.
2266 // Please, refer to the description in the jvmtiThreadSate.hpp.
2267 
2268 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2269   JVMWrapper("JVM_GetClassNameUTF");
2270   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2271   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2272   return k-&gt;name()-&gt;as_utf8();
2273 JVM_END
2274 
2275 
2276 JVM_QUICK_ENTRY(void, JVM_GetClassCPTypes(JNIEnv *env, jclass cls, unsigned char *types))
2277   JVMWrapper("JVM_GetClassCPTypes");
2278   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2279   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2280   // types will have length zero if this is not an InstanceKlass
2281   // (length is determined by call to JVM_GetClassCPEntriesCount)
2282   if (k-&gt;oop_is_instance()) {
2283     ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2284     for (int index = cp-&gt;length() - 1; index &gt;= 0; index--) {
2285       constantTag tag = cp-&gt;tag_at(index);
2286       types[index] = (tag.is_unresolved_klass()) ? JVM_CONSTANT_Class : tag.value();
2287   }
2288   }
2289 JVM_END
2290 
2291 
2292 JVM_QUICK_ENTRY(jint, JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cls))
2293   JVMWrapper("JVM_GetClassCPEntriesCount");
2294   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2295   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2296   if (!k-&gt;oop_is_instance())
2297     return 0;
2298   return InstanceKlass::cast(k)-&gt;constants()-&gt;length();
2299 JVM_END
2300 
2301 
2302 JVM_QUICK_ENTRY(jint, JVM_GetClassFieldsCount(JNIEnv *env, jclass cls))
2303   JVMWrapper("JVM_GetClassFieldsCount");
2304   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2305   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2306   if (!k-&gt;oop_is_instance())
2307     return 0;
2308   return InstanceKlass::cast(k)-&gt;java_fields_count();
2309 JVM_END
2310 
2311 
2312 JVM_QUICK_ENTRY(jint, JVM_GetClassMethodsCount(JNIEnv *env, jclass cls))
2313   JVMWrapper("JVM_GetClassMethodsCount");
2314   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2315   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2316   if (!k-&gt;oop_is_instance())
2317     return 0;
2318   return InstanceKlass::cast(k)-&gt;methods()-&gt;length();
2319 JVM_END
2320 
2321 
2322 // The following methods, used for the verifier, are never called with
2323 // array klasses, so a direct cast to InstanceKlass is safe.
2324 // Typically, these methods are called in a loop with bounds determined
2325 // by the results of JVM_GetClass{Fields,Methods}Count, which return
2326 // zero for arrays.
2327 JVM_QUICK_ENTRY(void, JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cls, jint method_index, unsigned short *exceptions))
2328   JVMWrapper("JVM_GetMethodIxExceptionIndexes");
2329   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2330   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2331   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2332   int length = method-&gt;checked_exceptions_length();
2333   if (length &gt; 0) {
2334     CheckedExceptionElement* table= method-&gt;checked_exceptions_start();
2335     for (int i = 0; i &lt; length; i++) {
2336       exceptions[i] = table[i].class_cp_index;
2337     }
2338   }
2339 JVM_END
2340 
2341 
2342 JVM_QUICK_ENTRY(jint, JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cls, jint method_index))
2343   JVMWrapper("JVM_GetMethodIxExceptionsCount");
2344   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2345   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2346   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2347   return method-&gt;checked_exceptions_length();
2348 JVM_END
2349 
2350 
2351 JVM_QUICK_ENTRY(void, JVM_GetMethodIxByteCode(JNIEnv *env, jclass cls, jint method_index, unsigned char *code))
2352   JVMWrapper("JVM_GetMethodIxByteCode");
2353   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2354   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2355   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2356   memcpy(code, method-&gt;code_base(), method-&gt;code_size());
2357 JVM_END
2358 
2359 
2360 JVM_QUICK_ENTRY(jint, JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cls, jint method_index))
2361   JVMWrapper("JVM_GetMethodIxByteCodeLength");
2362   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2363   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2364   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2365   return method-&gt;code_size();
2366 JVM_END
2367 
2368 
2369 JVM_QUICK_ENTRY(void, JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cls, jint method_index, jint entry_index, JVM_ExceptionTableEntryType *entry))
2370   JVMWrapper("JVM_GetMethodIxExceptionTableEntry");
2371   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2372   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2373   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2374   ExceptionTable extable(method);
2375   entry-&gt;start_pc   = extable.start_pc(entry_index);
2376   entry-&gt;end_pc     = extable.end_pc(entry_index);
2377   entry-&gt;handler_pc = extable.handler_pc(entry_index);
2378   entry-&gt;catchType  = extable.catch_type_index(entry_index);
2379 JVM_END
2380 
2381 
2382 JVM_QUICK_ENTRY(jint, JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cls, int method_index))
2383   JVMWrapper("JVM_GetMethodIxExceptionTableLength");
2384   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2385   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2386   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2387   return method-&gt;exception_table_length();
2388 JVM_END
2389 
2390 
2391 JVM_QUICK_ENTRY(jint, JVM_GetMethodIxModifiers(JNIEnv *env, jclass cls, int method_index))
2392   JVMWrapper("JVM_GetMethodIxModifiers");
2393   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2394   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2395   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2396   return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2397 JVM_END
2398 
2399 
2400 JVM_QUICK_ENTRY(jint, JVM_GetFieldIxModifiers(JNIEnv *env, jclass cls, int field_index))
2401   JVMWrapper("JVM_GetFieldIxModifiers");
2402   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2403   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2404   return InstanceKlass::cast(k)-&gt;field_access_flags(field_index) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2405 JVM_END
2406 
2407 
2408 JVM_QUICK_ENTRY(jint, JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cls, int method_index))
2409   JVMWrapper("JVM_GetMethodIxLocalsCount");
2410   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2411   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2412   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2413   return method-&gt;max_locals();
2414 JVM_END
2415 
2416 
2417 JVM_QUICK_ENTRY(jint, JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cls, int method_index))
2418   JVMWrapper("JVM_GetMethodIxArgsSize");
2419   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2420   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2421   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2422   return method-&gt;size_of_parameters();
2423 JVM_END
2424 
2425 
2426 JVM_QUICK_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2427   JVMWrapper("JVM_GetMethodIxMaxStack");
2428   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2429   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2430   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2431   return method-&gt;verifier_max_stack();
2432 JVM_END
2433 
2434 
2435 JVM_QUICK_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2436   JVMWrapper("JVM_IsConstructorIx");
2437   ResourceMark rm(THREAD);
2438   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2439   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2440   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2441   return method-&gt;name() == vmSymbols::object_initializer_name();
2442 JVM_END
2443 
2444 
2445 JVM_QUICK_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2446   JVMWrapper("JVM_IsVMGeneratedMethodIx");
2447   ResourceMark rm(THREAD);
2448   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2449   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2450   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2451   return method-&gt;is_overpass();
2452 JVM_END
2453 
2454 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2455   JVMWrapper("JVM_GetMethodIxIxUTF");
2456   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2457   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2458   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2459   return method-&gt;name()-&gt;as_utf8();
2460 JVM_END
2461 
2462 
2463 JVM_ENTRY(const char*, JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cls, jint method_index))
2464   JVMWrapper("JVM_GetMethodIxSignatureUTF");
2465   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2466   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2467   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2468   return method-&gt;signature()-&gt;as_utf8();
2469 JVM_END
2470 
2471 /**
2472  * All of these JVM_GetCP-xxx methods are used by the old verifier to
2473  * read entries in the constant pool.  Since the old verifier always
2474  * works on a copy of the code, it will not see any rewriting that
2475  * may possibly occur in the middle of verification.  So it is important
2476  * that nothing it calls tries to use the cpCache instead of the raw
2477  * constant pool, so we must use cp-&gt;uncached_x methods when appropriate.
2478  */
2479 JVM_ENTRY(const char*, JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2480   JVMWrapper("JVM_GetCPFieldNameUTF");
2481   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2482   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2483   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2484   switch (cp-&gt;tag_at(cp_index).value()) {
2485     case JVM_CONSTANT_Fieldref:
2486       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2487     default:
2488       fatal("JVM_GetCPFieldNameUTF: illegal constant");
2489   }
2490   ShouldNotReachHere();
2491   return NULL;
2492 JVM_END
2493 
2494 
2495 JVM_ENTRY(const char*, JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2496   JVMWrapper("JVM_GetCPMethodNameUTF");
2497   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2498   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2499   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2500   switch (cp-&gt;tag_at(cp_index).value()) {
2501     case JVM_CONSTANT_InterfaceMethodref:
2502     case JVM_CONSTANT_Methodref:
2503     case JVM_CONSTANT_NameAndType:  // for invokedynamic
2504       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2505     default:
2506       fatal("JVM_GetCPMethodNameUTF: illegal constant");
2507   }
2508   ShouldNotReachHere();
2509   return NULL;
2510 JVM_END
2511 
2512 
2513 JVM_ENTRY(const char*, JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2514   JVMWrapper("JVM_GetCPMethodSignatureUTF");
2515   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2516   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2517   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2518   switch (cp-&gt;tag_at(cp_index).value()) {
2519     case JVM_CONSTANT_InterfaceMethodref:
2520     case JVM_CONSTANT_Methodref:
2521     case JVM_CONSTANT_NameAndType:  // for invokedynamic
2522       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2523     default:
2524       fatal("JVM_GetCPMethodSignatureUTF: illegal constant");
2525   }
2526   ShouldNotReachHere();
2527   return NULL;
2528 JVM_END
2529 
2530 
2531 JVM_ENTRY(const char*, JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2532   JVMWrapper("JVM_GetCPFieldSignatureUTF");
2533   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2534   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2535   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2536   switch (cp-&gt;tag_at(cp_index).value()) {
2537     case JVM_CONSTANT_Fieldref:
2538       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2539     default:
2540       fatal("JVM_GetCPFieldSignatureUTF: illegal constant");
2541   }
2542   ShouldNotReachHere();
2543   return NULL;
2544 JVM_END
2545 
2546 
2547 JVM_ENTRY(const char*, JVM_GetCPClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2548   JVMWrapper("JVM_GetCPClassNameUTF");
2549   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2550   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2551   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2552   Symbol* classname = cp-&gt;klass_name_at(cp_index);
2553   return classname-&gt;as_utf8();
2554 JVM_END
2555 
2556 
2557 JVM_ENTRY(const char*, JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2558   JVMWrapper("JVM_GetCPFieldClassNameUTF");
2559   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2560   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2561   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2562   switch (cp-&gt;tag_at(cp_index).value()) {
2563     case JVM_CONSTANT_Fieldref: {
2564       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2565       Symbol* classname = cp-&gt;klass_name_at(class_index);
2566       return classname-&gt;as_utf8();
2567     }
2568     default:
2569       fatal("JVM_GetCPFieldClassNameUTF: illegal constant");
2570   }
2571   ShouldNotReachHere();
2572   return NULL;
2573 JVM_END
2574 
2575 
2576 JVM_ENTRY(const char*, JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2577   JVMWrapper("JVM_GetCPMethodClassNameUTF");
2578   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2579   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2580   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2581   switch (cp-&gt;tag_at(cp_index).value()) {
2582     case JVM_CONSTANT_Methodref:
2583     case JVM_CONSTANT_InterfaceMethodref: {
2584       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2585       Symbol* classname = cp-&gt;klass_name_at(class_index);
2586       return classname-&gt;as_utf8();
2587     }
2588     default:
2589       fatal("JVM_GetCPMethodClassNameUTF: illegal constant");
2590   }
2591   ShouldNotReachHere();
2592   return NULL;
2593 JVM_END
2594 
2595 
2596 JVM_ENTRY(jint, JVM_GetCPFieldModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2597   JVMWrapper("JVM_GetCPFieldModifiers");
2598   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2599   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2600   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2601   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2602   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2603   ConstantPool* cp_called = InstanceKlass::cast(k_called)-&gt;constants();
2604   switch (cp-&gt;tag_at(cp_index).value()) {
2605     case JVM_CONSTANT_Fieldref: {
2606       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2607       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2608       for (JavaFieldStream fs(k_called); !fs.done(); fs.next()) {
2609         if (fs.name() == name &amp;&amp; fs.signature() == signature) {
2610           return fs.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2611         }
2612       }
2613       return -1;
2614     }
2615     default:
2616       fatal("JVM_GetCPFieldModifiers: illegal constant");
2617   }
2618   ShouldNotReachHere();
2619   return 0;
2620 JVM_END
2621 
2622 
2623 JVM_QUICK_ENTRY(jint, JVM_GetCPMethodModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2624   JVMWrapper("JVM_GetCPMethodModifiers");
2625   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2626   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2627   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2628   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2629   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2630   switch (cp-&gt;tag_at(cp_index).value()) {
2631     case JVM_CONSTANT_Methodref:
2632     case JVM_CONSTANT_InterfaceMethodref: {
2633       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2634       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2635       Array&lt;Method*&gt;* methods = InstanceKlass::cast(k_called)-&gt;methods();
2636       int methods_count = methods-&gt;length();
2637       for (int i = 0; i &lt; methods_count; i++) {
2638         Method* method = methods-&gt;at(i);
2639         if (method-&gt;name() == name &amp;&amp; method-&gt;signature() == signature) {
2640             return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2641         }
2642       }
2643       return -1;
2644     }
2645     default:
2646       fatal("JVM_GetCPMethodModifiers: illegal constant");
2647   }
2648   ShouldNotReachHere();
2649   return 0;
2650 JVM_END
2651 
2652 
2653 // Misc //////////////////////////////////////////////////////////////////////////////////////////////
2654 
2655 JVM_LEAF(void, JVM_ReleaseUTF(const char *utf))
2656   // So long as UTF8::convert_to_utf8 returns resource strings, we don't have to do anything
2657 JVM_END
2658 
2659 
2660 JVM_ENTRY(jboolean, JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2))
2661   JVMWrapper("JVM_IsSameClassPackage");
2662   oop class1_mirror = JNIHandles::resolve_non_null(class1);
2663   oop class2_mirror = JNIHandles::resolve_non_null(class2);
2664   Klass* klass1 = java_lang_Class::as_Klass(class1_mirror);
2665   Klass* klass2 = java_lang_Class::as_Klass(class2_mirror);
2666   return (jboolean) Reflection::is_same_class_package(klass1, klass2);
2667 JVM_END
2668 
2669 
2670 // IO functions ////////////////////////////////////////////////////////////////////////////////////////
2671 
2672 JVM_LEAF(jint, JVM_Open(const char *fname, jint flags, jint mode))
2673   JVMWrapper2("JVM_Open (%s)", fname);
2674 
2675   //%note jvm_r6
2676   int result = os::open(fname, flags, mode);
2677   if (result &gt;= 0) {
2678     return result;
2679   } else {
2680     switch(errno) {
2681       case EEXIST:
2682         return JVM_EEXIST;
2683       default:
2684         return -1;
2685     }
2686   }
2687 JVM_END
2688 
2689 
2690 JVM_LEAF(jint, JVM_Close(jint fd))
2691   JVMWrapper2("JVM_Close (0x%x)", fd);
2692   //%note jvm_r6
2693   return os::close(fd);
2694 JVM_END
2695 
2696 
2697 JVM_LEAF(jint, JVM_Read(jint fd, char *buf, jint nbytes))
2698   JVMWrapper2("JVM_Read (0x%x)", fd);
2699 
2700   //%note jvm_r6
2701   return (jint)os::restartable_read(fd, buf, nbytes);
2702 JVM_END
2703 
2704 
2705 JVM_LEAF(jint, JVM_Write(jint fd, char *buf, jint nbytes))
2706   JVMWrapper2("JVM_Write (0x%x)", fd);
2707 
2708   //%note jvm_r6
2709   return (jint)os::write(fd, buf, nbytes);
2710 JVM_END
2711 
2712 
2713 JVM_LEAF(jint, JVM_Available(jint fd, jlong *pbytes))
2714   JVMWrapper2("JVM_Available (0x%x)", fd);
2715   //%note jvm_r6
2716   return os::available(fd, pbytes);
2717 JVM_END
2718 
2719 
2720 JVM_LEAF(jlong, JVM_Lseek(jint fd, jlong offset, jint whence))
2721   JVMWrapper4("JVM_Lseek (0x%x, %Ld, %d)", fd, offset, whence);
2722   //%note jvm_r6
2723   return os::lseek(fd, offset, whence);
2724 JVM_END
2725 
2726 
2727 JVM_LEAF(jint, JVM_SetLength(jint fd, jlong length))
2728   JVMWrapper3("JVM_SetLength (0x%x, %Ld)", fd, length);
2729   return os::ftruncate(fd, length);
2730 JVM_END
2731 
2732 
2733 JVM_LEAF(jint, JVM_Sync(jint fd))
2734   JVMWrapper2("JVM_Sync (0x%x)", fd);
2735   //%note jvm_r6
2736   return os::fsync(fd);
2737 JVM_END
2738 
2739 
2740 // Printing support //////////////////////////////////////////////////
2741 extern "C" {
2742 
2743 int jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args) {
2744   // see bug 4399518, 4417214
2745   if ((intptr_t)count &lt;= 0) return -1;
2746   return vsnprintf(str, count, fmt, args);
2747 }
2748 
2749 
2750 int jio_snprintf(char *str, size_t count, const char *fmt, ...) {
2751   va_list args;
2752   int len;
2753   va_start(args, fmt);
2754   len = jio_vsnprintf(str, count, fmt, args);
2755   va_end(args);
2756   return len;
2757 }
2758 
2759 
2760 int jio_fprintf(FILE* f, const char *fmt, ...) {
2761   int len;
2762   va_list args;
2763   va_start(args, fmt);
2764   len = jio_vfprintf(f, fmt, args);
2765   va_end(args);
2766   return len;
2767 }
2768 
2769 
2770 int jio_vfprintf(FILE* f, const char *fmt, va_list args) {
2771   if (Arguments::vfprintf_hook() != NULL) {
2772      return Arguments::vfprintf_hook()(f, fmt, args);
2773   } else {
2774     return vfprintf(f, fmt, args);
2775   }
2776 }
2777 
2778 
2779 JNIEXPORT int jio_printf(const char *fmt, ...) {
2780   int len;
2781   va_list args;
2782   va_start(args, fmt);
2783   len = jio_vfprintf(defaultStream::output_stream(), fmt, args);
2784   va_end(args);
2785   return len;
2786 }
2787 
2788 
2789 // HotSpot specific jio method
2790 void jio_print(const char* s) {
2791   // Try to make this function as atomic as possible.
2792   if (Arguments::vfprintf_hook() != NULL) {
2793     jio_fprintf(defaultStream::output_stream(), "%s", s);
2794   } else {
2795     // Make an unused local variable to avoid warning from gcc 4.x compiler.
2796     size_t count = ::write(defaultStream::output_fd(), s, (int)strlen(s));
2797   }
2798 }
2799 
2800 } // Extern C
2801 
2802 // java.lang.Thread //////////////////////////////////////////////////////////////////////////////
2803 
2804 // In most of the JVM Thread support functions we need to be sure to lock the Threads_lock
2805 // to prevent the target thread from exiting after we have a pointer to the C++ Thread or
2806 // OSThread objects.  The exception to this rule is when the target object is the thread
2807 // doing the operation, in which case we know that the thread won't exit until the
2808 // operation is done (all exits being voluntary).  There are a few cases where it is
2809 // rather silly to do operations on yourself, like resuming yourself or asking whether
2810 // you are alive.  While these can still happen, they are not subject to deadlocks if
2811 // the lock is held while the operation occurs (this is not the case for suspend, for
2812 // instance), and are very unlikely.  Because IsAlive needs to be fast and its
2813 // implementation is local to this file, we always lock Threads_lock for that one.
2814 
2815 static void thread_entry(JavaThread* thread, TRAPS) {
2816   HandleMark hm(THREAD);
2817   Handle obj(THREAD, thread-&gt;threadObj());
2818   JavaValue result(T_VOID);
2819   JavaCalls::call_virtual(&amp;result,
2820                           obj,
2821                           KlassHandle(THREAD, SystemDictionary::Thread_klass()),
2822                           vmSymbols::run_method_name(),
2823                           vmSymbols::void_method_signature(),
2824                           THREAD);
2825 }
2826 
2827 
2828 JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))
2829   JVMWrapper("JVM_StartThread");
2830   JavaThread *native_thread = NULL;
2831 
2832   // We cannot hold the Threads_lock when we throw an exception,
2833   // due to rank ordering issues. Example:  we might need to grab the
2834   // Heap_lock while we construct the exception.
2835   bool throw_illegal_thread_state = false;
2836 
2837   // We must release the Threads_lock before we can post a jvmti event
2838   // in Thread::start.
2839   {
2840     // Ensure that the C++ Thread and OSThread structures aren't freed before
2841     // we operate.
2842     MutexLocker mu(Threads_lock);
2843 
2844     // Since JDK 5 the java.lang.Thread threadStatus is used to prevent
2845     // re-starting an already started thread, so we should usually find
2846     // that the JavaThread is null. However for a JNI attached thread
2847     // there is a small window between the Thread object being created
2848     // (with its JavaThread set) and the update to its threadStatus, so we
2849     // have to check for this
2850     if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != NULL) {
2851       throw_illegal_thread_state = true;
2852     } else {
2853       // We could also check the stillborn flag to see if this thread was already stopped, but
2854       // for historical reasons we let the thread detect that itself when it starts running
2855 
2856       jlong size =
2857              java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));
2858       // Allocate the C++ Thread structure and create the native thread.  The
2859       // stack size retrieved from java is signed, but the constructor takes
2860       // size_t (an unsigned type), so avoid passing negative values which would
2861       // result in really large stacks.
2862       size_t sz = size &gt; 0 ? (size_t) size : 0;
2863       native_thread = new JavaThread(&amp;thread_entry, sz);
2864 
2865       // At this point it may be possible that no osthread was created for the
2866       // JavaThread due to lack of memory. Check for this situation and throw
2867       // an exception if necessary. Eventually we may want to change this so
2868       // that we only grab the lock if the thread was created successfully -
2869       // then we can also do this check and throw the exception in the
2870       // JavaThread constructor.
2871       if (native_thread-&gt;osthread() != NULL) {
2872         // Note: the current thread is not being used within "prepare".
2873         native_thread-&gt;prepare(jthread);
2874       }
2875     }
2876   }
2877 
2878   if (throw_illegal_thread_state) {
2879     THROW(vmSymbols::java_lang_IllegalThreadStateException());
2880   }
2881 
2882   assert(native_thread != NULL, "Starting null thread?");
2883 
2884   if (native_thread-&gt;osthread() == NULL) {
2885     // No one should hold a reference to the 'native_thread'.
2886     delete native_thread;
2887     if (JvmtiExport::should_post_resource_exhausted()) {
2888       JvmtiExport::post_resource_exhausted(
2889         JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,
2890         os::native_thread_creation_failed_msg());
2891     }
2892     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),
2893               os::native_thread_creation_failed_msg());
2894   }
2895 
2896   Thread::start(native_thread);
2897 
2898 JVM_END
2899 
2900 // JVM_Stop is implemented using a VM_Operation, so threads are forced to safepoints
2901 // before the quasi-asynchronous exception is delivered.  This is a little obtrusive,
2902 // but is thought to be reliable and simple. In the case, where the receiver is the
2903 // same thread as the sender, no safepoint is needed.
2904 JVM_ENTRY(void, JVM_StopThread(JNIEnv* env, jobject jthread, jobject throwable))
2905   JVMWrapper("JVM_StopThread");
2906 
2907   oop java_throwable = JNIHandles::resolve(throwable);
2908   if (java_throwable == NULL) {
2909     THROW(vmSymbols::java_lang_NullPointerException());
2910   }
2911   oop java_thread = JNIHandles::resolve_non_null(jthread);
2912   JavaThread* receiver = java_lang_Thread::thread(java_thread);
2913   Events::log_exception(JavaThread::current(),
2914                         "JVM_StopThread thread JavaThread " INTPTR_FORMAT " as oop " INTPTR_FORMAT " [exception " INTPTR_FORMAT "]",
2915                         receiver, (address)java_thread, throwable);
2916   // First check if thread is alive
2917   if (receiver != NULL) {
2918     // Check if exception is getting thrown at self (use oop equality, since the
2919     // target object might exit)
2920     if (java_thread == thread-&gt;threadObj()) {
2921       THROW_OOP(java_throwable);
2922     } else {
2923       // Enques a VM_Operation to stop all threads and then deliver the exception...
2924       Thread::send_async_exception(java_thread, JNIHandles::resolve(throwable));
2925     }
2926   }
2927   else {
2928     // Either:
2929     // - target thread has not been started before being stopped, or
2930     // - target thread already terminated
2931     // We could read the threadStatus to determine which case it is
2932     // but that is overkill as it doesn't matter. We must set the
2933     // stillborn flag for the first case, and if the thread has already
2934     // exited setting this flag has no affect
2935     java_lang_Thread::set_stillborn(java_thread);
2936   }
2937 JVM_END
2938 
2939 
2940 JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))
2941   JVMWrapper("JVM_IsThreadAlive");
2942 
2943   oop thread_oop = JNIHandles::resolve_non_null(jthread);
2944   return java_lang_Thread::is_alive(thread_oop);
2945 JVM_END
2946 
2947 
2948 JVM_ENTRY(void, JVM_SuspendThread(JNIEnv* env, jobject jthread))
2949   JVMWrapper("JVM_SuspendThread");
2950   oop java_thread = JNIHandles::resolve_non_null(jthread);
2951   JavaThread* receiver = java_lang_Thread::thread(java_thread);
2952 
2953   if (receiver != NULL) {
2954     // thread has run and has not exited (still on threads list)
2955 
2956     {
2957       MutexLockerEx ml(receiver-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);
2958       if (receiver-&gt;is_external_suspend()) {
2959         // Don't allow nested external suspend requests. We can't return
2960         // an error from this interface so just ignore the problem.
2961         return;
2962       }
2963       if (receiver-&gt;is_exiting()) { // thread is in the process of exiting
2964         return;
2965       }
2966       receiver-&gt;set_external_suspend();
2967     }
2968 
2969     // java_suspend() will catch threads in the process of exiting
2970     // and will ignore them.
2971     receiver-&gt;java_suspend();
2972 
2973     // It would be nice to have the following assertion in all the
2974     // time, but it is possible for a racing resume request to have
2975     // resumed this thread right after we suspended it. Temporarily
2976     // enable this assertion if you are chasing a different kind of
2977     // bug.
2978     //
2979     // assert(java_lang_Thread::thread(receiver-&gt;threadObj()) == NULL ||
2980     //   receiver-&gt;is_being_ext_suspended(), "thread is not suspended");
2981   }
2982 JVM_END
2983 
2984 
2985 JVM_ENTRY(void, JVM_ResumeThread(JNIEnv* env, jobject jthread))
2986   JVMWrapper("JVM_ResumeThread");
2987   // Ensure that the C++ Thread and OSThread structures aren't freed before we operate.
2988   // We need to *always* get the threads lock here, since this operation cannot be allowed during
2989   // a safepoint. The safepoint code relies on suspending a thread to examine its state. If other
2990   // threads randomly resumes threads, then a thread might not be suspended when the safepoint code
2991   // looks at it.
2992   MutexLocker ml(Threads_lock);
2993   JavaThread* thr = java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread));
2994   if (thr != NULL) {
2995     // the thread has run and is not in the process of exiting
2996     thr-&gt;java_resume();
2997   }
2998 JVM_END
2999 
3000 
3001 JVM_ENTRY(void, JVM_SetThreadPriority(JNIEnv* env, jobject jthread, jint prio))
3002   JVMWrapper("JVM_SetThreadPriority");
3003   // Ensure that the C++ Thread and OSThread structures aren't freed before we operate
3004   MutexLocker ml(Threads_lock);
3005   oop java_thread = JNIHandles::resolve_non_null(jthread);
3006   java_lang_Thread::set_priority(java_thread, (ThreadPriority)prio);
3007   JavaThread* thr = java_lang_Thread::thread(java_thread);
3008   if (thr != NULL) {                  // Thread not yet started; priority pushed down when it is
3009     Thread::set_priority(thr, (ThreadPriority)prio);
3010   }
3011 JVM_END
3012 
3013 
3014 JVM_ENTRY(void, JVM_Yield(JNIEnv *env, jclass threadClass))
3015   JVMWrapper("JVM_Yield");
3016   if (os::dont_yield()) return;
3017   HOTSPOT_THREAD_YIELD();
3018 
3019   // When ConvertYieldToSleep is off (default), this matches the classic VM use of yield.
3020   // Critical for similar threading behaviour
3021   if (ConvertYieldToSleep) {
3022     os::sleep(thread, MinSleepInterval, false);
3023   } else {
3024     os::yield();
3025   }
3026 JVM_END
3027 
3028 
3029 JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))
3030   JVMWrapper("JVM_Sleep");
3031 
3032   if (millis &lt; 0) {
3033     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), "timeout value is negative");
3034   }
3035 
3036   if (Thread::is_interrupted (THREAD, true) &amp;&amp; !HAS_PENDING_EXCEPTION) {
3037     THROW_MSG(vmSymbols::java_lang_InterruptedException(), "sleep interrupted");
3038   }
3039 
3040   // Save current thread state and restore it at the end of this block.
3041   // And set new thread state to SLEEPING.
3042   JavaThreadSleepState jtss(thread);
3043 
3044   HOTSPOT_THREAD_SLEEP_BEGIN(millis);
3045 
3046   EventThreadSleep event;
3047 
3048   if (millis == 0) {
3049     // When ConvertSleepToYield is on, this matches the classic VM implementation of
3050     // JVM_Sleep. Critical for similar threading behaviour (Win32)
3051     // It appears that in certain GUI contexts, it may be beneficial to do a short sleep
3052     // for SOLARIS
3053     if (ConvertSleepToYield) {
3054       os::yield();
3055     } else {
3056       ThreadState old_state = thread-&gt;osthread()-&gt;get_state();
3057       thread-&gt;osthread()-&gt;set_state(SLEEPING);
3058       os::sleep(thread, MinSleepInterval, false);
3059       thread-&gt;osthread()-&gt;set_state(old_state);
3060     }
3061   } else {
3062     ThreadState old_state = thread-&gt;osthread()-&gt;get_state();
3063     thread-&gt;osthread()-&gt;set_state(SLEEPING);
3064     if (os::sleep(thread, millis, true) == OS_INTRPT) {
3065       // An asynchronous exception (e.g., ThreadDeathException) could have been thrown on
3066       // us while we were sleeping. We do not overwrite those.
3067       if (!HAS_PENDING_EXCEPTION) {
3068         if (event.should_commit()) {
3069           event.set_time(millis);
3070           event.commit();
3071         }
3072         HOTSPOT_THREAD_SLEEP_END(1);
3073 
3074         // TODO-FIXME: THROW_MSG returns which means we will not call set_state()
3075         // to properly restore the thread state.  That's likely wrong.
3076         THROW_MSG(vmSymbols::java_lang_InterruptedException(), "sleep interrupted");
3077       }
3078     }
3079     thread-&gt;osthread()-&gt;set_state(old_state);
3080   }
3081   if (event.should_commit()) {
3082     event.set_time(millis);
3083     event.commit();
3084   }
3085   HOTSPOT_THREAD_SLEEP_END(0);
3086 JVM_END
3087 
3088 JVM_ENTRY(jobject, JVM_CurrentThread(JNIEnv* env, jclass threadClass))
3089   JVMWrapper("JVM_CurrentThread");
3090   oop jthread = thread-&gt;threadObj();
3091   assert (thread != NULL, "no current thread!");
3092   return JNIHandles::make_local(env, jthread);
3093 JVM_END
3094 
3095 
3096 JVM_ENTRY(jint, JVM_CountStackFrames(JNIEnv* env, jobject jthread))
3097   JVMWrapper("JVM_CountStackFrames");
3098 
3099   // Ensure that the C++ Thread and OSThread structures aren't freed before we operate
3100   oop java_thread = JNIHandles::resolve_non_null(jthread);
3101   bool throw_illegal_thread_state = false;
3102   int count = 0;
3103 
3104   {
3105     MutexLockerEx ml(thread-&gt;threadObj() == java_thread ? NULL : Threads_lock);
3106     // We need to re-resolve the java_thread, since a GC might have happened during the
3107     // acquire of the lock
3108     JavaThread* thr = java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread));
3109 
3110     if (thr == NULL) {
3111       // do nothing
3112     } else if(! thr-&gt;is_external_suspend() || ! thr-&gt;frame_anchor()-&gt;walkable()) {
3113       // Check whether this java thread has been suspended already. If not, throws
3114       // IllegalThreadStateException. We defer to throw that exception until
3115       // Threads_lock is released since loading exception class has to leave VM.
3116       // The correct way to test a thread is actually suspended is
3117       // wait_for_ext_suspend_completion(), but we can't call that while holding
3118       // the Threads_lock. The above tests are sufficient for our purposes
3119       // provided the walkability of the stack is stable - which it isn't
3120       // 100% but close enough for most practical purposes.
3121       throw_illegal_thread_state = true;
3122     } else {
3123       // Count all java activation, i.e., number of vframes
3124       for(vframeStream vfst(thr); !vfst.at_end(); vfst.next()) {
3125         // Native frames are not counted
3126         if (!vfst.method()-&gt;is_native()) count++;
3127        }
3128     }
3129   }
3130 
3131   if (throw_illegal_thread_state) {
3132     THROW_MSG_0(vmSymbols::java_lang_IllegalThreadStateException(),
3133                 "this thread is not suspended");
3134   }
3135   return count;
3136 JVM_END
3137 
3138 // Consider: A better way to implement JVM_Interrupt() is to acquire
3139 // Threads_lock to resolve the jthread into a Thread pointer, fetch
3140 // Thread-&gt;platformevent, Thread-&gt;native_thr, Thread-&gt;parker, etc.,
3141 // drop Threads_lock, and the perform the unpark() and thr_kill() operations
3142 // outside the critical section.  Threads_lock is hot so we want to minimize
3143 // the hold-time.  A cleaner interface would be to decompose interrupt into
3144 // two steps.  The 1st phase, performed under Threads_lock, would return
3145 // a closure that'd be invoked after Threads_lock was dropped.
3146 // This tactic is safe as PlatformEvent and Parkers are type-stable (TSM) and
3147 // admit spurious wakeups.
3148 
3149 JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))
3150   JVMWrapper("JVM_Interrupt");
3151 
3152   // Ensure that the C++ Thread and OSThread structures aren't freed before we operate
3153   oop java_thread = JNIHandles::resolve_non_null(jthread);
3154   MutexLockerEx ml(thread-&gt;threadObj() == java_thread ? NULL : Threads_lock);
3155   // We need to re-resolve the java_thread, since a GC might have happened during the
3156   // acquire of the lock
3157   JavaThread* thr = java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread));
3158   if (thr != NULL) {
3159     Thread::interrupt(thr);
3160   }
3161 JVM_END
3162 
3163 
3164 JVM_QUICK_ENTRY(jboolean, JVM_IsInterrupted(JNIEnv* env, jobject jthread, jboolean clear_interrupted))
3165   JVMWrapper("JVM_IsInterrupted");
3166 
3167   // Ensure that the C++ Thread and OSThread structures aren't freed before we operate
3168   oop java_thread = JNIHandles::resolve_non_null(jthread);
3169   MutexLockerEx ml(thread-&gt;threadObj() == java_thread ? NULL : Threads_lock);
3170   // We need to re-resolve the java_thread, since a GC might have happened during the
3171   // acquire of the lock
3172   JavaThread* thr = java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread));
3173   if (thr == NULL) {
3174     return JNI_FALSE;
3175   } else {
3176     return (jboolean) Thread::is_interrupted(thr, clear_interrupted != 0);
3177   }
3178 JVM_END
3179 
3180 
3181 // Return true iff the current thread has locked the object passed in
3182 
3183 JVM_ENTRY(jboolean, JVM_HoldsLock(JNIEnv* env, jclass threadClass, jobject obj))
3184   JVMWrapper("JVM_HoldsLock");
3185   assert(THREAD-&gt;is_Java_thread(), "sanity check");
3186   if (obj == NULL) {
3187     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_FALSE);
3188   }
3189   Handle h_obj(THREAD, JNIHandles::resolve(obj));
3190   return ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, h_obj);
3191 JVM_END
3192 
3193 
3194 JVM_ENTRY(void, JVM_DumpAllStacks(JNIEnv* env, jclass))
3195   JVMWrapper("JVM_DumpAllStacks");
3196   VM_PrintThreads op;
3197   VMThread::execute(&amp;op);
3198   if (JvmtiExport::should_post_data_dump()) {
3199     JvmtiExport::post_data_dump();
3200   }
3201 JVM_END
3202 
3203 JVM_ENTRY(void, JVM_SetNativeThreadName(JNIEnv* env, jobject jthread, jstring name))
3204   JVMWrapper("JVM_SetNativeThreadName");
3205   ResourceMark rm(THREAD);
3206   oop java_thread = JNIHandles::resolve_non_null(jthread);
3207   JavaThread* thr = java_lang_Thread::thread(java_thread);
3208   // Thread naming only supported for the current thread, doesn't work for
3209   // target threads.
3210   if (Thread::current() == thr &amp;&amp; !thr-&gt;has_attached_via_jni()) {
3211     // we don't set the name of an attached thread to avoid stepping
3212     // on other programs
3213     const char *thread_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3214     os::set_native_thread_name(thread_name);
3215   }
3216 JVM_END
3217 
3218 // java.lang.SecurityManager ///////////////////////////////////////////////////////////////////////
3219 
3220 static bool is_trusted_frame(JavaThread* jthread, vframeStream* vfst) {
3221   assert(jthread-&gt;is_Java_thread(), "must be a Java thread");
3222   if (jthread-&gt;privileged_stack_top() == NULL) return false;
3223   if (jthread-&gt;privileged_stack_top()-&gt;frame_id() == vfst-&gt;frame_id()) {
3224     oop loader = jthread-&gt;privileged_stack_top()-&gt;class_loader();
3225     if (loader == NULL) return true;
3226     bool trusted = java_lang_ClassLoader::is_trusted_loader(loader);
3227     if (trusted) return true;
3228   }
3229   return false;
3230 }
3231 
3232 JVM_ENTRY(jclass, JVM_CurrentLoadedClass(JNIEnv *env))
3233   JVMWrapper("JVM_CurrentLoadedClass");
3234   ResourceMark rm(THREAD);
3235 
3236   for (vframeStream vfst(thread); !vfst.at_end(); vfst.next()) {
3237     // if a method in a class in a trusted loader is in a doPrivileged, return NULL
3238     bool trusted = is_trusted_frame(thread, &amp;vfst);
3239     if (trusted) return NULL;
3240 
3241     Method* m = vfst.method();
3242     if (!m-&gt;is_native()) {
3243       InstanceKlass* holder = m-&gt;method_holder();
3244       oop loader = holder-&gt;class_loader();
3245       if (loader != NULL &amp;&amp; !java_lang_ClassLoader::is_trusted_loader(loader)) {
3246         return (jclass) JNIHandles::make_local(env, holder-&gt;java_mirror());
3247       }
3248     }
3249   }
3250   return NULL;
3251 JVM_END
3252 
3253 
3254 JVM_ENTRY(jobject, JVM_CurrentClassLoader(JNIEnv *env))
3255   JVMWrapper("JVM_CurrentClassLoader");
3256   ResourceMark rm(THREAD);
3257 
3258   for (vframeStream vfst(thread); !vfst.at_end(); vfst.next()) {
3259 
3260     // if a method in a class in a trusted loader is in a doPrivileged, return NULL
3261     bool trusted = is_trusted_frame(thread, &amp;vfst);
3262     if (trusted) return NULL;
3263 
3264     Method* m = vfst.method();
3265     if (!m-&gt;is_native()) {
3266       InstanceKlass* holder = m-&gt;method_holder();
3267       assert(holder-&gt;is_klass(), "just checking");
3268       oop loader = holder-&gt;class_loader();
3269       if (loader != NULL &amp;&amp; !java_lang_ClassLoader::is_trusted_loader(loader)) {
3270         return JNIHandles::make_local(env, loader);
3271       }
3272     }
3273   }
3274   return NULL;
3275 JVM_END
3276 
3277 
3278 JVM_ENTRY(jobjectArray, JVM_GetClassContext(JNIEnv *env))
3279   JVMWrapper("JVM_GetClassContext");
3280   ResourceMark rm(THREAD);
3281   JvmtiVMObjectAllocEventCollector oam;
3282   vframeStream vfst(thread);
3283 
3284   if (SystemDictionary::reflect_CallerSensitive_klass() != NULL) {
3285     // This must only be called from SecurityManager.getClassContext
3286     Method* m = vfst.method();
3287     if (!(m-&gt;method_holder() == SystemDictionary::SecurityManager_klass() &amp;&amp;
3288           m-&gt;name()          == vmSymbols::getClassContext_name() &amp;&amp;
3289           m-&gt;signature()     == vmSymbols::void_class_array_signature())) {
3290       THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), "JVM_GetClassContext must only be called from SecurityManager.getClassContext");
3291     }
3292   }
3293 
3294   // Collect method holders
3295   GrowableArray&lt;KlassHandle&gt;* klass_array = new GrowableArray&lt;KlassHandle&gt;();
3296   for (; !vfst.at_end(); vfst.security_next()) {
3297     Method* m = vfst.method();
3298     // Native frames are not returned
3299     if (!m-&gt;is_ignored_by_security_stack_walk() &amp;&amp; !m-&gt;is_native()) {
3300       Klass* holder = m-&gt;method_holder();
3301       assert(holder-&gt;is_klass(), "just checking");
3302       klass_array-&gt;append(holder);
3303     }
3304   }
3305 
3306   // Create result array of type [Ljava/lang/Class;
3307   objArrayOop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), klass_array-&gt;length(), CHECK_NULL);
3308   // Fill in mirrors corresponding to method holders
3309   for (int i = 0; i &lt; klass_array-&gt;length(); i++) {
3310     result-&gt;obj_at_put(i, klass_array-&gt;at(i)-&gt;java_mirror());
3311   }
3312 
3313   return (jobjectArray) JNIHandles::make_local(env, result);
3314 JVM_END
3315 
3316 
3317 JVM_ENTRY(jint, JVM_ClassDepth(JNIEnv *env, jstring name))
3318   JVMWrapper("JVM_ClassDepth");
3319   ResourceMark rm(THREAD);
3320   Handle h_name (THREAD, JNIHandles::resolve_non_null(name));
3321   Handle class_name_str = java_lang_String::internalize_classname(h_name, CHECK_0);
3322 
3323   const char* str = java_lang_String::as_utf8_string(class_name_str());
3324   TempNewSymbol class_name_sym = SymbolTable::probe(str, (int)strlen(str));
3325   if (class_name_sym == NULL) {
3326     return -1;
3327   }
3328 
3329   int depth = 0;
3330 
3331   for(vframeStream vfst(thread); !vfst.at_end(); vfst.next()) {
3332     if (!vfst.method()-&gt;is_native()) {
3333       InstanceKlass* holder = vfst.method()-&gt;method_holder();
3334       assert(holder-&gt;is_klass(), "just checking");
3335       if (holder-&gt;name() == class_name_sym) {
3336         return depth;
3337       }
3338       depth++;
3339     }
3340   }
3341   return -1;
3342 JVM_END
3343 
3344 
3345 JVM_ENTRY(jint, JVM_ClassLoaderDepth(JNIEnv *env))
3346   JVMWrapper("JVM_ClassLoaderDepth");
3347   ResourceMark rm(THREAD);
3348   int depth = 0;
3349   for (vframeStream vfst(thread); !vfst.at_end(); vfst.next()) {
3350     // if a method in a class in a trusted loader is in a doPrivileged, return -1
3351     bool trusted = is_trusted_frame(thread, &amp;vfst);
3352     if (trusted) return -1;
3353 
3354     Method* m = vfst.method();
3355     if (!m-&gt;is_native()) {
3356       InstanceKlass* holder = m-&gt;method_holder();
3357       assert(holder-&gt;is_klass(), "just checking");
3358       oop loader = holder-&gt;class_loader();
3359       if (loader != NULL &amp;&amp; !java_lang_ClassLoader::is_trusted_loader(loader)) {
3360         return depth;
3361       }
3362       depth++;
3363     }
3364   }
3365   return -1;
3366 JVM_END
3367 
3368 
3369 // java.lang.Package ////////////////////////////////////////////////////////////////
3370 
3371 
3372 JVM_ENTRY(jstring, JVM_GetSystemPackage(JNIEnv *env, jstring name))
3373   JVMWrapper("JVM_GetSystemPackage");
3374   ResourceMark rm(THREAD);
3375   JvmtiVMObjectAllocEventCollector oam;
3376   char* str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3377   oop result = ClassLoader::get_system_package(str, CHECK_NULL);
3378   return (jstring) JNIHandles::make_local(result);
3379 JVM_END
3380 
3381 
3382 JVM_ENTRY(jobjectArray, JVM_GetSystemPackages(JNIEnv *env))
3383   JVMWrapper("JVM_GetSystemPackages");
3384   JvmtiVMObjectAllocEventCollector oam;
3385   objArrayOop result = ClassLoader::get_system_packages(CHECK_NULL);
3386   return (jobjectArray) JNIHandles::make_local(result);
3387 JVM_END
3388 
3389 
3390 // ObjectInputStream ///////////////////////////////////////////////////////////////
3391 
3392 bool force_verify_field_access(Klass* current_class, Klass* field_class, AccessFlags access, bool classloader_only) {
3393   if (current_class == NULL) {
3394     return true;
3395   }
3396   if ((current_class == field_class) || access.is_public()) {
3397     return true;
3398   }
3399 
3400   if (access.is_protected()) {
3401     // See if current_class is a subclass of field_class
3402     if (current_class-&gt;is_subclass_of(field_class)) {
3403       return true;
3404     }
3405   }
3406 
3407   return (!access.is_private() &amp;&amp; InstanceKlass::cast(current_class)-&gt;is_same_class_package(field_class));
3408 }
3409 
3410 
3411 // JVM_AllocateNewObject and JVM_AllocateNewArray are unused as of 1.4
3412 JVM_ENTRY(jobject, JVM_AllocateNewObject(JNIEnv *env, jobject receiver, jclass currClass, jclass initClass))
3413   JVMWrapper("JVM_AllocateNewObject");
3414   JvmtiVMObjectAllocEventCollector oam;
3415   // Receiver is not used
3416   oop curr_mirror = JNIHandles::resolve_non_null(currClass);
3417   oop init_mirror = JNIHandles::resolve_non_null(initClass);
3418 
3419   // Cannot instantiate primitive types
3420   if (java_lang_Class::is_primitive(curr_mirror) || java_lang_Class::is_primitive(init_mirror)) {
3421     ResourceMark rm(THREAD);
3422     THROW_0(vmSymbols::java_lang_InvalidClassException());
3423   }
3424 
3425   // Arrays not allowed here, must use JVM_AllocateNewArray
3426   if (java_lang_Class::as_Klass(curr_mirror)-&gt;oop_is_array() ||
3427       java_lang_Class::as_Klass(init_mirror)-&gt;oop_is_array()) {
3428     ResourceMark rm(THREAD);
3429     THROW_0(vmSymbols::java_lang_InvalidClassException());
3430   }
3431 
3432   instanceKlassHandle curr_klass (THREAD, java_lang_Class::as_Klass(curr_mirror));
3433   instanceKlassHandle init_klass (THREAD, java_lang_Class::as_Klass(init_mirror));
3434 
3435   assert(curr_klass-&gt;is_subclass_of(init_klass()), "just checking");
3436 
3437   // Interfaces, abstract classes, and java.lang.Class classes cannot be instantiated directly.
3438   curr_klass-&gt;check_valid_for_instantiation(false, CHECK_NULL);
3439 
3440   // Make sure klass is initialized, since we are about to instantiate one of them.
3441   curr_klass-&gt;initialize(CHECK_NULL);
3442 
3443  methodHandle m (THREAD,
3444                  init_klass-&gt;find_method(vmSymbols::object_initializer_name(),
3445                                          vmSymbols::void_method_signature()));
3446   if (m.is_null()) {
3447     ResourceMark rm(THREAD);
3448     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(),
3449                 Method::name_and_sig_as_C_string(init_klass(),
3450                                           vmSymbols::object_initializer_name(),
3451                                           vmSymbols::void_method_signature()));
3452   }
3453 
3454   if (curr_klass ==  init_klass &amp;&amp; !m-&gt;is_public()) {
3455     // Calling the constructor for class 'curr_klass'.
3456     // Only allow calls to a public no-arg constructor.
3457     // This path corresponds to creating an Externalizable object.
3458     THROW_0(vmSymbols::java_lang_IllegalAccessException());
3459   }
3460 
3461   if (!force_verify_field_access(curr_klass(), init_klass(), m-&gt;access_flags(), false)) {
3462     // subclass 'curr_klass' does not have access to no-arg constructor of 'initcb'
3463     THROW_0(vmSymbols::java_lang_IllegalAccessException());
3464   }
3465 
3466   Handle obj = curr_klass-&gt;allocate_instance_handle(CHECK_NULL);
3467   // Call constructor m. This might call a constructor higher up in the hierachy
3468   JavaCalls::call_default_constructor(thread, m, obj, CHECK_NULL);
3469 
3470   return JNIHandles::make_local(obj());
3471 JVM_END
3472 
3473 
3474 JVM_ENTRY(jobject, JVM_AllocateNewArray(JNIEnv *env, jobject obj, jclass currClass, jint length))
3475   JVMWrapper("JVM_AllocateNewArray");
3476   JvmtiVMObjectAllocEventCollector oam;
3477   oop mirror = JNIHandles::resolve_non_null(currClass);
3478 
3479   if (java_lang_Class::is_primitive(mirror)) {
3480     THROW_0(vmSymbols::java_lang_InvalidClassException());
3481   }
3482   Klass* k = java_lang_Class::as_Klass(mirror);
3483   oop result;
3484 
3485   if (k-&gt;oop_is_typeArray()) {
3486     // typeArray
3487     result = TypeArrayKlass::cast(k)-&gt;allocate(length, CHECK_NULL);
3488   } else if (k-&gt;oop_is_objArray()) {
3489     // objArray
3490     ObjArrayKlass* oak = ObjArrayKlass::cast(k);
3491     oak-&gt;initialize(CHECK_NULL); // make sure class is initialized (matches Classic VM behavior)
3492     result = oak-&gt;allocate(length, CHECK_NULL);
3493   } else {
3494     THROW_0(vmSymbols::java_lang_InvalidClassException());
3495   }
3496   return JNIHandles::make_local(env, result);
3497 JVM_END
3498 
3499 
3500 // Return the first non-null class loader up the execution stack, or null
3501 // if only code from the null class loader is on the stack.
3502 
3503 JVM_ENTRY(jobject, JVM_LatestUserDefinedLoader(JNIEnv *env))
3504   for (vframeStream vfst(thread); !vfst.at_end(); vfst.next()) {
3505     vfst.skip_reflection_related_frames(); // Only needed for 1.4 reflection
3506     oop loader = vfst.method()-&gt;method_holder()-&gt;class_loader();
3507     if (loader != NULL) {
3508       return JNIHandles::make_local(env, loader);
3509     }
3510   }
3511   return NULL;
3512 JVM_END
3513 
3514 
3515 // Load a class relative to the most recent class on the stack  with a non-null
3516 // classloader.
3517 // This function has been deprecated and should not be considered part of the
3518 // specified JVM interface.
3519 
3520 JVM_ENTRY(jclass, JVM_LoadClass0(JNIEnv *env, jobject receiver,
3521                                  jclass currClass, jstring currClassName))
3522   JVMWrapper("JVM_LoadClass0");
3523   // Receiver is not used
3524   ResourceMark rm(THREAD);
3525 
3526   // Class name argument is not guaranteed to be in internal format
3527   Handle classname (THREAD, JNIHandles::resolve_non_null(currClassName));
3528   Handle string = java_lang_String::internalize_classname(classname, CHECK_NULL);
3529 
3530   const char* str = java_lang_String::as_utf8_string(string());
3531 
3532   if (str == NULL || (int)strlen(str) &gt; Symbol::max_length()) {
3533     // It's impossible to create this class;  the name cannot fit
3534     // into the constant pool.
3535     THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), str);
3536   }
3537 
3538   TempNewSymbol name = SymbolTable::new_symbol(str, CHECK_NULL);
3539   Handle curr_klass (THREAD, JNIHandles::resolve(currClass));
3540   // Find the most recent class on the stack with a non-null classloader
3541   oop loader = NULL;
3542   oop protection_domain = NULL;
3543   if (curr_klass.is_null()) {
3544     for (vframeStream vfst(thread);
3545          !vfst.at_end() &amp;&amp; loader == NULL;
3546          vfst.next()) {
3547       if (!vfst.method()-&gt;is_native()) {
3548         InstanceKlass* holder = vfst.method()-&gt;method_holder();
3549         loader             = holder-&gt;class_loader();
3550         protection_domain  = holder-&gt;protection_domain();
3551       }
3552     }
3553   } else {
3554     Klass* curr_klass_oop = java_lang_Class::as_Klass(curr_klass());
3555     loader            = InstanceKlass::cast(curr_klass_oop)-&gt;class_loader();
3556     protection_domain = InstanceKlass::cast(curr_klass_oop)-&gt;protection_domain();
3557   }
3558   Handle h_loader(THREAD, loader);
3559   Handle h_prot  (THREAD, protection_domain);
3560   jclass result =  find_class_from_class_loader(env, name, true, h_loader, h_prot,
3561                                                 false, thread);
3562   if (TraceClassResolution &amp;&amp; result != NULL) {
3563     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
3564   }
3565   return result;
3566 JVM_END
3567 
3568 
3569 // Array ///////////////////////////////////////////////////////////////////////////////////////////
3570 
3571 
3572 // resolve array handle and check arguments
3573 static inline arrayOop check_array(JNIEnv *env, jobject arr, bool type_array_only, TRAPS) {
3574   if (arr == NULL) {
3575     THROW_0(vmSymbols::java_lang_NullPointerException());
3576   }
3577   oop a = JNIHandles::resolve_non_null(arr);
3578   if (!a-&gt;is_array() || (type_array_only &amp;&amp; !a-&gt;is_typeArray())) {
3579     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Argument is not an array");
3580   }
3581   return arrayOop(a);
3582 }
3583 
3584 
3585 JVM_ENTRY(jint, JVM_GetArrayLength(JNIEnv *env, jobject arr))
3586   JVMWrapper("JVM_GetArrayLength");
3587   arrayOop a = check_array(env, arr, false, CHECK_0);
3588   return a-&gt;length();
3589 JVM_END
3590 
3591 
3592 JVM_ENTRY(jobject, JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index))
3593   JVMWrapper("JVM_Array_Get");
3594   JvmtiVMObjectAllocEventCollector oam;
3595   arrayOop a = check_array(env, arr, false, CHECK_NULL);
3596   jvalue value;
3597   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_NULL);
3598   oop box = Reflection::box(&amp;value, type, CHECK_NULL);
3599   return JNIHandles::make_local(env, box);
3600 JVM_END
3601 
3602 
3603 JVM_ENTRY(jvalue, JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode))
3604   JVMWrapper("JVM_GetPrimitiveArrayElement");
3605   jvalue value;
3606   value.i = 0; // to initialize value before getting used in CHECK
3607   arrayOop a = check_array(env, arr, true, CHECK_(value));
3608   assert(a-&gt;is_typeArray(), "just checking");
3609   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_(value));
3610   BasicType wide_type = (BasicType) wCode;
3611   if (type != wide_type) {
3612     Reflection::widen(&amp;value, type, wide_type, CHECK_(value));
3613   }
3614   return value;
3615 JVM_END
3616 
3617 
3618 JVM_ENTRY(void, JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val))
3619   JVMWrapper("JVM_SetArrayElement");
3620   arrayOop a = check_array(env, arr, false, CHECK);
3621   oop box = JNIHandles::resolve(val);
3622   jvalue value;
3623   value.i = 0; // to initialize value before getting used in CHECK
3624   BasicType value_type;
3625   if (a-&gt;is_objArray()) {
3626     // Make sure we do no unbox e.g. java/lang/Integer instances when storing into an object array
3627     value_type = Reflection::unbox_for_regular_object(box, &amp;value);
3628   } else {
3629     value_type = Reflection::unbox_for_primitive(box, &amp;value, CHECK);
3630   }
3631   Reflection::array_set(&amp;value, a, index, value_type, CHECK);
3632 JVM_END
3633 
3634 
3635 JVM_ENTRY(void, JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v, unsigned char vCode))
3636   JVMWrapper("JVM_SetPrimitiveArrayElement");
3637   arrayOop a = check_array(env, arr, true, CHECK);
3638   assert(a-&gt;is_typeArray(), "just checking");
3639   BasicType value_type = (BasicType) vCode;
3640   Reflection::array_set(&amp;v, a, index, value_type, CHECK);
3641 JVM_END
3642 
3643 
3644 JVM_ENTRY(jobject, JVM_NewArray(JNIEnv *env, jclass eltClass, jint length))
3645   JVMWrapper("JVM_NewArray");
3646   JvmtiVMObjectAllocEventCollector oam;
3647   oop element_mirror = JNIHandles::resolve(eltClass);
3648   oop result = Reflection::reflect_new_array(element_mirror, length, CHECK_NULL);
3649   return JNIHandles::make_local(env, result);
3650 JVM_END
3651 
3652 
3653 JVM_ENTRY(jobject, JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim))
3654   JVMWrapper("JVM_NewMultiArray");
3655   JvmtiVMObjectAllocEventCollector oam;
3656   arrayOop dim_array = check_array(env, dim, true, CHECK_NULL);
3657   oop element_mirror = JNIHandles::resolve(eltClass);
3658   assert(dim_array-&gt;is_typeArray(), "just checking");
3659   oop result = Reflection::reflect_new_multi_array(element_mirror, typeArrayOop(dim_array), CHECK_NULL);
3660   return JNIHandles::make_local(env, result);
3661 JVM_END
3662 
3663 
3664 // Networking library support ////////////////////////////////////////////////////////////////////
3665 
3666 JVM_LEAF(jint, JVM_InitializeSocketLibrary())
3667   JVMWrapper("JVM_InitializeSocketLibrary");
3668   return 0;
3669 JVM_END
3670 
3671 
3672 JVM_LEAF(jint, JVM_Socket(jint domain, jint type, jint protocol))
3673   JVMWrapper("JVM_Socket");
3674   return os::socket(domain, type, protocol);
3675 JVM_END
3676 
3677 
3678 JVM_LEAF(jint, JVM_SocketClose(jint fd))
3679   JVMWrapper2("JVM_SocketClose (0x%x)", fd);
3680   //%note jvm_r6
3681   return os::socket_close(fd);
3682 JVM_END
3683 
3684 
3685 JVM_LEAF(jint, JVM_SocketShutdown(jint fd, jint howto))
3686   JVMWrapper2("JVM_SocketShutdown (0x%x)", fd);
3687   //%note jvm_r6
3688   return os::socket_shutdown(fd, howto);
3689 JVM_END
3690 
3691 
3692 JVM_LEAF(jint, JVM_Recv(jint fd, char *buf, jint nBytes, jint flags))
3693   JVMWrapper2("JVM_Recv (0x%x)", fd);
3694   //%note jvm_r6
3695   return os::recv(fd, buf, (size_t)nBytes, (uint)flags);
3696 JVM_END
3697 
3698 
3699 JVM_LEAF(jint, JVM_Send(jint fd, char *buf, jint nBytes, jint flags))
3700   JVMWrapper2("JVM_Send (0x%x)", fd);
3701   //%note jvm_r6
3702   return os::send(fd, buf, (size_t)nBytes, (uint)flags);
3703 JVM_END
3704 
3705 
3706 JVM_LEAF(jint, JVM_Timeout(int fd, long timeout))
3707   JVMWrapper2("JVM_Timeout (0x%x)", fd);
3708   //%note jvm_r6
3709   return os::timeout(fd, timeout);
3710 JVM_END
3711 
3712 
3713 JVM_LEAF(jint, JVM_Listen(jint fd, jint count))
3714   JVMWrapper2("JVM_Listen (0x%x)", fd);
3715   //%note jvm_r6
3716   return os::listen(fd, count);
3717 JVM_END
3718 
3719 
3720 JVM_LEAF(jint, JVM_Connect(jint fd, struct sockaddr *him, jint len))
3721   JVMWrapper2("JVM_Connect (0x%x)", fd);
3722   //%note jvm_r6
3723   return os::connect(fd, him, (socklen_t)len);
3724 JVM_END
3725 
3726 
3727 JVM_LEAF(jint, JVM_Bind(jint fd, struct sockaddr *him, jint len))
3728   JVMWrapper2("JVM_Bind (0x%x)", fd);
3729   //%note jvm_r6
3730   return os::bind(fd, him, (socklen_t)len);
3731 JVM_END
3732 
3733 
3734 JVM_LEAF(jint, JVM_Accept(jint fd, struct sockaddr *him, jint *len))
3735   JVMWrapper2("JVM_Accept (0x%x)", fd);
3736   //%note jvm_r6
3737   socklen_t socklen = (socklen_t)(*len);
3738   jint result = os::accept(fd, him, &amp;socklen);
3739   *len = (jint)socklen;
3740   return result;
3741 JVM_END
3742 
3743 
3744 JVM_LEAF(jint, JVM_RecvFrom(jint fd, char *buf, int nBytes, int flags, struct sockaddr *from, int *fromlen))
3745   JVMWrapper2("JVM_RecvFrom (0x%x)", fd);
3746   //%note jvm_r6
3747   socklen_t socklen = (socklen_t)(*fromlen);
3748   jint result = os::recvfrom(fd, buf, (size_t)nBytes, (uint)flags, from, &amp;socklen);
3749   *fromlen = (int)socklen;
3750   return result;
3751 JVM_END
3752 
3753 
3754 JVM_LEAF(jint, JVM_GetSockName(jint fd, struct sockaddr *him, int *len))
3755   JVMWrapper2("JVM_GetSockName (0x%x)", fd);
3756   //%note jvm_r6
3757   socklen_t socklen = (socklen_t)(*len);
3758   jint result = os::get_sock_name(fd, him, &amp;socklen);
3759   *len = (int)socklen;
3760   return result;
3761 JVM_END
3762 
3763 
3764 JVM_LEAF(jint, JVM_SendTo(jint fd, char *buf, int len, int flags, struct sockaddr *to, int tolen))
3765   JVMWrapper2("JVM_SendTo (0x%x)", fd);
3766   //%note jvm_r6
3767   return os::sendto(fd, buf, (size_t)len, (uint)flags, to, (socklen_t)tolen);
3768 JVM_END
3769 
3770 
3771 JVM_LEAF(jint, JVM_SocketAvailable(jint fd, jint *pbytes))
3772   JVMWrapper2("JVM_SocketAvailable (0x%x)", fd);
3773   //%note jvm_r6
3774   return os::socket_available(fd, pbytes);
3775 JVM_END
3776 
3777 
3778 JVM_LEAF(jint, JVM_GetSockOpt(jint fd, int level, int optname, char *optval, int *optlen))
3779   JVMWrapper2("JVM_GetSockOpt (0x%x)", fd);
3780   //%note jvm_r6
3781   socklen_t socklen = (socklen_t)(*optlen);
3782   jint result = os::get_sock_opt(fd, level, optname, optval, &amp;socklen);
3783   *optlen = (int)socklen;
3784   return result;
3785 JVM_END
3786 
3787 
3788 JVM_LEAF(jint, JVM_SetSockOpt(jint fd, int level, int optname, const char *optval, int optlen))
3789   JVMWrapper2("JVM_GetSockOpt (0x%x)", fd);
3790   //%note jvm_r6
3791   return os::set_sock_opt(fd, level, optname, optval, (socklen_t)optlen);
3792 JVM_END
3793 
3794 
3795 JVM_LEAF(int, JVM_GetHostName(char* name, int namelen))
3796   JVMWrapper("JVM_GetHostName");
3797   return os::get_host_name(name, namelen);
3798 JVM_END
3799 
3800 
3801 // Library support ///////////////////////////////////////////////////////////////////////////
3802 
3803 JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name))
3804   //%note jvm_ct
3805   JVMWrapper2("JVM_LoadLibrary (%s)", name);
3806   char ebuf[1024];
3807   void *load_result;
3808   {
3809     ThreadToNativeFromVM ttnfvm(thread);
3810     load_result = os::dll_load(name, ebuf, sizeof ebuf);
3811   }
3812   if (load_result == NULL) {
3813     char msg[1024];
3814     jio_snprintf(msg, sizeof msg, "%s: %s", name, ebuf);
3815     // Since 'ebuf' may contain a string encoded using
3816     // platform encoding scheme, we need to pass
3817     // Exceptions::unsafe_to_utf8 to the new_exception method
3818     // as the last argument. See bug 6367357.
3819     Handle h_exception =
3820       Exceptions::new_exception(thread,
3821                                 vmSymbols::java_lang_UnsatisfiedLinkError(),
3822                                 msg, Exceptions::unsafe_to_utf8);
3823 
3824     THROW_HANDLE_0(h_exception);
3825   }
3826   return load_result;
3827 JVM_END
3828 
3829 
3830 JVM_LEAF(void, JVM_UnloadLibrary(void* handle))
3831   JVMWrapper("JVM_UnloadLibrary");
3832   os::dll_unload(handle);
3833 JVM_END
3834 
3835 
3836 JVM_LEAF(void*, JVM_FindLibraryEntry(void* handle, const char* name))
3837   JVMWrapper2("JVM_FindLibraryEntry (%s)", name);
3838   return os::dll_lookup(handle, name);
3839 JVM_END
3840 
3841 
3842 // Floating point support ////////////////////////////////////////////////////////////////////
3843 
3844 JVM_LEAF(jboolean, JVM_IsNaN(jdouble a))
3845   JVMWrapper("JVM_IsNaN");
3846   return g_isnan(a);
3847 JVM_END
3848 
3849 
3850 // JNI version ///////////////////////////////////////////////////////////////////////////////
3851 
3852 JVM_LEAF(jboolean, JVM_IsSupportedJNIVersion(jint version))
3853   JVMWrapper2("JVM_IsSupportedJNIVersion (%d)", version);
3854   return Threads::is_supported_jni_version_including_1_1(version);
3855 JVM_END
3856 
3857 
3858 // String support ///////////////////////////////////////////////////////////////////////////
3859 
3860 JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))
3861   JVMWrapper("JVM_InternString");
3862   JvmtiVMObjectAllocEventCollector oam;
3863   if (str == NULL) return NULL;
3864   oop string = JNIHandles::resolve_non_null(str);
3865   oop result = StringTable::intern(string, CHECK_NULL);
3866   return (jstring) JNIHandles::make_local(env, result);
3867 JVM_END
3868 
3869 
3870 // Raw monitor support //////////////////////////////////////////////////////////////////////
3871 
3872 // The lock routine below calls lock_without_safepoint_check in order to get a raw lock
3873 // without interfering with the safepoint mechanism. The routines are not JVM_LEAF because
3874 // they might be called by non-java threads. The JVM_LEAF installs a NoHandleMark check
3875 // that only works with java threads.
3876 
3877 
3878 JNIEXPORT void* JNICALL JVM_RawMonitorCreate(void) {
3879   VM_Exit::block_if_vm_exited();
3880   JVMWrapper("JVM_RawMonitorCreate");
3881   return new Mutex(Mutex::native, "JVM_RawMonitorCreate");
3882 }
3883 
3884 
3885 JNIEXPORT void JNICALL  JVM_RawMonitorDestroy(void *mon) {
3886   VM_Exit::block_if_vm_exited();
3887   JVMWrapper("JVM_RawMonitorDestroy");
3888   delete ((Mutex*) mon);
3889 }
3890 
3891 
3892 JNIEXPORT jint JNICALL JVM_RawMonitorEnter(void *mon) {
3893   VM_Exit::block_if_vm_exited();
3894   JVMWrapper("JVM_RawMonitorEnter");
3895   ((Mutex*) mon)-&gt;jvm_raw_lock();
3896   return 0;
3897 }
3898 
3899 
3900 JNIEXPORT void JNICALL JVM_RawMonitorExit(void *mon) {
3901   VM_Exit::block_if_vm_exited();
3902   JVMWrapper("JVM_RawMonitorExit");
3903   ((Mutex*) mon)-&gt;jvm_raw_unlock();
3904 }
3905 
3906 
3907 // Support for Serialization
3908 
3909 typedef jfloat  (JNICALL *IntBitsToFloatFn  )(JNIEnv* env, jclass cb, jint    value);
3910 typedef jdouble (JNICALL *LongBitsToDoubleFn)(JNIEnv* env, jclass cb, jlong   value);
3911 typedef jint    (JNICALL *FloatToIntBitsFn  )(JNIEnv* env, jclass cb, jfloat  value);
3912 typedef jlong   (JNICALL *DoubleToLongBitsFn)(JNIEnv* env, jclass cb, jdouble value);
3913 
3914 static IntBitsToFloatFn   int_bits_to_float_fn   = NULL;
3915 static LongBitsToDoubleFn long_bits_to_double_fn = NULL;
3916 static FloatToIntBitsFn   float_to_int_bits_fn   = NULL;
3917 static DoubleToLongBitsFn double_to_long_bits_fn = NULL;
3918 
3919 
3920 void initialize_converter_functions() {
3921   if (JDK_Version::is_gte_jdk14x_version()) {
3922     // These functions only exist for compatibility with 1.3.1 and earlier
3923     return;
3924   }
3925 
3926   // called from universe_post_init()
3927   assert(
3928     int_bits_to_float_fn   == NULL &amp;&amp;
3929     long_bits_to_double_fn == NULL &amp;&amp;
3930     float_to_int_bits_fn   == NULL &amp;&amp;
3931     double_to_long_bits_fn == NULL ,
3932     "initialization done twice"
3933   );
3934   // initialize
3935   int_bits_to_float_fn   = CAST_TO_FN_PTR(IntBitsToFloatFn  , NativeLookup::base_library_lookup("java/lang/Float" , "intBitsToFloat"  , "(I)F"));
3936   long_bits_to_double_fn = CAST_TO_FN_PTR(LongBitsToDoubleFn, NativeLookup::base_library_lookup("java/lang/Double", "longBitsToDouble", "(J)D"));
3937   float_to_int_bits_fn   = CAST_TO_FN_PTR(FloatToIntBitsFn  , NativeLookup::base_library_lookup("java/lang/Float" , "floatToIntBits"  , "(F)I"));
3938   double_to_long_bits_fn = CAST_TO_FN_PTR(DoubleToLongBitsFn, NativeLookup::base_library_lookup("java/lang/Double", "doubleToLongBits", "(D)J"));
3939   // verify
3940   assert(
3941     int_bits_to_float_fn   != NULL &amp;&amp;
3942     long_bits_to_double_fn != NULL &amp;&amp;
3943     float_to_int_bits_fn   != NULL &amp;&amp;
3944     double_to_long_bits_fn != NULL ,
3945     "initialization failed"
3946   );
3947 }
3948 
3949 
3950 
3951 // Shared JNI/JVM entry points //////////////////////////////////////////////////////////////
3952 
3953 jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init, Handle loader, Handle protection_domain, jboolean throwError, TRAPS) {
3954   // Security Note:
3955   //   The Java level wrapper will perform the necessary security check allowing
3956   //   us to pass the NULL as the initiating class loader.
3957   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3958 
3959   KlassHandle klass_handle(THREAD, klass);
3960   // Check if we should initialize the class
3961   if (init &amp;&amp; klass_handle-&gt;oop_is_instance()) {
3962     klass_handle-&gt;initialize(CHECK_NULL);
3963   }
3964   return (jclass) JNIHandles::make_local(env, klass_handle-&gt;java_mirror());
3965 }
3966 
3967 
3968 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3969 
3970 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3971   JVMWrapper("JVM_InvokeMethod");
3972   Handle method_handle;
3973   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3974     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3975     Handle receiver(THREAD, JNIHandles::resolve(obj));
3976     objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
3977     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3978     jobject res = JNIHandles::make_local(env, result);
3979     if (JvmtiExport::should_post_vm_object_alloc()) {
3980       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3981       assert(ret_type != NULL, "sanity check: ret_type oop must not be NULL!");
3982       if (java_lang_Class::is_primitive(ret_type)) {
3983         // Only for primitive type vm allocates memory for java object.
3984         // See box() method.
3985         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3986       }
3987     }
3988     return res;
3989   } else {
3990     THROW_0(vmSymbols::java_lang_StackOverflowError());
3991   }
3992 JVM_END
3993 
3994 
3995 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3996   JVMWrapper("JVM_NewInstanceFromConstructor");
3997   oop constructor_mirror = JNIHandles::resolve(c);
3998   objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
3999   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
4000   jobject res = JNIHandles::make_local(env, result);
4001   if (JvmtiExport::should_post_vm_object_alloc()) {
4002     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
4003   }
4004   return res;
4005 JVM_END
4006 
4007 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
4008 
4009 JVM_LEAF(jboolean, JVM_SupportsCX8())
4010   JVMWrapper("JVM_SupportsCX8");
4011   return VM_Version::supports_cx8();
4012 JVM_END
4013 
4014 
4015 JVM_ENTRY(jboolean, JVM_CX8Field(JNIEnv *env, jobject obj, jfieldID fid, jlong oldVal, jlong newVal))
4016   JVMWrapper("JVM_CX8Field");
4017   jlong res;
4018   oop             o       = JNIHandles::resolve(obj);
4019   intptr_t        fldOffs = jfieldIDWorkaround::from_instance_jfieldID(o-&gt;klass(), fid);
4020   volatile jlong* addr    = (volatile jlong*)((address)o + fldOffs);
4021 
4022   assert(VM_Version::supports_cx8(), "cx8 not supported");
4023   res = Atomic::cmpxchg(newVal, addr, oldVal);
4024 
4025   return res == oldVal;
4026 JVM_END
4027 
4028 // DTrace ///////////////////////////////////////////////////////////////////
4029 
4030 JVM_ENTRY(jint, JVM_DTraceGetVersion(JNIEnv* env))
4031   JVMWrapper("JVM_DTraceGetVersion");
4032   return (jint)JVM_TRACING_DTRACE_VERSION;
4033 JVM_END
4034 
4035 JVM_ENTRY(jlong,JVM_DTraceActivate(
4036     JNIEnv* env, jint version, jstring module_name, jint providers_count,
4037     JVM_DTraceProvider* providers))
4038   JVMWrapper("JVM_DTraceActivate");
4039   return DTraceJSDT::activate(
4040     version, module_name, providers_count, providers, CHECK_0);
4041 JVM_END
4042 
4043 JVM_ENTRY(jboolean,JVM_DTraceIsProbeEnabled(JNIEnv* env, jmethodID method))
4044   JVMWrapper("JVM_DTraceIsProbeEnabled");
4045   return DTraceJSDT::is_probe_enabled(method);
4046 JVM_END
4047 
4048 JVM_ENTRY(void,JVM_DTraceDispose(JNIEnv* env, jlong handle))
4049   JVMWrapper("JVM_DTraceDispose");
4050   DTraceJSDT::dispose(handle);
4051 JVM_END
4052 
4053 JVM_ENTRY(jboolean,JVM_DTraceIsSupported(JNIEnv* env))
4054   JVMWrapper("JVM_DTraceIsSupported");
4055   return DTraceJSDT::is_supported();
4056 JVM_END
4057 
4058 // Returns an array of all live Thread objects (VM internal JavaThreads,
4059 // jvmti agent threads, and JNI attaching threads  are skipped)
4060 // See CR 6404306 regarding JNI attaching threads
4061 JVM_ENTRY(jobjectArray, JVM_GetAllThreads(JNIEnv *env, jclass dummy))
4062   ResourceMark rm(THREAD);
4063   ThreadsListEnumerator tle(THREAD, false, false);
4064   JvmtiVMObjectAllocEventCollector oam;
4065 
4066   int num_threads = tle.num_threads();
4067   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Thread_klass(), num_threads, CHECK_NULL);
4068   objArrayHandle threads_ah(THREAD, r);
4069 
4070   for (int i = 0; i &lt; num_threads; i++) {
4071     Handle h = tle.get_threadObj(i);
4072     threads_ah-&gt;obj_at_put(i, h());
4073   }
4074 
4075   return (jobjectArray) JNIHandles::make_local(env, threads_ah());
4076 JVM_END
4077 
4078 
4079 // Support for java.lang.Thread.getStackTrace() and getAllStackTraces() methods
4080 // Return StackTraceElement[][], each element is the stack trace of a thread in
4081 // the corresponding entry in the given threads array
4082 JVM_ENTRY(jobjectArray, JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads))
4083   JVMWrapper("JVM_DumpThreads");
4084   JvmtiVMObjectAllocEventCollector oam;
4085 
4086   // Check if threads is null
4087   if (threads == NULL) {
4088     THROW_(vmSymbols::java_lang_NullPointerException(), 0);
4089   }
4090 
4091   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(threads));
4092   objArrayHandle ah(THREAD, a);
4093   int num_threads = ah-&gt;length();
4094   // check if threads is non-empty array
4095   if (num_threads == 0) {
4096     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
4097   }
4098 
4099   // check if threads is not an array of objects of Thread class
4100   Klass* k = ObjArrayKlass::cast(ah-&gt;klass())-&gt;element_klass();
4101   if (k != SystemDictionary::Thread_klass()) {
4102     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
4103   }
4104 
4105   ResourceMark rm(THREAD);
4106 
4107   GrowableArray&lt;instanceHandle&gt;* thread_handle_array = new GrowableArray&lt;instanceHandle&gt;(num_threads);
4108   for (int i = 0; i &lt; num_threads; i++) {
4109     oop thread_obj = ah-&gt;obj_at(i);
4110     instanceHandle h(THREAD, (instanceOop) thread_obj);
4111     thread_handle_array-&gt;append(h);
4112   }
4113 
4114   Handle stacktraces = ThreadService::dump_stack_traces(thread_handle_array, num_threads, CHECK_NULL);
4115   return (jobjectArray)JNIHandles::make_local(env, stacktraces());
4116 
4117 JVM_END
4118 
4119 // JVM monitoring and management support
4120 JVM_ENTRY_NO_ENV(void*, JVM_GetManagement(jint version))
4121   return Management::get_jmm_interface(version);
4122 JVM_END
4123 
4124 // com.sun.tools.attach.VirtualMachine agent properties support
4125 //
4126 // Initialize the agent properties with the properties maintained in the VM
4127 JVM_ENTRY(jobject, JVM_InitAgentProperties(JNIEnv *env, jobject properties))
4128   JVMWrapper("JVM_InitAgentProperties");
4129   ResourceMark rm;
4130 
4131   Handle props(THREAD, JNIHandles::resolve_non_null(properties));
4132 
4133   PUTPROP(props, "sun.java.command", Arguments::java_command());
4134   PUTPROP(props, "sun.jvm.flags", Arguments::jvm_flags());
4135   PUTPROP(props, "sun.jvm.args", Arguments::jvm_args());
4136   return properties;
4137 JVM_END
4138 
4139 JVM_ENTRY(jobjectArray, JVM_GetEnclosingMethodInfo(JNIEnv *env, jclass ofClass))
4140 {
4141   JVMWrapper("JVM_GetEnclosingMethodInfo");
4142   JvmtiVMObjectAllocEventCollector oam;
4143 
4144   if (ofClass == NULL) {
4145     return NULL;
4146   }
4147   Handle mirror(THREAD, JNIHandles::resolve_non_null(ofClass));
4148   // Special handling for primitive objects
4149   if (java_lang_Class::is_primitive(mirror())) {
4150     return NULL;
4151   }
4152   Klass* k = java_lang_Class::as_Klass(mirror());
4153   if (!k-&gt;oop_is_instance()) {
4154     return NULL;
4155   }
4156   instanceKlassHandle ik_h(THREAD, k);
4157   int encl_method_class_idx = ik_h-&gt;enclosing_method_class_index();
4158   if (encl_method_class_idx == 0) {
4159     return NULL;
4160   }
4161   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::Object_klass(), 3, CHECK_NULL);
4162   objArrayHandle dest(THREAD, dest_o);
4163   Klass* enc_k = ik_h-&gt;constants()-&gt;klass_at(encl_method_class_idx, CHECK_NULL);
4164   dest-&gt;obj_at_put(0, enc_k-&gt;java_mirror());
4165   int encl_method_method_idx = ik_h-&gt;enclosing_method_method_index();
4166   if (encl_method_method_idx != 0) {
4167     Symbol* sym = ik_h-&gt;constants()-&gt;symbol_at(
4168                         extract_low_short_from_int(
4169                           ik_h-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
4170     Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
4171     dest-&gt;obj_at_put(1, str());
4172     sym = ik_h-&gt;constants()-&gt;symbol_at(
4173               extract_high_short_from_int(
4174                 ik_h-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
4175     str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
4176     dest-&gt;obj_at_put(2, str());
4177   }
4178   return (jobjectArray) JNIHandles::make_local(dest());
4179 }
4180 JVM_END
4181 
4182 JVM_ENTRY(jintArray, JVM_GetThreadStateValues(JNIEnv* env,
4183                                               jint javaThreadState))
4184 {
4185   // If new thread states are added in future JDK and VM versions,
4186   // this should check if the JDK version is compatible with thread
4187   // states supported by the VM.  Return NULL if not compatible.
4188   //
4189   // This function must map the VM java_lang_Thread::ThreadStatus
4190   // to the Java thread state that the JDK supports.
4191   //
4192 
4193   typeArrayHandle values_h;
4194   switch (javaThreadState) {
4195     case JAVA_THREAD_STATE_NEW : {
4196       typeArrayOop r = oopFactory::new_typeArray(T_INT, 1, CHECK_NULL);
4197       values_h = typeArrayHandle(THREAD, r);
4198       values_h-&gt;int_at_put(0, java_lang_Thread::NEW);
4199       break;
4200     }
4201     case JAVA_THREAD_STATE_RUNNABLE : {
4202       typeArrayOop r = oopFactory::new_typeArray(T_INT, 1, CHECK_NULL);
4203       values_h = typeArrayHandle(THREAD, r);
4204       values_h-&gt;int_at_put(0, java_lang_Thread::RUNNABLE);
4205       break;
4206     }
4207     case JAVA_THREAD_STATE_BLOCKED : {
4208       typeArrayOop r = oopFactory::new_typeArray(T_INT, 1, CHECK_NULL);
4209       values_h = typeArrayHandle(THREAD, r);
4210       values_h-&gt;int_at_put(0, java_lang_Thread::BLOCKED_ON_MONITOR_ENTER);
4211       break;
4212     }
4213     case JAVA_THREAD_STATE_WAITING : {
4214       typeArrayOop r = oopFactory::new_typeArray(T_INT, 2, CHECK_NULL);
4215       values_h = typeArrayHandle(THREAD, r);
4216       values_h-&gt;int_at_put(0, java_lang_Thread::IN_OBJECT_WAIT);
4217       values_h-&gt;int_at_put(1, java_lang_Thread::PARKED);
4218       break;
4219     }
4220     case JAVA_THREAD_STATE_TIMED_WAITING : {
4221       typeArrayOop r = oopFactory::new_typeArray(T_INT, 3, CHECK_NULL);
4222       values_h = typeArrayHandle(THREAD, r);
4223       values_h-&gt;int_at_put(0, java_lang_Thread::SLEEPING);
4224       values_h-&gt;int_at_put(1, java_lang_Thread::IN_OBJECT_WAIT_TIMED);
4225       values_h-&gt;int_at_put(2, java_lang_Thread::PARKED_TIMED);
4226       break;
4227     }
4228     case JAVA_THREAD_STATE_TERMINATED : {
4229       typeArrayOop r = oopFactory::new_typeArray(T_INT, 1, CHECK_NULL);
4230       values_h = typeArrayHandle(THREAD, r);
4231       values_h-&gt;int_at_put(0, java_lang_Thread::TERMINATED);
4232       break;
4233     }
4234     default:
4235       // Unknown state - probably incompatible JDK version
4236       return NULL;
4237   }
4238 
4239   return (jintArray) JNIHandles::make_local(env, values_h());
4240 }
4241 JVM_END
4242 
4243 
4244 JVM_ENTRY(jobjectArray, JVM_GetThreadStateNames(JNIEnv* env,
4245                                                 jint javaThreadState,
4246                                                 jintArray values))
4247 {
4248   // If new thread states are added in future JDK and VM versions,
4249   // this should check if the JDK version is compatible with thread
4250   // states supported by the VM.  Return NULL if not compatible.
4251   //
4252   // This function must map the VM java_lang_Thread::ThreadStatus
4253   // to the Java thread state that the JDK supports.
4254   //
4255 
4256   ResourceMark rm;
4257 
4258   // Check if threads is null
4259   if (values == NULL) {
4260     THROW_(vmSymbols::java_lang_NullPointerException(), 0);
4261   }
4262 
4263   typeArrayOop v = typeArrayOop(JNIHandles::resolve_non_null(values));
4264   typeArrayHandle values_h(THREAD, v);
4265 
4266   objArrayHandle names_h;
4267   switch (javaThreadState) {
4268     case JAVA_THREAD_STATE_NEW : {
4269       assert(values_h-&gt;length() == 1 &amp;&amp;
4270                values_h-&gt;int_at(0) == java_lang_Thread::NEW,
4271              "Invalid threadStatus value");
4272 
4273       objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
4274                                                1, /* only 1 substate */
4275                                                CHECK_NULL);
4276       names_h = objArrayHandle(THREAD, r);
4277       Handle name = java_lang_String::create_from_str("NEW", CHECK_NULL);
4278       names_h-&gt;obj_at_put(0, name());
4279       break;
4280     }
4281     case JAVA_THREAD_STATE_RUNNABLE : {
4282       assert(values_h-&gt;length() == 1 &amp;&amp;
4283                values_h-&gt;int_at(0) == java_lang_Thread::RUNNABLE,
4284              "Invalid threadStatus value");
4285 
4286       objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
4287                                                1, /* only 1 substate */
4288                                                CHECK_NULL);
4289       names_h = objArrayHandle(THREAD, r);
4290       Handle name = java_lang_String::create_from_str("RUNNABLE", CHECK_NULL);
4291       names_h-&gt;obj_at_put(0, name());
4292       break;
4293     }
4294     case JAVA_THREAD_STATE_BLOCKED : {
4295       assert(values_h-&gt;length() == 1 &amp;&amp;
4296                values_h-&gt;int_at(0) == java_lang_Thread::BLOCKED_ON_MONITOR_ENTER,
4297              "Invalid threadStatus value");
4298 
4299       objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
4300                                                1, /* only 1 substate */
4301                                                CHECK_NULL);
4302       names_h = objArrayHandle(THREAD, r);
4303       Handle name = java_lang_String::create_from_str("BLOCKED", CHECK_NULL);
4304       names_h-&gt;obj_at_put(0, name());
4305       break;
4306     }
4307     case JAVA_THREAD_STATE_WAITING : {
4308       assert(values_h-&gt;length() == 2 &amp;&amp;
4309                values_h-&gt;int_at(0) == java_lang_Thread::IN_OBJECT_WAIT &amp;&amp;
4310                values_h-&gt;int_at(1) == java_lang_Thread::PARKED,
4311              "Invalid threadStatus value");
4312       objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
4313                                                2, /* number of substates */
4314                                                CHECK_NULL);
4315       names_h = objArrayHandle(THREAD, r);
4316       Handle name0 = java_lang_String::create_from_str("WAITING.OBJECT_WAIT",
4317                                                        CHECK_NULL);
4318       Handle name1 = java_lang_String::create_from_str("WAITING.PARKED",
4319                                                        CHECK_NULL);
4320       names_h-&gt;obj_at_put(0, name0());
4321       names_h-&gt;obj_at_put(1, name1());
4322       break;
4323     }
4324     case JAVA_THREAD_STATE_TIMED_WAITING : {
4325       assert(values_h-&gt;length() == 3 &amp;&amp;
4326                values_h-&gt;int_at(0) == java_lang_Thread::SLEEPING &amp;&amp;
4327                values_h-&gt;int_at(1) == java_lang_Thread::IN_OBJECT_WAIT_TIMED &amp;&amp;
4328                values_h-&gt;int_at(2) == java_lang_Thread::PARKED_TIMED,
4329              "Invalid threadStatus value");
4330       objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
4331                                                3, /* number of substates */
4332                                                CHECK_NULL);
4333       names_h = objArrayHandle(THREAD, r);
4334       Handle name0 = java_lang_String::create_from_str("TIMED_WAITING.SLEEPING",
4335                                                        CHECK_NULL);
4336       Handle name1 = java_lang_String::create_from_str("TIMED_WAITING.OBJECT_WAIT",
4337                                                        CHECK_NULL);
4338       Handle name2 = java_lang_String::create_from_str("TIMED_WAITING.PARKED",
4339                                                        CHECK_NULL);
4340       names_h-&gt;obj_at_put(0, name0());
4341       names_h-&gt;obj_at_put(1, name1());
4342       names_h-&gt;obj_at_put(2, name2());
4343       break;
4344     }
4345     case JAVA_THREAD_STATE_TERMINATED : {
4346       assert(values_h-&gt;length() == 1 &amp;&amp;
4347                values_h-&gt;int_at(0) == java_lang_Thread::TERMINATED,
4348              "Invalid threadStatus value");
4349       objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
4350                                                1, /* only 1 substate */
4351                                                CHECK_NULL);
4352       names_h = objArrayHandle(THREAD, r);
4353       Handle name = java_lang_String::create_from_str("TERMINATED", CHECK_NULL);
4354       names_h-&gt;obj_at_put(0, name());
4355       break;
4356     }
4357     default:
4358       // Unknown state - probably incompatible JDK version
4359       return NULL;
4360   }
4361   return (jobjectArray) JNIHandles::make_local(env, names_h());
4362 }
4363 JVM_END
4364 
4365 JVM_ENTRY(void, JVM_GetVersionInfo(JNIEnv* env, jvm_version_info* info, size_t info_size))
4366 {
4367   memset(info, 0, info_size);
4368 
4369   info-&gt;jvm_version = Abstract_VM_Version::jvm_version();
4370   info-&gt;update_version = 0;          /* 0 in HotSpot Express VM */
4371   info-&gt;special_update_version = 0;  /* 0 in HotSpot Express VM */
4372 
4373   // when we add a new capability in the jvm_version_info struct, we should also
4374   // consider to expose this new capability in the sun.rt.jvmCapabilities jvmstat
4375   // counter defined in runtimeService.cpp.
4376   info-&gt;is_attachable = AttachListener::is_attach_supported();
4377 }
4378 JVM_END
</pre></body></html>
