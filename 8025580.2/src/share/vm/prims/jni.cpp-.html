<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/share/vm/prims/jni.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012 Red Hat, Inc.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include "precompiled.hpp"
  27 #include "ci/ciReplay.hpp"
  28 #include "classfile/altHashing.hpp"
  29 #include "classfile/classLoader.hpp"
  30 #include "classfile/javaClasses.hpp"
  31 #include "classfile/symbolTable.hpp"
  32 #include "classfile/systemDictionary.hpp"
  33 #include "classfile/vmSymbols.hpp"
  34 #include "interpreter/linkResolver.hpp"
  35 #include "utilities/macros.hpp"
  36 #if INCLUDE_ALL_GCS
  37 #include "gc_implementation/g1/g1SATBCardTableModRefBS.hpp"
  38 #endif // INCLUDE_ALL_GCS
  39 #include "memory/allocation.hpp"
  40 #include "memory/allocation.inline.hpp"
  41 #include "memory/gcLocker.inline.hpp"
  42 #include "memory/oopFactory.hpp"
  43 #include "memory/universe.inline.hpp"
  44 #include "oops/instanceKlass.hpp"
  45 #include "oops/instanceOop.hpp"
  46 #include "oops/markOop.hpp"
  47 #include "oops/method.hpp"
  48 #include "oops/objArrayKlass.hpp"
  49 #include "oops/objArrayOop.hpp"
  50 #include "oops/oop.inline.hpp"
  51 #include "oops/symbol.hpp"
  52 #include "oops/typeArrayKlass.hpp"
  53 #include "oops/typeArrayOop.hpp"
  54 #include "prims/jni.h"
  55 #include "prims/jniCheck.hpp"
  56 #include "prims/jniExport.hpp"
  57 #include "prims/jniFastGetField.hpp"
  58 #include "prims/jvm.h"
  59 #include "prims/jvm_misc.hpp"
  60 #include "prims/jvmtiExport.hpp"
  61 #include "prims/jvmtiThreadState.hpp"
  62 #include "runtime/compilationPolicy.hpp"
  63 #include "runtime/fieldDescriptor.hpp"
  64 #include "runtime/fprofiler.hpp"
  65 #include "runtime/handles.inline.hpp"
  66 #include "runtime/interfaceSupport.hpp"
  67 #include "runtime/java.hpp"
  68 #include "runtime/javaCalls.hpp"
  69 #include "runtime/jfieldIDWorkaround.hpp"
  70 #include "runtime/reflection.hpp"
  71 #include "runtime/sharedRuntime.hpp"
  72 #include "runtime/signature.hpp"
  73 #include "runtime/thread.inline.hpp"
  74 #include "runtime/vm_operations.hpp"
  75 #include "services/runtimeService.hpp"
  76 #include "trace/tracing.hpp"
  77 #include "utilities/defaultStream.hpp"
  78 #include "utilities/dtrace.hpp"
  79 #include "utilities/events.hpp"
  80 #include "utilities/histogram.hpp"
  81 #ifdef TARGET_OS_FAMILY_linux
  82 # include "os_linux.inline.hpp"
  83 #endif
  84 #ifdef TARGET_OS_FAMILY_solaris
  85 # include "os_solaris.inline.hpp"
  86 #endif
  87 #ifdef TARGET_OS_FAMILY_windows
  88 # include "os_windows.inline.hpp"
  89 #endif
  90 #ifdef TARGET_OS_FAMILY_bsd
  91 # include "os_bsd.inline.hpp"
  92 #endif
  93 
  94 static jint CurrentVersion = JNI_VERSION_1_8;
  95 
  96 
  97 // The DT_RETURN_MARK macros create a scoped object to fire the dtrace
  98 // '-return' probe regardless of the return path is taken out of the function.
  99 // Methods that have multiple return paths use this to avoid having to
 100 // instrument each return path.  Methods that use CHECK or THROW must use this
 101 // since those macros can cause an immedate uninstrumented return.
 102 //
 103 // In order to get the return value, a reference to the variable containing
 104 // the return value must be passed to the contructor of the object, and
 105 // the return value must be set before return (since the mark object has
 106 // a reference to it).
 107 //
 108 // Example:
 109 // DT_RETURN_MARK_DECL(SomeFunc, int);
 110 // JNI_ENTRY(int, SomeFunc, ...)
 111 //   int return_value = 0;
 112 //   DT_RETURN_MARK(SomeFunc, int, (const int&amp;)return_value);
 113 //   foo(CHECK_0)
 114 //   return_value = 5;
 115 //   return return_value;
 116 // JNI_END
 117 #define DT_RETURN_MARK_DECL(name, type, probe)                             \
 118   DTRACE_ONLY(                                                             \
 119     class DTraceReturnProbeMark_##name {                                   \
 120      public:                                                               \
 121       const type&amp; _ret_ref;                                                \
 122       DTraceReturnProbeMark_##name(const type&amp; v) : _ret_ref(v) {}         \
 123       ~DTraceReturnProbeMark_##name() {                                    \
 124         probe;                                                             \
 125       }                                                                    \
 126     }                                                                      \
 127   )
 128 // Void functions are simpler since there's no return value
 129 #define DT_VOID_RETURN_MARK_DECL(name, probe)                              \
 130   DTRACE_ONLY(                                                             \
 131     class DTraceReturnProbeMark_##name {                                   \
 132      public:                                                               \
 133       ~DTraceReturnProbeMark_##name() {                                    \
 134         probe;                                                             \
 135       }                                                                    \
 136     }                                                                      \
 137   )
 138 
 139 // Place these macros in the function to mark the return.  Non-void
 140 // functions need the type and address of the return value.
 141 #define DT_RETURN_MARK(name, type, ref) \
 142   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark(ref) )
 143 #define DT_VOID_RETURN_MARK(name) \
 144   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark )
 145 
 146 
 147 // Use these to select distinct code for floating-point vs. non-floating point
 148 // situations.  Used from within common macros where we need slightly
 149 // different behavior for Float/Double
 150 #define FP_SELECT_Boolean(intcode, fpcode) intcode
 151 #define FP_SELECT_Byte(intcode, fpcode)    intcode
 152 #define FP_SELECT_Char(intcode, fpcode)    intcode
 153 #define FP_SELECT_Short(intcode, fpcode)   intcode
 154 #define FP_SELECT_Object(intcode, fpcode)  intcode
 155 #define FP_SELECT_Int(intcode, fpcode)     intcode
 156 #define FP_SELECT_Long(intcode, fpcode)    intcode
 157 #define FP_SELECT_Float(intcode, fpcode)   fpcode
 158 #define FP_SELECT_Double(intcode, fpcode)  fpcode
 159 #define FP_SELECT(TypeName, intcode, fpcode) \
 160   FP_SELECT_##TypeName(intcode, fpcode)
 161 
 162 #define COMMA ,
 163 
 164 // Choose DT_RETURN_MARK macros  based on the type: float/double -&gt; void
 165 // (dtrace doesn't do FP yet)
 166 #define DT_RETURN_MARK_DECL_FOR(TypeName, name, type, probe)    \
 167   FP_SELECT(TypeName, \
 168     DT_RETURN_MARK_DECL(name, type, probe), DT_VOID_RETURN_MARK_DECL(name, probe) )
 169 #define DT_RETURN_MARK_FOR(TypeName, name, type, ref) \
 170   FP_SELECT(TypeName, \
 171     DT_RETURN_MARK(name, type, ref), DT_VOID_RETURN_MARK(name) )
 172 
 173 
 174 // out-of-line helpers for class jfieldIDWorkaround:
 175 
 176 bool jfieldIDWorkaround::is_valid_jfieldID(Klass* k, jfieldID id) {
 177   if (jfieldIDWorkaround::is_instance_jfieldID(k, id)) {
 178     uintptr_t as_uint = (uintptr_t) id;
 179     intptr_t offset = raw_instance_offset(id);
 180     if (is_checked_jfieldID(id)) {
 181       if (!klass_hash_ok(k, id)) {
 182         return false;
 183       }
 184     }
 185     return InstanceKlass::cast(k)-&gt;contains_field_offset(offset);
 186   } else {
 187     JNIid* result = (JNIid*) id;
 188 #ifdef ASSERT
 189     return result != NULL &amp;&amp; result-&gt;is_static_field_id();
 190 #else
 191     return result != NULL;
 192 #endif
 193   }
 194 }
 195 
 196 
 197 intptr_t jfieldIDWorkaround::encode_klass_hash(Klass* k, intptr_t offset) {
 198   if (offset &lt;= small_offset_mask) {
 199     Klass* field_klass = k;
 200     Klass* super_klass = field_klass-&gt;super();
 201     // With compressed oops the most super class with nonstatic fields would
 202     // be the owner of fields embedded in the header.
 203     while (InstanceKlass::cast(super_klass)-&gt;has_nonstatic_fields() &amp;&amp;
 204            InstanceKlass::cast(super_klass)-&gt;contains_field_offset(offset)) {
 205       field_klass = super_klass;   // super contains the field also
 206       super_klass = field_klass-&gt;super();
 207     }
 208     debug_only(No_Safepoint_Verifier nosafepoint;)
 209     uintptr_t klass_hash = field_klass-&gt;identity_hash();
 210     return ((klass_hash &amp; klass_mask) &lt;&lt; klass_shift) | checked_mask_in_place;
 211   } else {
 212 #if 0
 213     #ifndef PRODUCT
 214     {
 215       ResourceMark rm;
 216       warning("VerifyJNIFields: long offset %d in %s", offset, k-&gt;external_name());
 217     }
 218     #endif
 219 #endif
 220     return 0;
 221   }
 222 }
 223 
 224 bool jfieldIDWorkaround::klass_hash_ok(Klass* k, jfieldID id) {
 225   uintptr_t as_uint = (uintptr_t) id;
 226   intptr_t klass_hash = (as_uint &gt;&gt; klass_shift) &amp; klass_mask;
 227   do {
 228     debug_only(No_Safepoint_Verifier nosafepoint;)
 229     // Could use a non-blocking query for identity_hash here...
 230     if ((k-&gt;identity_hash() &amp; klass_mask) == klass_hash)
 231       return true;
 232     k = k-&gt;super();
 233   } while (k != NULL);
 234   return false;
 235 }
 236 
 237 void jfieldIDWorkaround::verify_instance_jfieldID(Klass* k, jfieldID id) {
 238   guarantee(jfieldIDWorkaround::is_instance_jfieldID(k, id), "must be an instance field" );
 239   uintptr_t as_uint = (uintptr_t) id;
 240   intptr_t offset = raw_instance_offset(id);
 241   if (VerifyJNIFields) {
 242     if (is_checked_jfieldID(id)) {
 243       guarantee(klass_hash_ok(k, id),
 244     "Bug in native code: jfieldID class must match object");
 245     } else {
 246 #if 0
 247       #ifndef PRODUCT
 248       if (Verbose) {
 249   ResourceMark rm;
 250   warning("VerifyJNIFields: unverified offset %d for %s", offset, k-&gt;external_name());
 251       }
 252       #endif
 253 #endif
 254     }
 255   }
 256   guarantee(InstanceKlass::cast(k)-&gt;contains_field_offset(offset),
 257       "Bug in native code: jfieldID offset must address interior of object");
 258 }
 259 
 260 // Pick a reasonable higher bound for local capacity requested
 261 // for EnsureLocalCapacity and PushLocalFrame.  We don't want it too
 262 // high because a test (or very unusual application) may try to allocate
 263 // that many handles and run out of swap space.  An implementation is
 264 // permitted to allocate more handles than the ensured capacity, so this
 265 // value is set high enough to prevent compatibility problems.
 266 const int MAX_REASONABLE_LOCAL_CAPACITY = 4*K;
 267 
 268 
 269 // Wrapper to trace JNI functions
 270 
 271 #ifdef ASSERT
 272   Histogram* JNIHistogram;
 273   static volatile jint JNIHistogram_lock = 0;
 274 
 275   class JNITraceWrapper : public StackObj {
 276    public:
 277     JNITraceWrapper(const char* format, ...) {
 278       if (TraceJNICalls) {
 279         va_list ap;
 280         va_start(ap, format);
 281         tty-&gt;print("JNI ");
 282         tty-&gt;vprint_cr(format, ap);
 283         va_end(ap);
 284       }
 285     }
 286   };
 287 
 288   class JNIHistogramElement : public HistogramElement {
 289     public:
 290      JNIHistogramElement(const char* name);
 291   };
 292 
 293   JNIHistogramElement::JNIHistogramElement(const char* elementName) {
 294     _name = elementName;
 295     uintx count = 0;
 296 
 297     while (Atomic::cmpxchg(1, &amp;JNIHistogram_lock, 0) != 0) {
 298       while (OrderAccess::load_acquire(&amp;JNIHistogram_lock) != 0) {
 299         count +=1;
 300         if ( (WarnOnStalledSpinLock &gt; 0)
 301           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 302           warning("JNIHistogram_lock seems to be stalled");
 303         }
 304       }
 305      }
 306 
 307 
 308     if(JNIHistogram == NULL)
 309       JNIHistogram = new Histogram("JNI Call Counts",100);
 310 
 311     JNIHistogram-&gt;add_element(this);
 312     Atomic::dec(&amp;JNIHistogram_lock);
 313   }
 314 
 315   #define JNICountWrapper(arg)                                     \
 316      static JNIHistogramElement* e = new JNIHistogramElement(arg); \
 317       /* There is a MT-race condition in VC++. So we need to make sure that that e has been initialized */ \
 318      if (e != NULL) e-&gt;increment_count()
 319   #define JNIWrapper(arg) JNICountWrapper(arg); JNITraceWrapper(arg)
 320 #else
 321   #define JNIWrapper(arg)
 322 #endif
 323 
 324 
 325 // Implementation of JNI entries
 326 
 327 DT_RETURN_MARK_DECL(DefineClass, jclass
 328                     , HOTSPOT_JNI_DEFINECLASS_RETURN(_ret_ref));
 329 
 330 JNI_ENTRY(jclass, jni_DefineClass(JNIEnv *env, const char *name, jobject loaderRef,
 331                                   const jbyte *buf, jsize bufLen))
 332   JNIWrapper("DefineClass");
 333 
 334   HOTSPOT_JNI_DEFINECLASS_ENTRY(
 335     env, (char*) name, loaderRef, (char*) buf, bufLen);
 336 
 337   jclass cls = NULL;
 338   DT_RETURN_MARK(DefineClass, jclass, (const jclass&amp;)cls);
 339 
 340   TempNewSymbol class_name = NULL;
 341   // Since exceptions can be thrown, class initialization can take place
 342   // if name is NULL no check for class name in .class stream has to be made.
 343   if (name != NULL) {
 344     const int str_len = (int)strlen(name);
 345     if (str_len &gt; Symbol::max_length()) {
 346       // It's impossible to create this class;  the name cannot fit
 347       // into the constant pool.
 348       THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), name);
 349     }
 350     class_name = SymbolTable::new_symbol(name, CHECK_NULL);
 351   }
 352   ResourceMark rm(THREAD);
 353   ClassFileStream st((u1*) buf, bufLen, NULL);
 354   Handle class_loader (THREAD, JNIHandles::resolve(loaderRef));
 355 
 356   if (UsePerfData &amp;&amp; !class_loader.is_null()) {
 357     // check whether the current caller thread holds the lock or not.
 358     // If not, increment the corresponding counter
 359     if (ObjectSynchronizer::
 360         query_lock_ownership((JavaThread*)THREAD, class_loader) !=
 361         ObjectSynchronizer::owner_self) {
 362       ClassLoader::sync_JNIDefineClassLockFreeCounter()-&gt;inc();
 363     }
 364   }
 365   Klass* k = SystemDictionary::resolve_from_stream(class_name, class_loader,
 366                                                      Handle(), &amp;st, true,
 367                                                      CHECK_NULL);
 368 
 369   if (TraceClassResolution &amp;&amp; k != NULL) {
 370     trace_class_resolution(k);
 371   }
 372 
 373   cls = (jclass)JNIHandles::make_local(
 374     env, k-&gt;java_mirror());
 375   return cls;
 376 JNI_END
 377 
 378 
 379 
 380 static bool first_time_FindClass = true;
 381 
 382 DT_RETURN_MARK_DECL(FindClass, jclass
 383                     , HOTSPOT_JNI_FINDCLASS_RETURN(_ret_ref));
 384 
 385 JNI_ENTRY(jclass, jni_FindClass(JNIEnv *env, const char *name))
 386   JNIWrapper("FindClass");
 387 
 388   HOTSPOT_JNI_FINDCLASS_ENTRY(env, (char *)name);
 389 
 390   jclass result = NULL;
 391   DT_RETURN_MARK(FindClass, jclass, (const jclass&amp;)result);
 392 
 393   // Remember if we are the first invocation of jni_FindClass
 394   bool first_time = first_time_FindClass;
 395   first_time_FindClass = false;
 396 
 397   // Sanity check the name:  it cannot be null or larger than the maximum size
 398   // name we can fit in the constant pool.
 399   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 400     THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), name);
 401   }
 402 
 403   //%note jni_3
 404   Handle loader;
 405   Handle protection_domain;
 406   // Find calling class
 407   instanceKlassHandle k (THREAD, thread-&gt;security_get_caller_class(0));
 408   if (k.not_null()) {
 409     loader = Handle(THREAD, k-&gt;class_loader());
 410     // Special handling to make sure JNI_OnLoad and JNI_OnUnload are executed
 411     // in the correct class context.
 412     if (loader.is_null() &amp;&amp;
 413         k-&gt;name() == vmSymbols::java_lang_ClassLoader_NativeLibrary()) {
 414       JavaValue result(T_OBJECT);
 415       JavaCalls::call_static(&amp;result, k,
 416                                       vmSymbols::getFromClass_name(),
 417                                       vmSymbols::void_class_signature(),
 418                                       thread);
 419       if (HAS_PENDING_EXCEPTION) {
 420         Handle ex(thread, thread-&gt;pending_exception());
 421         CLEAR_PENDING_EXCEPTION;
 422         THROW_HANDLE_0(ex);
 423       }
 424       oop mirror = (oop) result.get_jobject();
 425       loader = Handle(THREAD,
 426         InstanceKlass::cast(java_lang_Class::as_Klass(mirror))-&gt;class_loader());
 427       protection_domain = Handle(THREAD,
 428         InstanceKlass::cast(java_lang_Class::as_Klass(mirror))-&gt;protection_domain());
 429     }
 430   } else {
 431     // We call ClassLoader.getSystemClassLoader to obtain the system class loader.
 432     loader = Handle(THREAD, SystemDictionary::java_system_loader());
 433   }
 434 
 435   TempNewSymbol sym = SymbolTable::new_symbol(name, CHECK_NULL);
 436   result = find_class_from_class_loader(env, sym, true, loader,
 437                                         protection_domain, true, thread);
 438 
 439   if (TraceClassResolution &amp;&amp; result != NULL) {
 440     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 441   }
 442 
 443   // If we were the first invocation of jni_FindClass, we enable compilation again
 444   // rather than just allowing invocation counter to overflow and decay.
 445   // Controlled by flag DelayCompilationDuringStartup.
 446   if (first_time &amp;&amp; !CompileTheWorld)
 447     CompilationPolicy::completed_vm_startup();
 448 
 449   return result;
 450 JNI_END
 451 
 452 DT_RETURN_MARK_DECL(FromReflectedMethod, jmethodID
 453                     , HOTSPOT_JNI_FROMREFLECTEDMETHOD_RETURN((uintptr_t)_ret_ref));
 454 
 455 JNI_ENTRY(jmethodID, jni_FromReflectedMethod(JNIEnv *env, jobject method))
 456   JNIWrapper("FromReflectedMethod");
 457 
 458   HOTSPOT_JNI_FROMREFLECTEDMETHOD_ENTRY(env, method);
 459 
 460   jmethodID ret = NULL;
 461   DT_RETURN_MARK(FromReflectedMethod, jmethodID, (const jmethodID&amp;)ret);
 462 
 463   // method is a handle to a java.lang.reflect.Method object
 464   oop reflected  = JNIHandles::resolve_non_null(method);
 465   oop mirror     = NULL;
 466   int slot       = 0;
 467 
 468   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 469     mirror = java_lang_reflect_Constructor::clazz(reflected);
 470     slot   = java_lang_reflect_Constructor::slot(reflected);
 471   } else {
 472     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(), "wrong type");
 473     mirror = java_lang_reflect_Method::clazz(reflected);
 474     slot   = java_lang_reflect_Method::slot(reflected);
 475   }
 476   Klass* k     = java_lang_Class::as_Klass(mirror);
 477 
 478   KlassHandle k1(THREAD, k);
 479   // Make sure class is initialized before handing id's out to methods
 480   k1()-&gt;initialize(CHECK_NULL);
 481   Method* m = InstanceKlass::cast(k1())-&gt;method_with_idnum(slot);
 482   ret = m==NULL? NULL : m-&gt;jmethod_id();  // return NULL if reflected method deleted
 483   return ret;
 484 JNI_END
 485 
 486 DT_RETURN_MARK_DECL(FromReflectedField, jfieldID
 487                     , HOTSPOT_JNI_FROMREFLECTEDFIELD_RETURN((uintptr_t)_ret_ref));
 488 
 489 JNI_ENTRY(jfieldID, jni_FromReflectedField(JNIEnv *env, jobject field))
 490   JNIWrapper("FromReflectedField");
 491 
 492   HOTSPOT_JNI_FROMREFLECTEDFIELD_ENTRY(env, field);
 493 
 494   jfieldID ret = NULL;
 495   DT_RETURN_MARK(FromReflectedField, jfieldID, (const jfieldID&amp;)ret);
 496 
 497   // field is a handle to a java.lang.reflect.Field object
 498   oop reflected   = JNIHandles::resolve_non_null(field);
 499   oop mirror      = java_lang_reflect_Field::clazz(reflected);
 500   Klass* k      = java_lang_Class::as_Klass(mirror);
 501   int slot        = java_lang_reflect_Field::slot(reflected);
 502   int modifiers   = java_lang_reflect_Field::modifiers(reflected);
 503 
 504   KlassHandle k1(THREAD, k);
 505   // Make sure class is initialized before handing id's out to fields
 506   k1()-&gt;initialize(CHECK_NULL);
 507 
 508   // First check if this is a static field
 509   if (modifiers &amp; JVM_ACC_STATIC) {
 510     intptr_t offset = InstanceKlass::cast(k1())-&gt;field_offset( slot );
 511     JNIid* id = InstanceKlass::cast(k1())-&gt;jni_id_for(offset);
 512     assert(id != NULL, "corrupt Field object");
 513     debug_only(id-&gt;set_is_static_field_id();)
 514     // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
 515     ret = jfieldIDWorkaround::to_static_jfieldID(id);
 516     return ret;
 517   }
 518 
 519   // The slot is the index of the field description in the field-array
 520   // The jfieldID is the offset of the field within the object
 521   // It may also have hash bits for k, if VerifyJNIFields is turned on.
 522   intptr_t offset = InstanceKlass::cast(k1())-&gt;field_offset( slot );
 523   assert(InstanceKlass::cast(k1())-&gt;contains_field_offset(offset), "stay within object");
 524   ret = jfieldIDWorkaround::to_instance_jfieldID(k1(), offset);
 525   return ret;
 526 JNI_END
 527 
 528 
 529 DT_RETURN_MARK_DECL(ToReflectedMethod, jobject
 530                     , HOTSPOT_JNI_TOREFLECTEDMETHOD_RETURN(_ret_ref));
 531 
 532 JNI_ENTRY(jobject, jni_ToReflectedMethod(JNIEnv *env, jclass cls, jmethodID method_id, jboolean isStatic))
 533   JNIWrapper("ToReflectedMethod");
 534 
 535   HOTSPOT_JNI_TOREFLECTEDMETHOD_ENTRY(env, cls, (uintptr_t) method_id, isStatic);
 536 
 537   jobject ret = NULL;
 538   DT_RETURN_MARK(ToReflectedMethod, jobject, (const jobject&amp;)ret);
 539 
 540   methodHandle m (THREAD, Method::resolve_jmethod_id(method_id));
 541   assert(m-&gt;is_static() == (isStatic != 0), "jni_ToReflectedMethod access flags doesn't match");
 542   oop reflection_method;
 543   if (m-&gt;is_initializer()) {
 544     reflection_method = Reflection::new_constructor(m, CHECK_NULL);
 545   } else {
 546     reflection_method = Reflection::new_method(m, UseNewReflection, false, CHECK_NULL);
 547   }
 548   ret = JNIHandles::make_local(env, reflection_method);
 549   return ret;
 550 JNI_END
 551 
 552 DT_RETURN_MARK_DECL(GetSuperclass, jclass
 553                     , HOTSPOT_JNI_GETSUPERCLASS_RETURN(_ret_ref));
 554 
 555 JNI_ENTRY(jclass, jni_GetSuperclass(JNIEnv *env, jclass sub))
 556   JNIWrapper("GetSuperclass");
 557 
 558   HOTSPOT_JNI_GETSUPERCLASS_ENTRY(env, sub);
 559 
 560   jclass obj = NULL;
 561   DT_RETURN_MARK(GetSuperclass, jclass, (const jclass&amp;)obj);
 562 
 563   oop mirror = JNIHandles::resolve_non_null(sub);
 564   // primitive classes return NULL
 565   if (java_lang_Class::is_primitive(mirror)) return NULL;
 566 
 567   // Rules of Class.getSuperClass as implemented by KLass::java_super:
 568   // arrays return Object
 569   // interfaces return NULL
 570   // proper classes return Klass::super()
 571   Klass* k = java_lang_Class::as_Klass(mirror);
 572   if (k-&gt;is_interface()) return NULL;
 573 
 574   // return mirror for superclass
 575   Klass* super = k-&gt;java_super();
 576   // super2 is the value computed by the compiler's getSuperClass intrinsic:
 577   debug_only(Klass* super2 = ( k-&gt;oop_is_array()
 578                                  ? SystemDictionary::Object_klass()
 579                                  : k-&gt;super() ) );
 580   assert(super == super2,
 581          "java_super computation depends on interface, array, other super");
 582   obj = (super == NULL) ? NULL : (jclass) JNIHandles::make_local(super-&gt;java_mirror());
 583   return obj;
 584 JNI_END
 585 
 586 JNI_QUICK_ENTRY(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))
 587   JNIWrapper("IsSubclassOf");
 588 
 589   HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);
 590 
 591   oop sub_mirror   = JNIHandles::resolve_non_null(sub);
 592   oop super_mirror = JNIHandles::resolve_non_null(super);
 593   if (java_lang_Class::is_primitive(sub_mirror) ||
 594       java_lang_Class::is_primitive(super_mirror)) {
 595     jboolean ret = (sub_mirror == super_mirror);
 596 
 597     HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 598     return ret;
 599   }
 600   Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
 601   Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
 602   assert(sub_klass != NULL &amp;&amp; super_klass != NULL, "invalid arguments to jni_IsAssignableFrom");
 603   jboolean ret = sub_klass-&gt;is_subtype_of(super_klass) ?
 604                    JNI_TRUE : JNI_FALSE;
 605 
 606   HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 607   return ret;
 608 JNI_END
 609 
 610 
 611 DT_RETURN_MARK_DECL(Throw, jint
 612                     , HOTSPOT_JNI_THROW_RETURN(_ret_ref));
 613 
 614 JNI_ENTRY(jint, jni_Throw(JNIEnv *env, jthrowable obj))
 615   JNIWrapper("Throw");
 616 
 617   HOTSPOT_JNI_THROW_ENTRY(env, obj);
 618 
 619   jint ret = JNI_OK;
 620   DT_RETURN_MARK(Throw, jint, (const jint&amp;)ret);
 621 
 622   THROW_OOP_(JNIHandles::resolve(obj), JNI_OK);
 623   ShouldNotReachHere();
 624 JNI_END
 625 
 626 
 627 DT_RETURN_MARK_DECL(ThrowNew, jint
 628                     , HOTSPOT_JNI_THROWNEW_RETURN(_ret_ref));
 629 
 630 JNI_ENTRY(jint, jni_ThrowNew(JNIEnv *env, jclass clazz, const char *message))
 631   JNIWrapper("ThrowNew");
 632 
 633   HOTSPOT_JNI_THROWNEW_ENTRY(env, clazz, (char *) message);
 634 
 635   jint ret = JNI_OK;
 636   DT_RETURN_MARK(ThrowNew, jint, (const jint&amp;)ret);
 637 
 638   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
 639   Symbol*  name = k-&gt;name();
 640   Handle class_loader (THREAD,  k-&gt;class_loader());
 641   Handle protection_domain (THREAD, k-&gt;protection_domain());
 642   THROW_MSG_LOADER_(name, (char *)message, class_loader, protection_domain, JNI_OK);
 643   ShouldNotReachHere();
 644 JNI_END
 645 
 646 
 647 // JNI functions only transform a pending async exception to a synchronous
 648 // exception in ExceptionOccurred and ExceptionCheck calls, since
 649 // delivering an async exception in other places won't change the native
 650 // code's control flow and would be harmful when native code further calls
 651 // JNI functions with a pending exception. Async exception is also checked
 652 // during the call, so ExceptionOccurred/ExceptionCheck won't return
 653 // false but deliver the async exception at the very end during
 654 // state transition.
 655 
 656 static void jni_check_async_exceptions(JavaThread *thread) {
 657   assert(thread == Thread::current(), "must be itself");
 658   thread-&gt;check_and_handle_async_exceptions();
 659 }
 660 
 661 JNI_ENTRY_NO_PRESERVE(jthrowable, jni_ExceptionOccurred(JNIEnv *env))
 662   JNIWrapper("ExceptionOccurred");
 663 
 664   HOTSPOT_JNI_EXCEPTIONOCCURRED_ENTRY(env);
 665 
 666   jni_check_async_exceptions(thread);
 667   oop exception = thread-&gt;pending_exception();
 668   jthrowable ret = (jthrowable) JNIHandles::make_local(env, exception);
 669 
 670   HOTSPOT_JNI_EXCEPTIONOCCURRED_RETURN(ret);
 671   return ret;
 672 JNI_END
 673 
 674 
 675 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionDescribe(JNIEnv *env))
 676   JNIWrapper("ExceptionDescribe");
 677 
 678   HOTSPOT_JNI_EXCEPTIONDESCRIBE_ENTRY(env);
 679 
 680   if (thread-&gt;has_pending_exception()) {
 681     Handle ex(thread, thread-&gt;pending_exception());
 682     thread-&gt;clear_pending_exception();
 683     if (ex-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
 684       // Don't print anything if we are being killed.
 685     } else {
 686       jio_fprintf(defaultStream::error_stream(), "Exception ");
 687       if (thread != NULL &amp;&amp; thread-&gt;threadObj() != NULL) {
 688         ResourceMark rm(THREAD);
 689         jio_fprintf(defaultStream::error_stream(),
 690         "in thread \"%s\" ", thread-&gt;get_thread_name());
 691       }
 692       if (ex-&gt;is_a(SystemDictionary::Throwable_klass())) {
 693         JavaValue result(T_VOID);
 694         JavaCalls::call_virtual(&amp;result,
 695                                 ex,
 696                                 KlassHandle(THREAD,
 697                                   SystemDictionary::Throwable_klass()),
 698                                 vmSymbols::printStackTrace_name(),
 699                                 vmSymbols::void_method_signature(),
 700                                 THREAD);
 701         // If an exception is thrown in the call it gets thrown away. Not much
 702         // we can do with it. The native code that calls this, does not check
 703         // for the exception - hence, it might still be in the thread when DestroyVM gets
 704         // called, potentially causing a few asserts to trigger - since no pending exception
 705         // is expected.
 706         CLEAR_PENDING_EXCEPTION;
 707       } else {
 708         ResourceMark rm(THREAD);
 709         jio_fprintf(defaultStream::error_stream(),
 710         ". Uncaught exception of type %s.",
 711         ex-&gt;klass()-&gt;external_name());
 712       }
 713     }
 714   }
 715 
 716   HOTSPOT_JNI_EXCEPTIONDESCRIBE_RETURN();
 717 JNI_END
 718 
 719 
 720 JNI_QUICK_ENTRY(void, jni_ExceptionClear(JNIEnv *env))
 721   JNIWrapper("ExceptionClear");
 722 
 723   HOTSPOT_JNI_EXCEPTIONCLEAR_ENTRY(env);
 724 
 725   // The jni code might be using this API to clear java thrown exception.
 726   // So just mark jvmti thread exception state as exception caught.
 727   JvmtiThreadState *state = JavaThread::current()-&gt;jvmti_thread_state();
 728   if (state != NULL &amp;&amp; state-&gt;is_exception_detected()) {
 729     state-&gt;set_exception_caught();
 730   }
 731   thread-&gt;clear_pending_exception();
 732 
 733   HOTSPOT_JNI_EXCEPTIONCLEAR_RETURN();
 734 JNI_END
 735 
 736 
 737 JNI_ENTRY(void, jni_FatalError(JNIEnv *env, const char *msg))
 738   JNIWrapper("FatalError");
 739 
 740   HOTSPOT_JNI_FATALERROR_ENTRY(env, (char *) msg);
 741 
 742   tty-&gt;print_cr("FATAL ERROR in native method: %s", msg);
 743   thread-&gt;print_stack();
 744   os::abort(); // Dump core and abort
 745 JNI_END
 746 
 747 
 748 JNI_ENTRY(jint, jni_PushLocalFrame(JNIEnv *env, jint capacity))
 749   JNIWrapper("PushLocalFrame");
 750 
 751   HOTSPOT_JNI_PUSHLOCALFRAME_ENTRY(env, capacity);
 752 
 753   //%note jni_11
 754   if (capacity &lt; 0 || capacity &gt; MAX_REASONABLE_LOCAL_CAPACITY) {
 755     HOTSPOT_JNI_PUSHLOCALFRAME_RETURN((uint32_t)JNI_ERR);
 756     return JNI_ERR;
 757   }
 758   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 759   JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(thread);
 760   assert(new_handles != NULL, "should not be NULL");
 761   new_handles-&gt;set_pop_frame_link(old_handles);
 762   thread-&gt;set_active_handles(new_handles);
 763   jint ret = JNI_OK;
 764   HOTSPOT_JNI_PUSHLOCALFRAME_RETURN(ret);
 765   return ret;
 766 JNI_END
 767 
 768 
 769 JNI_ENTRY(jobject, jni_PopLocalFrame(JNIEnv *env, jobject result))
 770   JNIWrapper("PopLocalFrame");
 771 
 772   HOTSPOT_JNI_POPLOCALFRAME_ENTRY(env, result);
 773 
 774   //%note jni_11
 775   Handle result_handle(thread, JNIHandles::resolve(result));
 776   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 777   JNIHandleBlock* new_handles = old_handles-&gt;pop_frame_link();
 778   if (new_handles != NULL) {
 779     // As a sanity check we only release the handle blocks if the pop_frame_link is not NULL.
 780     // This way code will still work if PopLocalFrame is called without a corresponding
 781     // PushLocalFrame call. Note that we set the pop_frame_link to NULL explicitly, otherwise
 782     // the release_block call will release the blocks.
 783     thread-&gt;set_active_handles(new_handles);
 784     old_handles-&gt;set_pop_frame_link(NULL);              // clear link we won't release new_handles below
 785     JNIHandleBlock::release_block(old_handles, thread); // may block
 786     result = JNIHandles::make_local(thread, result_handle());
 787   }
 788   HOTSPOT_JNI_POPLOCALFRAME_RETURN(result);
 789   return result;
 790 JNI_END
 791 
 792 
 793 JNI_ENTRY(jobject, jni_NewGlobalRef(JNIEnv *env, jobject ref))
 794   JNIWrapper("NewGlobalRef");
 795 
 796   HOTSPOT_JNI_NEWGLOBALREF_ENTRY(env, ref);
 797 
 798   Handle ref_handle(thread, JNIHandles::resolve(ref));
 799   jobject ret = JNIHandles::make_global(ref_handle);
 800 
 801   HOTSPOT_JNI_NEWGLOBALREF_RETURN(ret);
 802   return ret;
 803 JNI_END
 804 
 805 // Must be JNI_ENTRY (with HandleMark)
 806 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteGlobalRef(JNIEnv *env, jobject ref))
 807   JNIWrapper("DeleteGlobalRef");
 808 
 809   HOTSPOT_JNI_DELETEGLOBALREF_ENTRY(env, ref);
 810 
 811   JNIHandles::destroy_global(ref);
 812 
 813   HOTSPOT_JNI_DELETEGLOBALREF_RETURN();
 814 JNI_END
 815 
 816 JNI_QUICK_ENTRY(void, jni_DeleteLocalRef(JNIEnv *env, jobject obj))
 817   JNIWrapper("DeleteLocalRef");
 818 
 819   HOTSPOT_JNI_DELETELOCALREF_ENTRY(env, obj);
 820 
 821   JNIHandles::destroy_local(obj);
 822 
 823   HOTSPOT_JNI_DELETELOCALREF_RETURN();
 824 JNI_END
 825 
 826 JNI_QUICK_ENTRY(jboolean, jni_IsSameObject(JNIEnv *env, jobject r1, jobject r2))
 827   JNIWrapper("IsSameObject");
 828 
 829   HOTSPOT_JNI_ISSAMEOBJECT_ENTRY(env, r1, r2);
 830 
 831   oop a = JNIHandles::resolve(r1);
 832   oop b = JNIHandles::resolve(r2);
 833   jboolean ret = (a == b) ? JNI_TRUE : JNI_FALSE;
 834 
 835   HOTSPOT_JNI_ISSAMEOBJECT_RETURN(ret);
 836   return ret;
 837 JNI_END
 838 
 839 
 840 JNI_ENTRY(jobject, jni_NewLocalRef(JNIEnv *env, jobject ref))
 841   JNIWrapper("NewLocalRef");
 842 
 843   HOTSPOT_JNI_NEWLOCALREF_ENTRY(env, ref);
 844 
 845   jobject ret = JNIHandles::make_local(env, JNIHandles::resolve(ref));
 846 
 847   HOTSPOT_JNI_NEWLOCALREF_RETURN(ret);
 848   return ret;
 849 JNI_END
 850 
 851 JNI_LEAF(jint, jni_EnsureLocalCapacity(JNIEnv *env, jint capacity))
 852   JNIWrapper("EnsureLocalCapacity");
 853 
 854   HOTSPOT_JNI_ENSURELOCALCAPACITY_ENTRY(env, capacity);
 855 
 856   jint ret;
 857   if (capacity &gt;= 0 &amp;&amp; capacity &lt;= MAX_REASONABLE_LOCAL_CAPACITY) {
 858     ret = JNI_OK;
 859   } else {
 860     ret = JNI_ERR;
 861   }
 862 
 863   HOTSPOT_JNI_ENSURELOCALCAPACITY_RETURN(ret);
 864   return ret;
 865 JNI_END
 866 
 867 // Return the Handle Type
 868 JNI_LEAF(jobjectRefType, jni_GetObjectRefType(JNIEnv *env, jobject obj))
 869   JNIWrapper("GetObjectRefType");
 870 
 871   HOTSPOT_JNI_GETOBJECTREFTYPE_ENTRY(env, obj);
 872 
 873   jobjectRefType ret;
 874   if (JNIHandles::is_local_handle(thread, obj) ||
 875       JNIHandles::is_frame_handle(thread, obj))
 876     ret = JNILocalRefType;
 877   else if (JNIHandles::is_global_handle(obj))
 878     ret = JNIGlobalRefType;
 879   else if (JNIHandles::is_weak_global_handle(obj))
 880     ret = JNIWeakGlobalRefType;
 881   else
 882     ret = JNIInvalidRefType;
 883 
 884   HOTSPOT_JNI_GETOBJECTREFTYPE_RETURN((void *) ret);
 885   return ret;
 886 JNI_END
 887 
 888 
 889 class JNI_ArgumentPusher : public SignatureIterator {
 890  protected:
 891   JavaCallArguments*  _arguments;
 892 
 893   virtual void get_bool   () = 0;
 894   virtual void get_char   () = 0;
 895   virtual void get_short  () = 0;
 896   virtual void get_byte   () = 0;
 897   virtual void get_int    () = 0;
 898   virtual void get_long   () = 0;
 899   virtual void get_float  () = 0;
 900   virtual void get_double () = 0;
 901   virtual void get_object () = 0;
 902 
 903   JNI_ArgumentPusher(Symbol* signature) : SignatureIterator(signature) {
 904     this-&gt;_return_type = T_ILLEGAL;
 905     _arguments = NULL;
 906   }
 907 
 908  public:
 909   virtual void iterate( uint64_t fingerprint ) = 0;
 910 
 911   void set_java_argument_object(JavaCallArguments *arguments) { _arguments = arguments; }
 912 
 913   inline void do_bool()                     { if (!is_return_type()) get_bool();   }
 914   inline void do_char()                     { if (!is_return_type()) get_char();   }
 915   inline void do_short()                    { if (!is_return_type()) get_short();  }
 916   inline void do_byte()                     { if (!is_return_type()) get_byte();   }
 917   inline void do_int()                      { if (!is_return_type()) get_int();    }
 918   inline void do_long()                     { if (!is_return_type()) get_long();   }
 919   inline void do_float()                    { if (!is_return_type()) get_float();  }
 920   inline void do_double()                   { if (!is_return_type()) get_double(); }
 921   inline void do_object(int begin, int end) { if (!is_return_type()) get_object(); }
 922   inline void do_array(int begin, int end)  { if (!is_return_type()) get_object(); } // do_array uses get_object -- there is no get_array
 923   inline void do_void()                     { }
 924 
 925   JavaCallArguments* arguments()     { return _arguments; }
 926   void push_receiver(Handle h)       { _arguments-&gt;push_oop(h); }
 927 };
 928 
 929 
 930 class JNI_ArgumentPusherVaArg : public JNI_ArgumentPusher {
 931  protected:
 932   va_list _ap;
 933 
 934   inline void get_bool()   { _arguments-&gt;push_int(va_arg(_ap, jint)); } // bool is coerced to int when using va_arg
 935   inline void get_char()   { _arguments-&gt;push_int(va_arg(_ap, jint)); } // char is coerced to int when using va_arg
 936   inline void get_short()  { _arguments-&gt;push_int(va_arg(_ap, jint)); } // short is coerced to int when using va_arg
 937   inline void get_byte()   { _arguments-&gt;push_int(va_arg(_ap, jint)); } // byte is coerced to int when using va_arg
 938   inline void get_int()    { _arguments-&gt;push_int(va_arg(_ap, jint)); }
 939 
 940   // each of these paths is exercized by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests
 941 
 942   inline void get_long()   { _arguments-&gt;push_long(va_arg(_ap, jlong)); }
 943   inline void get_float()  { _arguments-&gt;push_float((jfloat)va_arg(_ap, jdouble)); } // float is coerced to double w/ va_arg
 944   inline void get_double() { _arguments-&gt;push_double(va_arg(_ap, jdouble)); }
 945   inline void get_object() { jobject l = va_arg(_ap, jobject);
 946                              _arguments-&gt;push_oop(Handle((oop *)l, false)); }
 947 
 948   inline void set_ap(va_list rap) {
 949 #ifdef va_copy
 950     va_copy(_ap, rap);
 951 #elif defined (__va_copy)
 952     __va_copy(_ap, rap);
 953 #else
 954     _ap = rap;
 955 #endif
 956   }
 957 
 958  public:
 959   JNI_ArgumentPusherVaArg(Symbol* signature, va_list rap)
 960        : JNI_ArgumentPusher(signature) {
 961     set_ap(rap);
 962   }
 963   JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
 964       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)-&gt;signature()) {
 965     set_ap(rap);
 966   }
 967 
 968   // Optimized path if we have the bitvector form of signature
 969   void iterate( uint64_t fingerprint ) {
 970     if ( fingerprint == UCONST64(-1) ) SignatureIterator::iterate();// Must be too many arguments
 971     else {
 972       _return_type = (BasicType)((fingerprint &gt;&gt; static_feature_size) &amp;
 973                                   result_feature_mask);
 974 
 975       assert(fingerprint, "Fingerprint should not be 0");
 976       fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);
 977       while ( 1 ) {
 978         switch ( fingerprint &amp; parameter_feature_mask ) {
 979           case bool_parm:
 980           case char_parm:
 981           case short_parm:
 982           case byte_parm:
 983           case int_parm:
 984             get_int();
 985             break;
 986           case obj_parm:
 987             get_object();
 988             break;
 989           case long_parm:
 990             get_long();
 991             break;
 992           case float_parm:
 993             get_float();
 994             break;
 995           case double_parm:
 996             get_double();
 997             break;
 998           case done_parm:
 999             return;
1000             break;
1001           default:
1002             ShouldNotReachHere();
1003             break;
1004         }
1005         fingerprint &gt;&gt;= parameter_feature_size;
1006       }
1007     }
1008   }
1009 };
1010 
1011 
1012 class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
1013  protected:
1014   const jvalue *_ap;
1015 
1016   inline void get_bool()   { _arguments-&gt;push_int((jint)(_ap++)-&gt;z); }
1017   inline void get_char()   { _arguments-&gt;push_int((jint)(_ap++)-&gt;c); }
1018   inline void get_short()  { _arguments-&gt;push_int((jint)(_ap++)-&gt;s); }
1019   inline void get_byte()   { _arguments-&gt;push_int((jint)(_ap++)-&gt;b); }
1020   inline void get_int()    { _arguments-&gt;push_int((jint)(_ap++)-&gt;i); }
1021 
1022   inline void get_long()   { _arguments-&gt;push_long((_ap++)-&gt;j);  }
1023   inline void get_float()  { _arguments-&gt;push_float((_ap++)-&gt;f); }
1024   inline void get_double() { _arguments-&gt;push_double((_ap++)-&gt;d);}
1025   inline void get_object() { _arguments-&gt;push_oop(Handle((oop *)(_ap++)-&gt;l, false)); }
1026 
1027   inline void set_ap(const jvalue *rap) { _ap = rap; }
1028 
1029  public:
1030   JNI_ArgumentPusherArray(Symbol* signature, const jvalue *rap)
1031        : JNI_ArgumentPusher(signature) {
1032     set_ap(rap);
1033   }
1034   JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
1035       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)-&gt;signature()) {
1036     set_ap(rap);
1037   }
1038 
1039   // Optimized path if we have the bitvector form of signature
1040   void iterate( uint64_t fingerprint ) {
1041     if ( fingerprint == UCONST64(-1) ) SignatureIterator::iterate(); // Must be too many arguments
1042     else {
1043       _return_type = (BasicType)((fingerprint &gt;&gt; static_feature_size) &amp;
1044                                   result_feature_mask);
1045       assert(fingerprint, "Fingerprint should not be 0");
1046       fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);
1047       while ( 1 ) {
1048         switch ( fingerprint &amp; parameter_feature_mask ) {
1049           case bool_parm:
1050             get_bool();
1051             break;
1052           case char_parm:
1053             get_char();
1054             break;
1055           case short_parm:
1056             get_short();
1057             break;
1058           case byte_parm:
1059             get_byte();
1060             break;
1061           case int_parm:
1062             get_int();
1063             break;
1064           case obj_parm:
1065             get_object();
1066             break;
1067           case long_parm:
1068             get_long();
1069             break;
1070           case float_parm:
1071             get_float();
1072             break;
1073           case double_parm:
1074             get_double();
1075             break;
1076           case done_parm:
1077             return;
1078             break;
1079           default:
1080             ShouldNotReachHere();
1081             break;
1082         }
1083         fingerprint &gt;&gt;= parameter_feature_size;
1084       }
1085     }
1086   }
1087 };
1088 
1089 
1090 enum JNICallType {
1091   JNI_STATIC,
1092   JNI_VIRTUAL,
1093   JNI_NONVIRTUAL
1094 };
1095 
1096 
1097 
1098 static void jni_invoke_static(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1099   methodHandle method(THREAD, Method::resolve_jmethod_id(method_id));
1100 
1101   // Create object to hold arguments for the JavaCall, and associate it with
1102   // the jni parser
1103   ResourceMark rm(THREAD);
1104   int number_of_parameters = method-&gt;size_of_parameters();
1105   JavaCallArguments java_args(number_of_parameters);
1106   args-&gt;set_java_argument_object(&amp;java_args);
1107 
1108   assert(method-&gt;is_static(), "method should be static");
1109 
1110   // Fill out JavaCallArguments object
1111   args-&gt;iterate( Fingerprinter(method).fingerprint() );
1112   // Initialize result type
1113   result-&gt;set_type(args-&gt;get_ret_type());
1114 
1115   // Invoke the method. Result is returned as oop.
1116   JavaCalls::call(result, method, &amp;java_args, CHECK);
1117 
1118   // Convert result
1119   if (result-&gt;get_type() == T_OBJECT || result-&gt;get_type() == T_ARRAY) {
1120     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1121   }
1122 }
1123 
1124 
1125 static void jni_invoke_nonstatic(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1126   oop recv = JNIHandles::resolve(receiver);
1127   if (recv == NULL) {
1128     THROW(vmSymbols::java_lang_NullPointerException());
1129   }
1130   Handle h_recv(THREAD, recv);
1131 
1132   int number_of_parameters;
1133   Method* selected_method;
1134   {
1135     Method* m = Method::resolve_jmethod_id(method_id);
1136     number_of_parameters = m-&gt;size_of_parameters();
1137     Klass* holder = m-&gt;method_holder();
1138     if (!(holder)-&gt;is_interface()) {
1139       // non-interface call -- for that little speed boost, don't handlize
1140       debug_only(No_Safepoint_Verifier nosafepoint;)
1141       if (call_type == JNI_VIRTUAL) {
1142         // jni_GetMethodID makes sure class is linked and initialized
1143         // so m should have a valid vtable index.
1144         assert(!m-&gt;has_itable_index(), "");
1145         int vtbl_index = m-&gt;vtable_index();
1146         if (vtbl_index != Method::nonvirtual_vtable_index) {
1147           Klass* k = h_recv-&gt;klass();
1148           // k might be an arrayKlassOop but all vtables start at
1149           // the same place. The cast is to avoid virtual call and assertion.
1150           InstanceKlass *ik = (InstanceKlass*)k;
1151           selected_method = ik-&gt;method_at_vtable(vtbl_index);
1152         } else {
1153           // final method
1154           selected_method = m;
1155         }
1156       } else {
1157         // JNI_NONVIRTUAL call
1158         selected_method = m;
1159       }
1160     } else {
1161       // interface call
1162       KlassHandle h_holder(THREAD, holder);
1163 
1164       if (call_type == JNI_VIRTUAL) {
1165         int itbl_index = m-&gt;itable_index();
1166         Klass* k = h_recv-&gt;klass();
1167         selected_method = InstanceKlass::cast(k)-&gt;method_at_itable(h_holder(), itbl_index, CHECK);
1168       } else {
1169         selected_method = m;
1170       }
1171     }
1172   }
1173 
1174   methodHandle method(THREAD, selected_method);
1175 
1176   // Create object to hold arguments for the JavaCall, and associate it with
1177   // the jni parser
1178   ResourceMark rm(THREAD);
1179   JavaCallArguments java_args(number_of_parameters);
1180   args-&gt;set_java_argument_object(&amp;java_args);
1181 
1182   // handle arguments
1183   assert(!method-&gt;is_static(), "method should not be static");
1184   args-&gt;push_receiver(h_recv); // Push jobject handle
1185 
1186   // Fill out JavaCallArguments object
1187   args-&gt;iterate( Fingerprinter(method).fingerprint() );
1188   // Initialize result type
1189   result-&gt;set_type(args-&gt;get_ret_type());
1190 
1191   // Invoke the method. Result is returned as oop.
1192   JavaCalls::call(result, method, &amp;java_args, CHECK);
1193 
1194   // Convert result
1195   if (result-&gt;get_type() == T_OBJECT || result-&gt;get_type() == T_ARRAY) {
1196     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1197   }
1198 }
1199 
1200 
1201 static instanceOop alloc_object(jclass clazz, TRAPS) {
1202   KlassHandle k(THREAD, java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
1203   if (k == NULL) {
1204     ResourceMark rm(THREAD);
1205     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1206   }
1207   k()-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1208   InstanceKlass::cast(k())-&gt;initialize(CHECK_NULL);
1209   instanceOop ih = InstanceKlass::cast(k())-&gt;allocate_instance(THREAD);
1210   return ih;
1211 }
1212 
1213 DT_RETURN_MARK_DECL(AllocObject, jobject
1214                     , HOTSPOT_JNI_ALLOCOBJECT_RETURN(_ret_ref));
1215 
1216 JNI_ENTRY(jobject, jni_AllocObject(JNIEnv *env, jclass clazz))
1217   JNIWrapper("AllocObject");
1218 
1219   HOTSPOT_JNI_ALLOCOBJECT_ENTRY(env, clazz);
1220 
1221   jobject ret = NULL;
1222   DT_RETURN_MARK(AllocObject, jobject, (const jobject&amp;)ret);
1223 
1224   instanceOop i = alloc_object(clazz, CHECK_NULL);
1225   ret = JNIHandles::make_local(env, i);
1226   return ret;
1227 JNI_END
1228 
1229 DT_RETURN_MARK_DECL(NewObjectA, jobject
1230                     , HOTSPOT_JNI_NEWOBJECTA_RETURN(_ret_ref));
1231 
1232 JNI_ENTRY(jobject, jni_NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args))
1233   JNIWrapper("NewObjectA");
1234 
1235   HOTSPOT_JNI_NEWOBJECTA_ENTRY(env, clazz, (uintptr_t) methodID);
1236 
1237   jobject obj = NULL;
1238   DT_RETURN_MARK(NewObjectA, jobject, (const jobject)obj);
1239 
1240   instanceOop i = alloc_object(clazz, CHECK_NULL);
1241   obj = JNIHandles::make_local(env, i);
1242   JavaValue jvalue(T_VOID);
1243   JNI_ArgumentPusherArray ap(methodID, args);
1244   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1245   return obj;
1246 JNI_END
1247 
1248 
1249 DT_RETURN_MARK_DECL(NewObjectV, jobject
1250                     , HOTSPOT_JNI_NEWOBJECTV_RETURN(_ret_ref));
1251 
1252 JNI_ENTRY(jobject, jni_NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args))
1253   JNIWrapper("NewObjectV");
1254 
1255   HOTSPOT_JNI_NEWOBJECTV_ENTRY(env, clazz, (uintptr_t) methodID);
1256 
1257   jobject obj = NULL;
1258   DT_RETURN_MARK(NewObjectV, jobject, (const jobject&amp;)obj);
1259 
1260   instanceOop i = alloc_object(clazz, CHECK_NULL);
1261   obj = JNIHandles::make_local(env, i);
1262   JavaValue jvalue(T_VOID);
1263   JNI_ArgumentPusherVaArg ap(methodID, args);
1264   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1265   return obj;
1266 JNI_END
1267 
1268 
1269 DT_RETURN_MARK_DECL(NewObject, jobject
1270                     , HOTSPOT_JNI_NEWOBJECT_RETURN(_ret_ref));
1271 
1272 JNI_ENTRY(jobject, jni_NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...))
1273   JNIWrapper("NewObject");
1274 
1275   HOTSPOT_JNI_NEWOBJECT_ENTRY(env, clazz, (uintptr_t) methodID);
1276 
1277   jobject obj = NULL;
1278   DT_RETURN_MARK(NewObject, jobject, (const jobject&amp;)obj);
1279 
1280   instanceOop i = alloc_object(clazz, CHECK_NULL);
1281   obj = JNIHandles::make_local(env, i);
1282   va_list args;
1283   va_start(args, methodID);
1284   JavaValue jvalue(T_VOID);
1285   JNI_ArgumentPusherVaArg ap(methodID, args);
1286   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1287   va_end(args);
1288   return obj;
1289 JNI_END
1290 
1291 
1292 JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
1293   JNIWrapper("GetObjectClass");
1294 
1295   HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(env, obj);
1296 
1297   Klass* k = JNIHandles::resolve_non_null(obj)-&gt;klass();
1298   jclass ret =
1299     (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1300 
1301   HOTSPOT_JNI_GETOBJECTCLASS_RETURN(ret);
1302   return ret;
1303 JNI_END
1304 
1305 JNI_QUICK_ENTRY(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))
1306   JNIWrapper("IsInstanceOf");
1307 
1308   HOTSPOT_JNI_ISINSTANCEOF_ENTRY(env, obj, clazz);
1309 
1310   jboolean ret = JNI_TRUE;
1311   if (obj != NULL) {
1312     ret = JNI_FALSE;
1313     Klass* k = java_lang_Class::as_Klass(
1314       JNIHandles::resolve_non_null(clazz));
1315     if (k != NULL) {
1316       ret = JNIHandles::resolve_non_null(obj)-&gt;is_a(k) ? JNI_TRUE : JNI_FALSE;
1317     }
1318   }
1319 
1320   HOTSPOT_JNI_ISINSTANCEOF_RETURN(ret);
1321   return ret;
1322 JNI_END
1323 
1324 
1325 static jmethodID get_method_id(JNIEnv *env, jclass clazz, const char *name_str,
1326                                const char *sig, bool is_static, TRAPS) {
1327   // %%%% This code should probably just call into a method in the LinkResolver
1328   //
1329   // The class should have been loaded (we have an instance of the class
1330   // passed in) so the method and signature should already be in the symbol
1331   // table.  If they're not there, the method doesn't exist.
1332   const char *name_to_probe = (name_str == NULL)
1333                         ? vmSymbols::object_initializer_name()-&gt;as_C_string()
1334                         : name_str;
1335   TempNewSymbol name = SymbolTable::probe(name_to_probe, (int)strlen(name_to_probe));
1336   TempNewSymbol signature = SymbolTable::probe(sig, (int)strlen(sig));
1337 
1338   if (name == NULL || signature == NULL) {
1339     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
1340   }
1341 
1342   // Throw a NoSuchMethodError exception if we have an instance of a
1343   // primitive java.lang.Class
1344   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(clazz))) {
1345     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
1346   }
1347 
1348   KlassHandle klass(THREAD,
1349                java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
1350 
1351   // Make sure class is linked and initialized before handing id's out to
1352   // Method*s.
1353   klass()-&gt;initialize(CHECK_NULL);
1354 
1355   Method* m;
1356   if (name == vmSymbols::object_initializer_name() ||
1357       name == vmSymbols::class_initializer_name()) {
1358     // Never search superclasses for constructors
1359     if (klass-&gt;oop_is_instance()) {
1360       m = InstanceKlass::cast(klass())-&gt;find_method(name, signature);
1361     } else {
1362       m = NULL;
1363     }
1364   } else {
1365     m = klass-&gt;lookup_method(name, signature);
1366     if (m == NULL &amp;&amp;  klass-&gt;oop_is_instance()) {
1367       m = InstanceKlass::cast(klass())-&gt;lookup_method_in_ordered_interfaces(name, signature);
1368     }
1369   }
1370   if (m == NULL || (m-&gt;is_static() != is_static)) {
1371     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
1372   }
1373   return m-&gt;jmethod_id();
1374 }
1375 
1376 
1377 JNI_ENTRY(jmethodID, jni_GetMethodID(JNIEnv *env, jclass clazz,
1378           const char *name, const char *sig))
1379   JNIWrapper("GetMethodID");
1380   HOTSPOT_JNI_GETMETHODID_ENTRY(env, clazz, (char *) name, (char *) sig);
1381   jmethodID ret = get_method_id(env, clazz, name, sig, false, thread);
1382   HOTSPOT_JNI_GETMETHODID_RETURN((uintptr_t) ret);
1383   return ret;
1384 JNI_END
1385 
1386 
1387 JNI_ENTRY(jmethodID, jni_GetStaticMethodID(JNIEnv *env, jclass clazz,
1388           const char *name, const char *sig))
1389   JNIWrapper("GetStaticMethodID");
1390   HOTSPOT_JNI_GETSTATICMETHODID_ENTRY(env, (char *) clazz, (char *) name, (char *)sig);
1391   jmethodID ret = get_method_id(env, clazz, name, sig, true, thread);
1392   HOTSPOT_JNI_GETSTATICMETHODID_RETURN((uintptr_t) ret);
1393   return ret;
1394 JNI_END
1395 
1396 
1397 
1398 //
1399 // Calling Methods
1400 //
1401 
1402 
1403 #define DEFINE_CALLMETHOD(ResultType, Result, Tag \
1404                           , EntryProbe, ReturnProbe)    \
1405 \
1406   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##Method, ResultType \
1407                           , ReturnProbe);                          \
1408 \
1409 JNI_ENTRY(ResultType, \
1410           jni_Call##Result##Method(JNIEnv *env, jobject obj, jmethodID methodID, ...)) \
1411   JNIWrapper("Call" XSTR(Result) "Method"); \
1412 \
1413   EntryProbe; \
1414   ResultType ret = 0;\
1415   DT_RETURN_MARK_FOR(Result, Call##Result##Method, ResultType, \
1416                      (const ResultType&amp;)ret);\
1417 \
1418   va_list args; \
1419   va_start(args, methodID); \
1420   JavaValue jvalue(Tag); \
1421   JNI_ArgumentPusherVaArg ap(methodID, args); \
1422   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1423   va_end(args); \
1424   ret = jvalue.get_##ResultType(); \
1425   return ret;\
1426 JNI_END
1427 
1428 // the runtime type of subword integral basic types is integer
1429 DEFINE_CALLMETHOD(jboolean, Boolean, T_BOOLEAN
1430                   , HOTSPOT_JNI_CALLBOOLEANMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1431                   HOTSPOT_JNI_CALLBOOLEANMETHOD_RETURN(_ret_ref))
1432 DEFINE_CALLMETHOD(jbyte,    Byte,    T_BYTE
1433                   , HOTSPOT_JNI_CALLBYTEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1434                   HOTSPOT_JNI_CALLBYTEMETHOD_RETURN(_ret_ref))
1435 DEFINE_CALLMETHOD(jchar,    Char,    T_CHAR
1436                   , HOTSPOT_JNI_CALLCHARMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1437                   HOTSPOT_JNI_CALLCHARMETHOD_RETURN(_ret_ref))
1438 DEFINE_CALLMETHOD(jshort,   Short,   T_SHORT
1439                   , HOTSPOT_JNI_CALLSHORTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1440                   HOTSPOT_JNI_CALLSHORTMETHOD_RETURN(_ret_ref))
1441 
1442 DEFINE_CALLMETHOD(jobject,  Object,  T_OBJECT
1443                   , HOTSPOT_JNI_CALLOBJECTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1444                   HOTSPOT_JNI_CALLOBJECTMETHOD_RETURN(_ret_ref))
1445 DEFINE_CALLMETHOD(jint,     Int,     T_INT,
1446                   HOTSPOT_JNI_CALLINTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1447                   HOTSPOT_JNI_CALLINTMETHOD_RETURN(_ret_ref))
1448 DEFINE_CALLMETHOD(jlong,    Long,    T_LONG
1449                   , HOTSPOT_JNI_CALLLONGMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1450                   HOTSPOT_JNI_CALLLONGMETHOD_RETURN(_ret_ref))
1451 // Float and double probes don't return value because dtrace doesn't currently support it
1452 DEFINE_CALLMETHOD(jfloat,   Float,   T_FLOAT
1453                   , HOTSPOT_JNI_CALLFLOATMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1454                   HOTSPOT_JNI_CALLFLOATMETHOD_RETURN())
1455 DEFINE_CALLMETHOD(jdouble,  Double,  T_DOUBLE
1456                   , HOTSPOT_JNI_CALLDOUBLEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1457                   HOTSPOT_JNI_CALLDOUBLEMETHOD_RETURN())
1458 
1459 #define DEFINE_CALLMETHODV(ResultType, Result, Tag \
1460                           , EntryProbe, ReturnProbe)    \
1461 \
1462   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodV, ResultType \
1463                           , ReturnProbe);                          \
1464 \
1465 JNI_ENTRY(ResultType, \
1466           jni_Call##Result##MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args)) \
1467   JNIWrapper("Call" XSTR(Result) "MethodV"); \
1468 \
1469   EntryProbe;\
1470   ResultType ret = 0;\
1471   DT_RETURN_MARK_FOR(Result, Call##Result##MethodV, ResultType, \
1472                      (const ResultType&amp;)ret);\
1473 \
1474   JavaValue jvalue(Tag); \
1475   JNI_ArgumentPusherVaArg ap(methodID, args); \
1476   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1477   ret = jvalue.get_##ResultType(); \
1478   return ret;\
1479 JNI_END
1480 
1481 // the runtime type of subword integral basic types is integer
1482 DEFINE_CALLMETHODV(jboolean, Boolean, T_BOOLEAN
1483                   , HOTSPOT_JNI_CALLBOOLEANMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1484                   HOTSPOT_JNI_CALLBOOLEANMETHODV_RETURN(_ret_ref))
1485 DEFINE_CALLMETHODV(jbyte,    Byte,    T_BYTE
1486                   , HOTSPOT_JNI_CALLBYTEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1487                   HOTSPOT_JNI_CALLBYTEMETHODV_RETURN(_ret_ref))
1488 DEFINE_CALLMETHODV(jchar,    Char,    T_CHAR
1489                   , HOTSPOT_JNI_CALLCHARMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1490                   HOTSPOT_JNI_CALLCHARMETHODV_RETURN(_ret_ref))
1491 DEFINE_CALLMETHODV(jshort,   Short,   T_SHORT
1492                   , HOTSPOT_JNI_CALLSHORTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1493                   HOTSPOT_JNI_CALLSHORTMETHODV_RETURN(_ret_ref))
1494 
1495 DEFINE_CALLMETHODV(jobject,  Object,  T_OBJECT
1496                   , HOTSPOT_JNI_CALLOBJECTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1497                   HOTSPOT_JNI_CALLOBJECTMETHODV_RETURN(_ret_ref))
1498 DEFINE_CALLMETHODV(jint,     Int,     T_INT,
1499                   HOTSPOT_JNI_CALLINTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1500                   HOTSPOT_JNI_CALLINTMETHODV_RETURN(_ret_ref))
1501 DEFINE_CALLMETHODV(jlong,    Long,    T_LONG
1502                   , HOTSPOT_JNI_CALLLONGMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1503                   HOTSPOT_JNI_CALLLONGMETHODV_RETURN(_ret_ref))
1504 // Float and double probes don't return value because dtrace doesn't currently support it
1505 DEFINE_CALLMETHODV(jfloat,   Float,   T_FLOAT
1506                   , HOTSPOT_JNI_CALLFLOATMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1507                   HOTSPOT_JNI_CALLFLOATMETHODV_RETURN())
1508 DEFINE_CALLMETHODV(jdouble,  Double,  T_DOUBLE
1509                   , HOTSPOT_JNI_CALLDOUBLEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1510                   HOTSPOT_JNI_CALLDOUBLEMETHODV_RETURN())
1511 
1512 #define DEFINE_CALLMETHODA(ResultType, Result, Tag \
1513                           , EntryProbe, ReturnProbe)    \
1514 \
1515   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodA, ResultType \
1516                           , ReturnProbe);                          \
1517 \
1518 JNI_ENTRY(ResultType, \
1519           jni_Call##Result##MethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args)) \
1520   JNIWrapper("Call" XSTR(Result) "MethodA"); \
1521   EntryProbe; \
1522   ResultType ret = 0;\
1523   DT_RETURN_MARK_FOR(Result, Call##Result##MethodA, ResultType, \
1524                      (const ResultType&amp;)ret);\
1525 \
1526   JavaValue jvalue(Tag); \
1527   JNI_ArgumentPusherArray ap(methodID, args); \
1528   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1529   ret = jvalue.get_##ResultType(); \
1530   return ret;\
1531 JNI_END
1532 
1533 // the runtime type of subword integral basic types is integer
1534 DEFINE_CALLMETHODA(jboolean, Boolean, T_BOOLEAN
1535                   , HOTSPOT_JNI_CALLBOOLEANMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1536                   HOTSPOT_JNI_CALLBOOLEANMETHODA_RETURN(_ret_ref))
1537 DEFINE_CALLMETHODA(jbyte,    Byte,    T_BYTE
1538                   , HOTSPOT_JNI_CALLBYTEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1539                   HOTSPOT_JNI_CALLBYTEMETHODA_RETURN(_ret_ref))
1540 DEFINE_CALLMETHODA(jchar,    Char,    T_CHAR
1541                   , HOTSPOT_JNI_CALLCHARMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1542                   HOTSPOT_JNI_CALLCHARMETHODA_RETURN(_ret_ref))
1543 DEFINE_CALLMETHODA(jshort,   Short,   T_SHORT
1544                   , HOTSPOT_JNI_CALLSHORTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1545                   HOTSPOT_JNI_CALLSHORTMETHODA_RETURN(_ret_ref))
1546 
1547 DEFINE_CALLMETHODA(jobject,  Object,  T_OBJECT
1548                   , HOTSPOT_JNI_CALLOBJECTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1549                   HOTSPOT_JNI_CALLOBJECTMETHODA_RETURN(_ret_ref))
1550 DEFINE_CALLMETHODA(jint,     Int,     T_INT,
1551                   HOTSPOT_JNI_CALLINTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1552                   HOTSPOT_JNI_CALLINTMETHODA_RETURN(_ret_ref))
1553 DEFINE_CALLMETHODA(jlong,    Long,    T_LONG
1554                   , HOTSPOT_JNI_CALLLONGMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1555                   HOTSPOT_JNI_CALLLONGMETHODA_RETURN(_ret_ref))
1556 // Float and double probes don't return value because dtrace doesn't currently support it
1557 DEFINE_CALLMETHODA(jfloat,   Float,   T_FLOAT
1558                   , HOTSPOT_JNI_CALLFLOATMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1559                   HOTSPOT_JNI_CALLFLOATMETHODA_RETURN())
1560 DEFINE_CALLMETHODA(jdouble,  Double,  T_DOUBLE
1561                   , HOTSPOT_JNI_CALLDOUBLEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1562                   HOTSPOT_JNI_CALLDOUBLEMETHODA_RETURN())
1563 
1564 DT_VOID_RETURN_MARK_DECL(CallVoidMethod, HOTSPOT_JNI_CALLVOIDMETHOD_RETURN());
1565 DT_VOID_RETURN_MARK_DECL(CallVoidMethodV, HOTSPOT_JNI_CALLVOIDMETHODV_RETURN());
1566 DT_VOID_RETURN_MARK_DECL(CallVoidMethodA, HOTSPOT_JNI_CALLVOIDMETHODA_RETURN());
1567 
1568 
1569 JNI_ENTRY(void, jni_CallVoidMethod(JNIEnv *env, jobject obj, jmethodID methodID, ...))
1570   JNIWrapper("CallVoidMethod");
1571   HOTSPOT_JNI_CALLVOIDMETHOD_ENTRY(env, obj, (uintptr_t) methodID);
1572   DT_VOID_RETURN_MARK(CallVoidMethod);
1573 
1574   va_list args;
1575   va_start(args, methodID);
1576   JavaValue jvalue(T_VOID);
1577   JNI_ArgumentPusherVaArg ap(methodID, args);
1578   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1579   va_end(args);
1580 JNI_END
1581 
1582 
1583 JNI_ENTRY(void, jni_CallVoidMethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args))
1584   JNIWrapper("CallVoidMethodV");
1585   HOTSPOT_JNI_CALLVOIDMETHODV_ENTRY(env, obj, (uintptr_t) methodID);
1586   DT_VOID_RETURN_MARK(CallVoidMethodV);
1587 
1588   JavaValue jvalue(T_VOID);
1589   JNI_ArgumentPusherVaArg ap(methodID, args);
1590   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1591 JNI_END
1592 
1593 
1594 JNI_ENTRY(void, jni_CallVoidMethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args))
1595   JNIWrapper("CallVoidMethodA");
1596   HOTSPOT_JNI_CALLVOIDMETHODA_ENTRY(env, obj, (uintptr_t) methodID);
1597   DT_VOID_RETURN_MARK(CallVoidMethodA);
1598 
1599   JavaValue jvalue(T_VOID);
1600   JNI_ArgumentPusherArray ap(methodID, args);
1601   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1602 JNI_END
1603 
1604 
1605 
1606 #define DEFINE_CALLNONVIRTUALMETHOD(ResultType, Result, Tag \
1607                                     , EntryProbe, ReturnProbe)      \
1608 \
1609   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##Method, ResultType \
1610                           , ReturnProbe);\
1611 \
1612 JNI_ENTRY(ResultType, \
1613           jni_CallNonvirtual##Result##Method(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...)) \
1614   JNIWrapper("CallNonvitual" XSTR(Result) "Method"); \
1615 \
1616   EntryProbe;\
1617   ResultType ret;\
1618   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##Method, ResultType, \
1619                      (const ResultType&amp;)ret);\
1620 \
1621   va_list args; \
1622   va_start(args, methodID); \
1623   JavaValue jvalue(Tag); \
1624   JNI_ArgumentPusherVaArg ap(methodID, args); \
1625   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1626   va_end(args); \
1627   ret = jvalue.get_##ResultType(); \
1628   return ret;\
1629 JNI_END
1630 
1631 // the runtime type of subword integral basic types is integer
1632 DEFINE_CALLNONVIRTUALMETHOD(jboolean, Boolean, T_BOOLEAN
1633                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1634                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_RETURN(_ret_ref))
1635 DEFINE_CALLNONVIRTUALMETHOD(jbyte,    Byte,    T_BYTE
1636                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1637                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_RETURN(_ret_ref))
1638 DEFINE_CALLNONVIRTUALMETHOD(jchar,    Char,    T_CHAR
1639                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1640                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_RETURN(_ret_ref))
1641 DEFINE_CALLNONVIRTUALMETHOD(jshort,   Short,   T_SHORT
1642                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1643                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_RETURN(_ret_ref))
1644 
1645 DEFINE_CALLNONVIRTUALMETHOD(jobject,  Object,  T_OBJECT
1646                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1647                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_RETURN(_ret_ref))
1648 DEFINE_CALLNONVIRTUALMETHOD(jint,     Int,     T_INT
1649                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1650                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_RETURN(_ret_ref))
1651 DEFINE_CALLNONVIRTUALMETHOD(jlong,    Long,    T_LONG
1652                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1653 // Float and double probes don't return value because dtrace doesn't currently support it
1654                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_RETURN(_ret_ref))
1655 DEFINE_CALLNONVIRTUALMETHOD(jfloat,   Float,   T_FLOAT
1656                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1657                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_RETURN())
1658 DEFINE_CALLNONVIRTUALMETHOD(jdouble,  Double,  T_DOUBLE
1659                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1660                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_RETURN())
1661 
1662 #define DEFINE_CALLNONVIRTUALMETHODV(ResultType, Result, Tag \
1663                                     , EntryProbe, ReturnProbe)      \
1664 \
1665   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodV, ResultType \
1666                           , ReturnProbe);\
1667 \
1668 JNI_ENTRY(ResultType, \
1669           jni_CallNonvirtual##Result##MethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args)) \
1670   JNIWrapper("CallNonvitual" XSTR(Result) "MethodV"); \
1671 \
1672   EntryProbe;\
1673   ResultType ret;\
1674   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodV, ResultType, \
1675                      (const ResultType&amp;)ret);\
1676 \
1677   JavaValue jvalue(Tag); \
1678   JNI_ArgumentPusherVaArg ap(methodID, args); \
1679   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1680   ret = jvalue.get_##ResultType(); \
1681   return ret;\
1682 JNI_END
1683 
1684 // the runtime type of subword integral basic types is integer
1685 DEFINE_CALLNONVIRTUALMETHODV(jboolean, Boolean, T_BOOLEAN
1686                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1687                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_RETURN(_ret_ref))
1688 DEFINE_CALLNONVIRTUALMETHODV(jbyte,    Byte,    T_BYTE
1689                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1690                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_RETURN(_ret_ref))
1691 DEFINE_CALLNONVIRTUALMETHODV(jchar,    Char,    T_CHAR
1692                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1693                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_RETURN(_ret_ref))
1694 DEFINE_CALLNONVIRTUALMETHODV(jshort,   Short,   T_SHORT
1695                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1696                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_RETURN(_ret_ref))
1697 
1698 DEFINE_CALLNONVIRTUALMETHODV(jobject,  Object,  T_OBJECT
1699                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1700                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_RETURN(_ret_ref))
1701 DEFINE_CALLNONVIRTUALMETHODV(jint,     Int,     T_INT
1702                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1703                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_RETURN(_ret_ref))
1704 DEFINE_CALLNONVIRTUALMETHODV(jlong,    Long,    T_LONG
1705                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1706 // Float and double probes don't return value because dtrace doesn't currently support it
1707                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_RETURN(_ret_ref))
1708 DEFINE_CALLNONVIRTUALMETHODV(jfloat,   Float,   T_FLOAT
1709                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1710                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_RETURN())
1711 DEFINE_CALLNONVIRTUALMETHODV(jdouble,  Double,  T_DOUBLE
1712                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1713                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_RETURN())
1714 
1715 #define DEFINE_CALLNONVIRTUALMETHODA(ResultType, Result, Tag \
1716                                     , EntryProbe, ReturnProbe)      \
1717 \
1718   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodA, ResultType \
1719                           , ReturnProbe);\
1720 \
1721 JNI_ENTRY(ResultType, \
1722           jni_CallNonvirtual##Result##MethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args)) \
1723   JNIWrapper("CallNonvitual" XSTR(Result) "MethodA"); \
1724 \
1725   EntryProbe;\
1726   ResultType ret;\
1727   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodA, ResultType, \
1728                      (const ResultType&amp;)ret);\
1729 \
1730   JavaValue jvalue(Tag); \
1731   JNI_ArgumentPusherArray ap(methodID, args); \
1732   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1733   ret = jvalue.get_##ResultType(); \
1734   return ret;\
1735 JNI_END
1736 
1737 // the runtime type of subword integral basic types is integer
1738 DEFINE_CALLNONVIRTUALMETHODA(jboolean, Boolean, T_BOOLEAN
1739                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1740                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_RETURN(_ret_ref))
1741 DEFINE_CALLNONVIRTUALMETHODA(jbyte,    Byte,    T_BYTE
1742                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1743                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_RETURN(_ret_ref))
1744 DEFINE_CALLNONVIRTUALMETHODA(jchar,    Char,    T_CHAR
1745                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1746                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_RETURN(_ret_ref))
1747 DEFINE_CALLNONVIRTUALMETHODA(jshort,   Short,   T_SHORT
1748                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1749                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_RETURN(_ret_ref))
1750 
1751 DEFINE_CALLNONVIRTUALMETHODA(jobject,  Object,  T_OBJECT
1752                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1753                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_RETURN(_ret_ref))
1754 DEFINE_CALLNONVIRTUALMETHODA(jint,     Int,     T_INT
1755                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1756                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_RETURN(_ret_ref))
1757 DEFINE_CALLNONVIRTUALMETHODA(jlong,    Long,    T_LONG
1758                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1759 // Float and double probes don't return value because dtrace doesn't currently support it
1760                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_RETURN(_ret_ref))
1761 DEFINE_CALLNONVIRTUALMETHODA(jfloat,   Float,   T_FLOAT
1762                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1763                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_RETURN())
1764 DEFINE_CALLNONVIRTUALMETHODA(jdouble,  Double,  T_DOUBLE
1765                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1766                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_RETURN())
1767 
1768 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethod
1769                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_RETURN());
1770 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodV
1771                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_RETURN());
1772 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodA
1773                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_RETURN());
1774 
1775 JNI_ENTRY(void, jni_CallNonvirtualVoidMethod(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...))
1776   JNIWrapper("CallNonvirtualVoidMethod");
1777 
1778   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_ENTRY(env, obj, cls, (uintptr_t) methodID);
1779   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethod);
1780 
1781   va_list args;
1782   va_start(args, methodID);
1783   JavaValue jvalue(T_VOID);
1784   JNI_ArgumentPusherVaArg ap(methodID, args);
1785   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1786   va_end(args);
1787 JNI_END
1788 
1789 
1790 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args))
1791   JNIWrapper("CallNonvirtualVoidMethodV");
1792 
1793   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_ENTRY(
1794                env, obj, cls, (uintptr_t) methodID);
1795   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodV);
1796 
1797   JavaValue jvalue(T_VOID);
1798   JNI_ArgumentPusherVaArg ap(methodID, args);
1799   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1800 JNI_END
1801 
1802 
1803 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args))
1804   JNIWrapper("CallNonvirtualVoidMethodA");
1805   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_ENTRY(
1806                 env, obj, cls, (uintptr_t) methodID);
1807   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodA);
1808   JavaValue jvalue(T_VOID);
1809   JNI_ArgumentPusherArray ap(methodID, args);
1810   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1811 JNI_END
1812 
1813 
1814 
1815 #define DEFINE_CALLSTATICMETHOD(ResultType, Result, Tag \
1816                                 , EntryProbe, ResultProbe) \
1817 \
1818   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##Method, ResultType \
1819                           , ResultProbe);                               \
1820 \
1821 JNI_ENTRY(ResultType, \
1822           jni_CallStatic##Result##Method(JNIEnv *env, jclass cls, jmethodID methodID, ...)) \
1823   JNIWrapper("CallStatic" XSTR(Result) "Method"); \
1824 \
1825   EntryProbe; \
1826   ResultType ret = 0;\
1827   DT_RETURN_MARK_FOR(Result, CallStatic##Result##Method, ResultType, \
1828                      (const ResultType&amp;)ret);\
1829 \
1830   va_list args; \
1831   va_start(args, methodID); \
1832   JavaValue jvalue(Tag); \
1833   JNI_ArgumentPusherVaArg ap(methodID, args); \
1834   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1835   va_end(args); \
1836   ret = jvalue.get_##ResultType(); \
1837   return ret;\
1838 JNI_END
1839 
1840 // the runtime type of subword integral basic types is integer
1841 DEFINE_CALLSTATICMETHOD(jboolean, Boolean, T_BOOLEAN
1842                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1843                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_RETURN(_ret_ref));
1844 DEFINE_CALLSTATICMETHOD(jbyte,    Byte,    T_BYTE
1845                         , HOTSPOT_JNI_CALLSTATICBYTEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1846                         HOTSPOT_JNI_CALLSTATICBYTEMETHOD_RETURN(_ret_ref));
1847 DEFINE_CALLSTATICMETHOD(jchar,    Char,    T_CHAR
1848                         , HOTSPOT_JNI_CALLSTATICCHARMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1849                         HOTSPOT_JNI_CALLSTATICCHARMETHOD_RETURN(_ret_ref));
1850 DEFINE_CALLSTATICMETHOD(jshort,   Short,   T_SHORT
1851                         , HOTSPOT_JNI_CALLSTATICSHORTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1852                         HOTSPOT_JNI_CALLSTATICSHORTMETHOD_RETURN(_ret_ref));
1853 
1854 DEFINE_CALLSTATICMETHOD(jobject,  Object,  T_OBJECT
1855                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1856                         HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_RETURN(_ret_ref));
1857 DEFINE_CALLSTATICMETHOD(jint,     Int,     T_INT
1858                         , HOTSPOT_JNI_CALLSTATICINTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1859                         HOTSPOT_JNI_CALLSTATICINTMETHOD_RETURN(_ret_ref));
1860 DEFINE_CALLSTATICMETHOD(jlong,    Long,    T_LONG
1861                         , HOTSPOT_JNI_CALLSTATICLONGMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1862                         HOTSPOT_JNI_CALLSTATICLONGMETHOD_RETURN(_ret_ref));
1863 // Float and double probes don't return value because dtrace doesn't currently support it
1864 DEFINE_CALLSTATICMETHOD(jfloat,   Float,   T_FLOAT
1865                         , HOTSPOT_JNI_CALLSTATICFLOATMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1866                         HOTSPOT_JNI_CALLSTATICFLOATMETHOD_RETURN());
1867 DEFINE_CALLSTATICMETHOD(jdouble,  Double,  T_DOUBLE
1868                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1869                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_RETURN());
1870 
1871 #define DEFINE_CALLSTATICMETHODV(ResultType, Result, Tag \
1872                                 , EntryProbe, ResultProbe) \
1873 \
1874   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodV, ResultType \
1875                           , ResultProbe);                               \
1876 \
1877 JNI_ENTRY(ResultType, \
1878           jni_CallStatic##Result##MethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args)) \
1879   JNIWrapper("CallStatic" XSTR(Result) "MethodV"); \
1880 \
1881   EntryProbe; \
1882   ResultType ret = 0;\
1883   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodV, ResultType, \
1884                      (const ResultType&amp;)ret);\
1885 \
1886   JavaValue jvalue(Tag); \
1887   JNI_ArgumentPusherVaArg ap(methodID, args); \
1888   /* Make sure class is initialized before trying to invoke its method */ \
1889   KlassHandle k(THREAD, java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls))); \
1890   k()-&gt;initialize(CHECK_0); \
1891   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1892   va_end(args); \
1893   ret = jvalue.get_##ResultType(); \
1894   return ret;\
1895 JNI_END
1896 
1897 // the runtime type of subword integral basic types is integer
1898 DEFINE_CALLSTATICMETHODV(jboolean, Boolean, T_BOOLEAN
1899                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1900                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_RETURN(_ret_ref));
1901 DEFINE_CALLSTATICMETHODV(jbyte,    Byte,    T_BYTE
1902                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1903                         HOTSPOT_JNI_CALLSTATICBYTEMETHODV_RETURN(_ret_ref));
1904 DEFINE_CALLSTATICMETHODV(jchar,    Char,    T_CHAR
1905                         , HOTSPOT_JNI_CALLSTATICCHARMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1906                         HOTSPOT_JNI_CALLSTATICCHARMETHODV_RETURN(_ret_ref));
1907 DEFINE_CALLSTATICMETHODV(jshort,   Short,   T_SHORT
1908                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1909                         HOTSPOT_JNI_CALLSTATICSHORTMETHODV_RETURN(_ret_ref));
1910 
1911 DEFINE_CALLSTATICMETHODV(jobject,  Object,  T_OBJECT
1912                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1913                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_RETURN(_ret_ref));
1914 DEFINE_CALLSTATICMETHODV(jint,     Int,     T_INT
1915                         , HOTSPOT_JNI_CALLSTATICINTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1916                         HOTSPOT_JNI_CALLSTATICINTMETHODV_RETURN(_ret_ref));
1917 DEFINE_CALLSTATICMETHODV(jlong,    Long,    T_LONG
1918                         , HOTSPOT_JNI_CALLSTATICLONGMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1919                         HOTSPOT_JNI_CALLSTATICLONGMETHODV_RETURN(_ret_ref));
1920 // Float and double probes don't return value because dtrace doesn't currently support it
1921 DEFINE_CALLSTATICMETHODV(jfloat,   Float,   T_FLOAT
1922                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1923                         HOTSPOT_JNI_CALLSTATICFLOATMETHODV_RETURN());
1924 DEFINE_CALLSTATICMETHODV(jdouble,  Double,  T_DOUBLE
1925                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1926                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_RETURN());
1927 
1928 #define DEFINE_CALLSTATICMETHODA(ResultType, Result, Tag \
1929                                 , EntryProbe, ResultProbe) \
1930 \
1931   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodA, ResultType \
1932                           , ResultProbe);                               \
1933 \
1934 JNI_ENTRY(ResultType, \
1935           jni_CallStatic##Result##MethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args)) \
1936   JNIWrapper("CallStatic" XSTR(Result) "MethodA"); \
1937 \
1938   EntryProbe; \
1939   ResultType ret = 0;\
1940   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodA, ResultType, \
1941                      (const ResultType&amp;)ret);\
1942 \
1943   JavaValue jvalue(Tag); \
1944   JNI_ArgumentPusherArray ap(methodID, args); \
1945   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1946   ret = jvalue.get_##ResultType(); \
1947   return ret;\
1948 JNI_END
1949 
1950 // the runtime type of subword integral basic types is integer
1951 DEFINE_CALLSTATICMETHODA(jboolean, Boolean, T_BOOLEAN
1952                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1953                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_RETURN(_ret_ref));
1954 DEFINE_CALLSTATICMETHODA(jbyte,    Byte,    T_BYTE
1955                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1956                         HOTSPOT_JNI_CALLSTATICBYTEMETHODA_RETURN(_ret_ref));
1957 DEFINE_CALLSTATICMETHODA(jchar,    Char,    T_CHAR
1958                         , HOTSPOT_JNI_CALLSTATICCHARMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1959                         HOTSPOT_JNI_CALLSTATICCHARMETHODA_RETURN(_ret_ref));
1960 DEFINE_CALLSTATICMETHODA(jshort,   Short,   T_SHORT
1961                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1962                         HOTSPOT_JNI_CALLSTATICSHORTMETHODA_RETURN(_ret_ref));
1963 
1964 DEFINE_CALLSTATICMETHODA(jobject,  Object,  T_OBJECT
1965                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1966                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_RETURN(_ret_ref));
1967 DEFINE_CALLSTATICMETHODA(jint,     Int,     T_INT
1968                         , HOTSPOT_JNI_CALLSTATICINTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1969                         HOTSPOT_JNI_CALLSTATICINTMETHODA_RETURN(_ret_ref));
1970 DEFINE_CALLSTATICMETHODA(jlong,    Long,    T_LONG
1971                         , HOTSPOT_JNI_CALLSTATICLONGMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1972                         HOTSPOT_JNI_CALLSTATICLONGMETHODA_RETURN(_ret_ref));
1973 // Float and double probes don't return value because dtrace doesn't currently support it
1974 DEFINE_CALLSTATICMETHODA(jfloat,   Float,   T_FLOAT
1975                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1976                         HOTSPOT_JNI_CALLSTATICFLOATMETHODA_RETURN());
1977 DEFINE_CALLSTATICMETHODA(jdouble,  Double,  T_DOUBLE
1978                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1979                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_RETURN());
1980 
1981 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethod
1982                          , HOTSPOT_JNI_CALLSTATICVOIDMETHOD_RETURN());
1983 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodV
1984                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODV_RETURN());
1985 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodA
1986                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODA_RETURN());
1987 
1988 JNI_ENTRY(void, jni_CallStaticVoidMethod(JNIEnv *env, jclass cls, jmethodID methodID, ...))
1989   JNIWrapper("CallStaticVoidMethod");
1990   HOTSPOT_JNI_CALLSTATICVOIDMETHOD_ENTRY(env, cls, (uintptr_t) methodID);
1991   DT_VOID_RETURN_MARK(CallStaticVoidMethod);
1992 
1993   va_list args;
1994   va_start(args, methodID);
1995   JavaValue jvalue(T_VOID);
1996   JNI_ArgumentPusherVaArg ap(methodID, args);
1997   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1998   va_end(args);
1999 JNI_END
2000 
2001 
2002 JNI_ENTRY(void, jni_CallStaticVoidMethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args))
2003   JNIWrapper("CallStaticVoidMethodV");
2004   HOTSPOT_JNI_CALLSTATICVOIDMETHODV_ENTRY(env, cls, (uintptr_t) methodID);
2005   DT_VOID_RETURN_MARK(CallStaticVoidMethodV);
2006 
2007   JavaValue jvalue(T_VOID);
2008   JNI_ArgumentPusherVaArg ap(methodID, args);
2009   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
2010 JNI_END
2011 
2012 
2013 JNI_ENTRY(void, jni_CallStaticVoidMethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args))
2014   JNIWrapper("CallStaticVoidMethodA");
2015   HOTSPOT_JNI_CALLSTATICVOIDMETHODA_ENTRY(env, cls, (uintptr_t) methodID);
2016   DT_VOID_RETURN_MARK(CallStaticVoidMethodA);
2017 
2018   JavaValue jvalue(T_VOID);
2019   JNI_ArgumentPusherArray ap(methodID, args);
2020   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
2021 JNI_END
2022 
2023 
2024 //
2025 // Accessing Fields
2026 //
2027 
2028 
2029 DT_RETURN_MARK_DECL(GetFieldID, jfieldID
2030                     , HOTSPOT_JNI_GETFIELDID_RETURN((uintptr_t)_ret_ref));
2031 
2032 JNI_ENTRY(jfieldID, jni_GetFieldID(JNIEnv *env, jclass clazz,
2033           const char *name, const char *sig))
2034   JNIWrapper("GetFieldID");
2035   HOTSPOT_JNI_GETFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
2036   jfieldID ret = 0;
2037   DT_RETURN_MARK(GetFieldID, jfieldID, (const jfieldID&amp;)ret);
2038 
2039   // The class should have been loaded (we have an instance of the class
2040   // passed in) so the field and signature should already be in the symbol
2041   // table.  If they're not there, the field doesn't exist.
2042   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
2043   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
2044   if (fieldname == NULL || signame == NULL) {
2045     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2046   }
2047   KlassHandle k(THREAD,
2048                 java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
2049   // Make sure class is initialized before handing id's out to fields
2050   k()-&gt;initialize(CHECK_NULL);
2051 
2052   fieldDescriptor fd;
2053   if (!k()-&gt;oop_is_instance() ||
2054       !InstanceKlass::cast(k())-&gt;find_field(fieldname, signame, false, &amp;fd)) {
2055     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2056   }
2057 
2058   // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
2059   // It may also have hash bits for k, if VerifyJNIFields is turned on.
2060   ret = jfieldIDWorkaround::to_instance_jfieldID(k(), fd.offset());
2061   return ret;
2062 JNI_END
2063 
2064 
2065 JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
2066   JNIWrapper("GetObjectField");
2067   HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
2068   oop o = JNIHandles::resolve_non_null(obj);
2069   Klass* k = o-&gt;klass();
2070   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2071   // Keep JVMTI addition small and only check enabled flag here.
2072   // jni_GetField_probe() assumes that is okay to create handles.
2073   if (JvmtiExport::should_post_field_access()) {
2074     o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
2075   }
2076   jobject ret = JNIHandles::make_local(env, o-&gt;obj_field(offset));
2077 #if INCLUDE_ALL_GCS
2078   // If G1 is enabled and we are accessing the value of the referent
2079   // field in a reference object then we need to register a non-null
2080   // referent with the SATB barrier.
2081   if (UseG1GC) {
2082     bool needs_barrier = false;
2083 
2084     if (ret != NULL &amp;&amp;
2085         offset == java_lang_ref_Reference::referent_offset &amp;&amp;
2086         InstanceKlass::cast(k)-&gt;reference_type() != REF_NONE) {
2087       assert(InstanceKlass::cast(k)-&gt;is_subclass_of(SystemDictionary::Reference_klass()), "sanity");
2088       needs_barrier = true;
2089     }
2090 
2091     if (needs_barrier) {
2092       oop referent = JNIHandles::resolve(ret);
2093       G1SATBCardTableModRefBS::enqueue(referent);
2094     }
2095   }
2096 #endif // INCLUDE_ALL_GCS
2097 HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
2098   return ret;
2099 JNI_END
2100 
2101 
2102 
2103 #define DEFINE_GETFIELD(Return,Fieldname,Result \
2104   , EntryProbe, ReturnProbe) \
2105 \
2106   DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
2107   , ReturnProbe); \
2108 \
2109 JNI_QUICK_ENTRY(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \
2110   JNIWrapper("Get" XSTR(Result) "Field"); \
2111 \
2112   EntryProbe; \
2113   Return ret = 0;\
2114   DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&amp;)ret);\
2115 \
2116   oop o = JNIHandles::resolve_non_null(obj); \
2117   Klass* k = o-&gt;klass(); \
2118   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2119   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2120   /* jni_GetField_probe_nh() assumes that is not okay to create handles */ \
2121   /* and creates a ResetNoHandleMark.                                   */ \
2122   if (JvmtiExport::should_post_field_access()) { \
2123     o = JvmtiExport::jni_GetField_probe_nh(thread, obj, o, k, fieldID, false); \
2124   } \
2125   ret = o-&gt;Fieldname##_field(offset); \
2126   return ret; \
2127 JNI_END
2128 
2129 DEFINE_GETFIELD(jboolean, bool,   Boolean
2130                 , HOTSPOT_JNI_GETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2131                 HOTSPOT_JNI_GETBOOLEANFIELD_RETURN(_ret_ref))
2132 DEFINE_GETFIELD(jbyte,    byte,   Byte
2133                 , HOTSPOT_JNI_GETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2134                 HOTSPOT_JNI_GETBYTEFIELD_RETURN(_ret_ref))
2135 DEFINE_GETFIELD(jchar,    char,   Char
2136                 , HOTSPOT_JNI_GETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2137                 HOTSPOT_JNI_GETCHARFIELD_RETURN(_ret_ref))
2138 DEFINE_GETFIELD(jshort,   short,  Short
2139                 , HOTSPOT_JNI_GETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2140                 HOTSPOT_JNI_GETSHORTFIELD_RETURN(_ret_ref))
2141 DEFINE_GETFIELD(jint,     int,    Int
2142                 , HOTSPOT_JNI_GETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2143                 HOTSPOT_JNI_GETINTFIELD_RETURN(_ret_ref))
2144 DEFINE_GETFIELD(jlong,    long,   Long
2145                 , HOTSPOT_JNI_GETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2146                 HOTSPOT_JNI_GETLONGFIELD_RETURN(_ret_ref))
2147 // Float and double probes don't return value because dtrace doesn't currently support it
2148 DEFINE_GETFIELD(jfloat,   float,  Float
2149                 , HOTSPOT_JNI_GETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2150                 HOTSPOT_JNI_GETFLOATFIELD_RETURN())
2151 DEFINE_GETFIELD(jdouble,  double, Double
2152                 , HOTSPOT_JNI_GETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2153                 HOTSPOT_JNI_GETDOUBLEFIELD_RETURN())
2154 
2155 address jni_GetBooleanField_addr() {
2156   return (address)jni_GetBooleanField;
2157 }
2158 address jni_GetByteField_addr() {
2159   return (address)jni_GetByteField;
2160 }
2161 address jni_GetCharField_addr() {
2162   return (address)jni_GetCharField;
2163 }
2164 address jni_GetShortField_addr() {
2165   return (address)jni_GetShortField;
2166 }
2167 address jni_GetIntField_addr() {
2168   return (address)jni_GetIntField;
2169 }
2170 address jni_GetLongField_addr() {
2171   return (address)jni_GetLongField;
2172 }
2173 address jni_GetFloatField_addr() {
2174   return (address)jni_GetFloatField;
2175 }
2176 address jni_GetDoubleField_addr() {
2177   return (address)jni_GetDoubleField;
2178 }
2179 
2180 JNI_QUICK_ENTRY(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))
2181   JNIWrapper("SetObjectField");
2182   HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID, value);
2183   oop o = JNIHandles::resolve_non_null(obj);
2184   Klass* k = o-&gt;klass();
2185   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2186   // Keep JVMTI addition small and only check enabled flag here.
2187   // jni_SetField_probe_nh() assumes that is not okay to create handles
2188   // and creates a ResetNoHandleMark.
2189   if (JvmtiExport::should_post_field_modification()) {
2190     jvalue field_value;
2191     field_value.l = value;
2192     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, 'L', (jvalue *)&amp;field_value);
2193   }
2194   o-&gt;obj_field_put(offset, JNIHandles::resolve(value));
2195   HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
2196 JNI_END
2197 
2198 
2199 #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
2200                         , EntryProbe, ReturnProbe) \
2201 \
2202 JNI_QUICK_ENTRY(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \
2203   JNIWrapper("Set" XSTR(Result) "Field"); \
2204 \
2205   EntryProbe; \
2206 \
2207   oop o = JNIHandles::resolve_non_null(obj); \
2208   Klass* k = o-&gt;klass(); \
2209   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2210   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2211   /* jni_SetField_probe_nh() assumes that is not okay to create handles */ \
2212   /* and creates a ResetNoHandleMark.                                   */ \
2213   if (JvmtiExport::should_post_field_modification()) { \
2214     jvalue field_value; \
2215     field_value.unionType = value; \
2216     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&amp;field_value); \
2217   } \
2218   o-&gt;Fieldname##_field_put(offset, value); \
2219   ReturnProbe; \
2220 JNI_END
2221 
2222 DEFINE_SETFIELD(jboolean, bool,   Boolean, 'Z', z
2223                 , HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2224                 HOTSPOT_JNI_SETBOOLEANFIELD_RETURN())
2225 DEFINE_SETFIELD(jbyte,    byte,   Byte,    'B', b
2226                 , HOTSPOT_JNI_SETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2227                 HOTSPOT_JNI_SETBYTEFIELD_RETURN())
2228 DEFINE_SETFIELD(jchar,    char,   Char,    'C', c
2229                 , HOTSPOT_JNI_SETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2230                 HOTSPOT_JNI_SETCHARFIELD_RETURN())
2231 DEFINE_SETFIELD(jshort,   short,  Short,   'S', s
2232                 , HOTSPOT_JNI_SETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2233                 HOTSPOT_JNI_SETSHORTFIELD_RETURN())
2234 DEFINE_SETFIELD(jint,     int,    Int,     'I', i
2235                 , HOTSPOT_JNI_SETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2236                 HOTSPOT_JNI_SETINTFIELD_RETURN())
2237 DEFINE_SETFIELD(jlong,    long,   Long,    'J', j
2238                 , HOTSPOT_JNI_SETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2239                 HOTSPOT_JNI_SETLONGFIELD_RETURN())
2240 // Float and double probes don't return value because dtrace doesn't currently support it
2241 DEFINE_SETFIELD(jfloat,   float,  Float,   'F', f
2242                 , HOTSPOT_JNI_SETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2243                 HOTSPOT_JNI_SETFLOATFIELD_RETURN())
2244 DEFINE_SETFIELD(jdouble,  double, Double,  'D', d
2245                 , HOTSPOT_JNI_SETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2246                 HOTSPOT_JNI_SETDOUBLEFIELD_RETURN())
2247 
2248 DT_RETURN_MARK_DECL(ToReflectedField, jobject
2249                     , HOTSPOT_JNI_TOREFLECTEDFIELD_RETURN(_ret_ref));
2250 
2251 JNI_ENTRY(jobject, jni_ToReflectedField(JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic))
2252   JNIWrapper("ToReflectedField");
2253   HOTSPOT_JNI_TOREFLECTEDFIELD_ENTRY(env, cls, (uintptr_t) fieldID, isStatic);
2254   jobject ret = NULL;
2255   DT_RETURN_MARK(ToReflectedField, jobject, (const jobject&amp;)ret);
2256 
2257   fieldDescriptor fd;
2258   bool found = false;
2259   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2260 
2261   assert(jfieldIDWorkaround::is_static_jfieldID(fieldID) == (isStatic != 0), "invalid fieldID");
2262 
2263   if (isStatic) {
2264     // Static field. The fieldID a JNIid specifying the field holder and the offset within the Klass*.
2265     JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2266     assert(id-&gt;is_static_field_id(), "invalid static field id");
2267     found = id-&gt;find_local_field(&amp;fd);
2268   } else {
2269     // Non-static field. The fieldID is really the offset of the field within the instanceOop.
2270     int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2271     found = InstanceKlass::cast(k)-&gt;find_field_from_offset(offset, false, &amp;fd);
2272   }
2273   assert(found, "bad fieldID passed into jni_ToReflectedField");
2274   oop reflected = Reflection::new_field(&amp;fd, UseNewReflection, CHECK_NULL);
2275   ret = JNIHandles::make_local(env, reflected);
2276   return ret;
2277 JNI_END
2278 
2279 
2280 //
2281 // Accessing Static Fields
2282 //
2283 DT_RETURN_MARK_DECL(GetStaticFieldID, jfieldID
2284                     , HOTSPOT_JNI_GETSTATICFIELDID_RETURN((uintptr_t)_ret_ref));
2285 
2286 JNI_ENTRY(jfieldID, jni_GetStaticFieldID(JNIEnv *env, jclass clazz,
2287           const char *name, const char *sig))
2288   JNIWrapper("GetStaticFieldID");
2289   HOTSPOT_JNI_GETSTATICFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
2290   jfieldID ret = NULL;
2291   DT_RETURN_MARK(GetStaticFieldID, jfieldID, (const jfieldID&amp;)ret);
2292 
2293   // The class should have been loaded (we have an instance of the class
2294   // passed in) so the field and signature should already be in the symbol
2295   // table.  If they're not there, the field doesn't exist.
2296   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
2297   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
2298   if (fieldname == NULL || signame == NULL) {
2299     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2300   }
2301   KlassHandle k(THREAD,
2302                 java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
2303   // Make sure class is initialized before handing id's out to static fields
2304   k()-&gt;initialize(CHECK_NULL);
2305 
2306   fieldDescriptor fd;
2307   if (!k()-&gt;oop_is_instance() ||
2308       !InstanceKlass::cast(k())-&gt;find_field(fieldname, signame, true, &amp;fd)) {
2309     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2310   }
2311 
2312   // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
2313   JNIid* id = fd.field_holder()-&gt;jni_id_for(fd.offset());
2314   debug_only(id-&gt;set_is_static_field_id();)
2315 
2316   debug_only(id-&gt;verify(fd.field_holder()));
2317 
2318   ret = jfieldIDWorkaround::to_static_jfieldID(id);
2319   return ret;
2320 JNI_END
2321 
2322 
2323 JNI_ENTRY(jobject, jni_GetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID))
2324   JNIWrapper("GetStaticObjectField");
2325   HOTSPOT_JNI_GETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID);
2326 #if INCLUDE_JNI_CHECK
2327   DEBUG_ONLY(Klass* param_k = jniCheck::validate_class(thread, clazz);)
2328 #endif // INCLUDE_JNI_CHECK
2329   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2330   assert(id-&gt;is_static_field_id(), "invalid static field id");
2331   // Keep JVMTI addition small and only check enabled flag here.
2332   // jni_GetField_probe() assumes that is okay to create handles.
2333   if (JvmtiExport::should_post_field_access()) {
2334     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true);
2335   }
2336   jobject ret = JNIHandles::make_local(id-&gt;holder()-&gt;java_mirror()-&gt;obj_field(id-&gt;offset()));
2337   HOTSPOT_JNI_GETSTATICOBJECTFIELD_RETURN(ret);
2338   return ret;
2339 JNI_END
2340 
2341 
2342 #define DEFINE_GETSTATICFIELD(Return,Fieldname,Result \
2343                               , EntryProbe, ReturnProbe) \
2344 \
2345   DT_RETURN_MARK_DECL_FOR(Result, GetStatic##Result##Field, Return \
2346                           , ReturnProbe);                                          \
2347 \
2348 JNI_ENTRY(Return, jni_GetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID)) \
2349   JNIWrapper("GetStatic" XSTR(Result) "Field"); \
2350   EntryProbe; \
2351   Return ret = 0;\
2352   DT_RETURN_MARK_FOR(Result, GetStatic##Result##Field, Return, \
2353                      (const Return&amp;)ret);\
2354   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2355   assert(id-&gt;is_static_field_id(), "invalid static field id"); \
2356   /* Keep JVMTI addition small and only check enabled flag here. */ \
2357   /* jni_GetField_probe() assumes that is okay to create handles. */ \
2358   if (JvmtiExport::should_post_field_access()) { \
2359     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true); \
2360   } \
2361   ret = id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field (id-&gt;offset()); \
2362   return ret;\
2363 JNI_END
2364 
2365 DEFINE_GETSTATICFIELD(jboolean, bool,   Boolean
2366                       , HOTSPOT_JNI_GETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t) fieldID), HOTSPOT_JNI_GETSTATICBOOLEANFIELD_RETURN(_ret_ref))
2367 DEFINE_GETSTATICFIELD(jbyte,    byte,   Byte
2368                       , HOTSPOT_JNI_GETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICBYTEFIELD_RETURN(_ret_ref)   )
2369 DEFINE_GETSTATICFIELD(jchar,    char,   Char
2370                       , HOTSPOT_JNI_GETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICCHARFIELD_RETURN(_ret_ref)   )
2371 DEFINE_GETSTATICFIELD(jshort,   short,  Short
2372                       , HOTSPOT_JNI_GETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICSHORTFIELD_RETURN(_ret_ref)  )
2373 DEFINE_GETSTATICFIELD(jint,     int,    Int
2374                       , HOTSPOT_JNI_GETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),     HOTSPOT_JNI_GETSTATICINTFIELD_RETURN(_ret_ref)    )
2375 DEFINE_GETSTATICFIELD(jlong,    long,   Long
2376                       , HOTSPOT_JNI_GETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICLONGFIELD_RETURN(_ret_ref)   )
2377 // Float and double probes don't return value because dtrace doesn't currently support it
2378 DEFINE_GETSTATICFIELD(jfloat,   float,  Float
2379                       , HOTSPOT_JNI_GETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICFLOATFIELD_RETURN()          )
2380 DEFINE_GETSTATICFIELD(jdouble,  double, Double
2381                       , HOTSPOT_JNI_GETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),  HOTSPOT_JNI_GETSTATICDOUBLEFIELD_RETURN()         )
2382 
2383 JNI_ENTRY(void, jni_SetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value))
2384   JNIWrapper("SetStaticObjectField");
2385  HOTSPOT_JNI_SETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value);
2386   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2387   assert(id-&gt;is_static_field_id(), "invalid static field id");
2388   // Keep JVMTI addition small and only check enabled flag here.
2389   // jni_SetField_probe() assumes that is okay to create handles.
2390   if (JvmtiExport::should_post_field_modification()) {
2391     jvalue field_value;
2392     field_value.l = value;
2393     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, 'L', (jvalue *)&amp;field_value);
2394   }
2395   id-&gt;holder()-&gt;java_mirror()-&gt;obj_field_put(id-&gt;offset(), JNIHandles::resolve(value));
2396   HOTSPOT_JNI_SETSTATICOBJECTFIELD_RETURN();
2397 JNI_END
2398 
2399 
2400 
2401 #define DEFINE_SETSTATICFIELD(Argument,Fieldname,Result,SigType,unionType \
2402                               , EntryProbe, ReturnProbe) \
2403 \
2404 JNI_ENTRY(void, jni_SetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID, Argument value)) \
2405   JNIWrapper("SetStatic" XSTR(Result) "Field"); \
2406   EntryProbe; \
2407 \
2408   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2409   assert(id-&gt;is_static_field_id(), "invalid static field id"); \
2410   /* Keep JVMTI addition small and only check enabled flag here. */ \
2411   /* jni_SetField_probe() assumes that is okay to create handles. */ \
2412   if (JvmtiExport::should_post_field_modification()) { \
2413     jvalue field_value; \
2414     field_value.unionType = value; \
2415     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, SigType, (jvalue *)&amp;field_value); \
2416   } \
2417   id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field_put (id-&gt;offset(), value); \
2418   ReturnProbe;\
2419 JNI_END
2420 
2421 DEFINE_SETSTATICFIELD(jboolean, bool,   Boolean, 'Z', z
2422                       , HOTSPOT_JNI_SETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
2423                       HOTSPOT_JNI_SETSTATICBOOLEANFIELD_RETURN())
2424 DEFINE_SETSTATICFIELD(jbyte,    byte,   Byte,    'B', b
2425                       , HOTSPOT_JNI_SETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2426                       HOTSPOT_JNI_SETSTATICBYTEFIELD_RETURN())
2427 DEFINE_SETSTATICFIELD(jchar,    char,   Char,    'C', c
2428                       , HOTSPOT_JNI_SETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2429                       HOTSPOT_JNI_SETSTATICCHARFIELD_RETURN())
2430 DEFINE_SETSTATICFIELD(jshort,   short,  Short,   'S', s
2431                       , HOTSPOT_JNI_SETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2432                       HOTSPOT_JNI_SETSTATICSHORTFIELD_RETURN())
2433 DEFINE_SETSTATICFIELD(jint,     int,    Int,     'I', i
2434                       , HOTSPOT_JNI_SETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2435                       HOTSPOT_JNI_SETSTATICINTFIELD_RETURN())
2436 DEFINE_SETSTATICFIELD(jlong,    long,   Long,    'J', j
2437                       , HOTSPOT_JNI_SETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2438                       HOTSPOT_JNI_SETSTATICLONGFIELD_RETURN())
2439 // Float and double probes don't return value because dtrace doesn't currently support it
2440 DEFINE_SETSTATICFIELD(jfloat,   float,  Float,   'F', f
2441                       , HOTSPOT_JNI_SETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2442                       HOTSPOT_JNI_SETSTATICFLOATFIELD_RETURN())
2443 DEFINE_SETSTATICFIELD(jdouble,  double, Double,  'D', d
2444                       , HOTSPOT_JNI_SETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2445                       HOTSPOT_JNI_SETSTATICDOUBLEFIELD_RETURN())
2446 
2447 //
2448 // String Operations
2449 //
2450 
2451 // Unicode Interface
2452 
2453 DT_RETURN_MARK_DECL(NewString, jstring
2454                     , HOTSPOT_JNI_NEWSTRING_RETURN(_ret_ref));
2455 
2456 JNI_ENTRY(jstring, jni_NewString(JNIEnv *env, const jchar *unicodeChars, jsize len))
2457   JNIWrapper("NewString");
2458  HOTSPOT_JNI_NEWSTRING_ENTRY(env, (uint16_t *) unicodeChars, len);
2459   jstring ret = NULL;
2460   DT_RETURN_MARK(NewString, jstring, (const jstring&amp;)ret);
2461   oop string=java_lang_String::create_oop_from_unicode((jchar*) unicodeChars, len, CHECK_NULL);
2462   ret = (jstring) JNIHandles::make_local(env, string);
2463   return ret;
2464 JNI_END
2465 
2466 
2467 JNI_QUICK_ENTRY(jsize, jni_GetStringLength(JNIEnv *env, jstring string))
2468   JNIWrapper("GetStringLength");
2469   HOTSPOT_JNI_GETSTRINGLENGTH_ENTRY(env, string);
2470   jsize ret = 0;
2471   oop s = JNIHandles::resolve_non_null(string);
2472   if (java_lang_String::value(s) != NULL) {
2473     ret = java_lang_String::length(s);
2474   }
2475  HOTSPOT_JNI_GETSTRINGLENGTH_RETURN(ret);
2476   return ret;
2477 JNI_END
2478 
2479 
2480 JNI_QUICK_ENTRY(const jchar*, jni_GetStringChars(
2481   JNIEnv *env, jstring string, jboolean *isCopy))
2482   JNIWrapper("GetStringChars");
2483  HOTSPOT_JNI_GETSTRINGCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2484   jchar* buf = NULL;
2485   oop s = JNIHandles::resolve_non_null(string);
2486   typeArrayOop s_value = java_lang_String::value(s);
2487   if (s_value != NULL) {
2488     int s_len = java_lang_String::length(s);
2489     int s_offset = java_lang_String::offset(s);
2490     buf = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
2491     /* JNI Specification states return NULL on OOM */
2492     if (buf != NULL) {
2493       if (s_len &gt; 0) {
2494         memcpy(buf, s_value-&gt;char_at_addr(s_offset), sizeof(jchar)*s_len);
2495       }
2496       buf[s_len] = 0;
2497       //%note jni_5
2498       if (isCopy != NULL) {
2499         *isCopy = JNI_TRUE;
2500       }
2501     }
2502   }
2503   HOTSPOT_JNI_GETSTRINGCHARS_RETURN(buf);
2504   return buf;
2505 JNI_END
2506 
2507 
2508 JNI_QUICK_ENTRY(void, jni_ReleaseStringChars(JNIEnv *env, jstring str, const jchar *chars))
2509   JNIWrapper("ReleaseStringChars");
2510   HOTSPOT_JNI_RELEASESTRINGCHARS_ENTRY(env, str, (uint16_t *) chars);
2511   //%note jni_6
2512   if (chars != NULL) {
2513     // Since String objects are supposed to be immutable, don't copy any
2514     // new data back.  A bad user will have to go after the char array.
2515     FreeHeap((void*) chars);
2516   }
2517   HOTSPOT_JNI_RELEASESTRINGCHARS_RETURN();
2518 JNI_END
2519 
2520 
2521 // UTF Interface
2522 
2523 DT_RETURN_MARK_DECL(NewStringUTF, jstring
2524                     , HOTSPOT_JNI_NEWSTRINGUTF_RETURN(_ret_ref));
2525 
2526 JNI_ENTRY(jstring, jni_NewStringUTF(JNIEnv *env, const char *bytes))
2527   JNIWrapper("NewStringUTF");
2528   HOTSPOT_JNI_NEWSTRINGUTF_ENTRY(env, (char *) bytes);
2529   jstring ret;
2530   DT_RETURN_MARK(NewStringUTF, jstring, (const jstring&amp;)ret);
2531 
2532   oop result = java_lang_String::create_oop_from_str((char*) bytes, CHECK_NULL);
2533   ret = (jstring) JNIHandles::make_local(env, result);
2534   return ret;
2535 JNI_END
2536 
2537 
2538 JNI_ENTRY(jsize, jni_GetStringUTFLength(JNIEnv *env, jstring string))
2539   JNIWrapper("GetStringUTFLength");
2540  HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(env, string);
2541   jsize ret = 0;
2542   oop java_string = JNIHandles::resolve_non_null(string);
2543   if (java_lang_String::value(java_string) != NULL) {
2544     ret = java_lang_String::utf8_length(java_string);
2545   }
2546   HOTSPOT_JNI_GETSTRINGUTFLENGTH_RETURN(ret);
2547   return ret;
2548 JNI_END
2549 
2550 
2551 JNI_ENTRY(const char*, jni_GetStringUTFChars(JNIEnv *env, jstring string, jboolean *isCopy))
2552   JNIWrapper("GetStringUTFChars");
2553  HOTSPOT_JNI_GETSTRINGUTFCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2554   char* result = NULL;
2555   oop java_string = JNIHandles::resolve_non_null(string);
2556   if (java_lang_String::value(java_string) != NULL) {
2557     size_t length = java_lang_String::utf8_length(java_string);
2558     /* JNI Specification states return NULL on OOM */
2559     result = AllocateHeap(length + 1, mtInternal, 0, AllocFailStrategy::RETURN_NULL);
2560     if (result != NULL) {
2561       java_lang_String::as_utf8_string(java_string, result, (int) length + 1);
2562       if (isCopy != NULL) {
2563         *isCopy = JNI_TRUE;
2564       }
2565     }
2566   }
2567  HOTSPOT_JNI_GETSTRINGUTFCHARS_RETURN(result);
2568   return result;
2569 JNI_END
2570 
2571 
2572 JNI_LEAF(void, jni_ReleaseStringUTFChars(JNIEnv *env, jstring str, const char *chars))
2573   JNIWrapper("ReleaseStringUTFChars");
2574  HOTSPOT_JNI_RELEASESTRINGUTFCHARS_ENTRY(env, str, (char *) chars);
2575   if (chars != NULL) {
2576     FreeHeap((char*) chars);
2577   }
2578 HOTSPOT_JNI_RELEASESTRINGUTFCHARS_RETURN();
2579 JNI_END
2580 
2581 
2582 JNI_QUICK_ENTRY(jsize, jni_GetArrayLength(JNIEnv *env, jarray array))
2583   JNIWrapper("GetArrayLength");
2584  HOTSPOT_JNI_GETARRAYLENGTH_ENTRY(env, array);
2585   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
2586   assert(a-&gt;is_array(), "must be array");
2587   jsize ret = a-&gt;length();
2588  HOTSPOT_JNI_GETARRAYLENGTH_RETURN(ret);
2589   return ret;
2590 JNI_END
2591 
2592 
2593 //
2594 // Object Array Operations
2595 //
2596 
2597 DT_RETURN_MARK_DECL(NewObjectArray, jobjectArray
2598                     , HOTSPOT_JNI_NEWOBJECTARRAY_RETURN(_ret_ref));
2599 
2600 JNI_ENTRY(jobjectArray, jni_NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement))
2601   JNIWrapper("NewObjectArray");
2602  HOTSPOT_JNI_NEWOBJECTARRAY_ENTRY(env, length, elementClass, initialElement);
2603   jobjectArray ret = NULL;
2604   DT_RETURN_MARK(NewObjectArray, jobjectArray, (const jobjectArray&amp;)ret);
2605   KlassHandle ek(THREAD, java_lang_Class::as_Klass(JNIHandles::resolve_non_null(elementClass)));
2606   Klass* ako = ek()-&gt;array_klass(CHECK_NULL);
2607   KlassHandle ak = KlassHandle(THREAD, ako);
2608   ObjArrayKlass::cast(ak())-&gt;initialize(CHECK_NULL);
2609   objArrayOop result = ObjArrayKlass::cast(ak())-&gt;allocate(length, CHECK_NULL);
2610   oop initial_value = JNIHandles::resolve(initialElement);
2611   if (initial_value != NULL) {  // array already initialized with NULL
2612     for (int index = 0; index &lt; length; index++) {
2613       result-&gt;obj_at_put(index, initial_value);
2614     }
2615   }
2616   ret = (jobjectArray) JNIHandles::make_local(env, result);
2617   return ret;
2618 JNI_END
2619 
2620 DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject
2621                     , HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(_ret_ref));
2622 
2623 JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
2624   JNIWrapper("GetObjectArrayElement");
2625  HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
2626   jobject ret = NULL;
2627   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&amp;)ret);
2628   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2629   if (a-&gt;is_within_bounds(index)) {
2630     ret = JNIHandles::make_local(env, a-&gt;obj_at(index));
2631     return ret;
2632   } else {
2633     char buf[jintAsStringSize];
2634     sprintf(buf, "%d", index);
2635     THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), buf);
2636   }
2637 JNI_END
2638 
2639 DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
2640                          , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
2641 
2642 JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
2643   JNIWrapper("SetObjectArrayElement");
2644  HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);
2645   DT_VOID_RETURN_MARK(SetObjectArrayElement);
2646 
2647   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2648   oop v = JNIHandles::resolve(value);
2649   if (a-&gt;is_within_bounds(index)) {
2650     if (v == NULL || v-&gt;is_a(ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass())) {
2651       a-&gt;obj_at_put(index, v);
2652     } else {
2653       THROW(vmSymbols::java_lang_ArrayStoreException());
2654     }
2655   } else {
2656     char buf[jintAsStringSize];
2657     sprintf(buf, "%d", index);
2658     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), buf);
2659   }
2660 JNI_END
2661 
2662 
2663 
2664 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
2665                               ,EntryProbe,ReturnProbe)  \
2666 \
2667   DT_RETURN_MARK_DECL(New##Result##Array, Return \
2668                       , ReturnProbe); \
2669 \
2670 JNI_ENTRY(Return, \
2671           jni_New##Result##Array(JNIEnv *env, jsize len)) \
2672   JNIWrapper("New" XSTR(Result) "Array"); \
2673   EntryProbe; \
2674   Return ret = NULL;\
2675   DT_RETURN_MARK(New##Result##Array, Return, (const Return&amp;)ret);\
2676 \
2677   oop obj= oopFactory::Allocator(len, CHECK_0); \
2678   ret = (Return) JNIHandles::make_local(env, obj); \
2679   return ret;\
2680 JNI_END
2681 
2682 DEFINE_NEWSCALARARRAY(jbooleanArray, new_boolArray,   Boolean,
2683                       HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY(env, len),
2684                       HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN(_ret_ref))
2685 DEFINE_NEWSCALARARRAY(jbyteArray,    new_byteArray,   Byte,
2686                       HOTSPOT_JNI_NEWBYTEARRAY_ENTRY(env, len),
2687                       HOTSPOT_JNI_NEWBYTEARRAY_RETURN(_ret_ref))
2688 DEFINE_NEWSCALARARRAY(jshortArray,   new_shortArray,  Short,
2689                       HOTSPOT_JNI_NEWSHORTARRAY_ENTRY(env, len),
2690                       HOTSPOT_JNI_NEWSHORTARRAY_RETURN(_ret_ref))
2691 DEFINE_NEWSCALARARRAY(jcharArray,    new_charArray,   Char,
2692                       HOTSPOT_JNI_NEWCHARARRAY_ENTRY(env, len),
2693                       HOTSPOT_JNI_NEWCHARARRAY_RETURN(_ret_ref))
2694 DEFINE_NEWSCALARARRAY(jintArray,     new_intArray,    Int,
2695                       HOTSPOT_JNI_NEWINTARRAY_ENTRY(env, len),
2696                       HOTSPOT_JNI_NEWINTARRAY_RETURN(_ret_ref))
2697 DEFINE_NEWSCALARARRAY(jlongArray,    new_longArray,   Long,
2698                       HOTSPOT_JNI_NEWLONGARRAY_ENTRY(env, len),
2699                       HOTSPOT_JNI_NEWLONGARRAY_RETURN(_ret_ref))
2700 DEFINE_NEWSCALARARRAY(jfloatArray,   new_singleArray, Float,
2701                       HOTSPOT_JNI_NEWFLOATARRAY_ENTRY(env, len),
2702                       HOTSPOT_JNI_NEWFLOATARRAY_RETURN(_ret_ref))
2703 DEFINE_NEWSCALARARRAY(jdoubleArray,  new_doubleArray, Double,
2704                       HOTSPOT_JNI_NEWDOUBLEARRAY_ENTRY(env, len),
2705                       HOTSPOT_JNI_NEWDOUBLEARRAY_RETURN(_ret_ref))
2706 
2707 // Return an address which will fault if the caller writes to it.
2708 
2709 static char* get_bad_address() {
2710   static char* bad_address = NULL;
2711   if (bad_address == NULL) {
2712     size_t size = os::vm_allocation_granularity();
2713     bad_address = os::reserve_memory(size);
2714     if (bad_address != NULL) {
2715       os::protect_memory(bad_address, size, os::MEM_PROT_READ,
2716                          /*is_committed*/false);
2717     }
2718   }
2719   return bad_address;
2720 }
2721 
2722 
2723 
2724 #define DEFINE_GETSCALARARRAYELEMENTS(ElementTag,ElementType,Result, Tag \
2725                                       , EntryProbe, ReturnProbe) \
2726 \
2727 JNI_QUICK_ENTRY(ElementType*, \
2728           jni_Get##Result##ArrayElements(JNIEnv *env, ElementType##Array array, jboolean *isCopy)) \
2729   JNIWrapper("Get" XSTR(Result) "ArrayElements"); \
2730   EntryProbe; \
2731   /* allocate an chunk of memory in c land */ \
2732   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2733   ElementType* result; \
2734   int len = a-&gt;length(); \
2735   if (len == 0) { \
2736     /* Empty array: legal but useless, can't return NULL. \
2737      * Return a pointer to something useless. \
2738      * Avoid asserts in typeArrayOop. */ \
2739     result = (ElementType*)get_bad_address(); \
2740   } else { \
2741     /* JNI Specification states return NULL on OOM */                    \
2742     result = NEW_C_HEAP_ARRAY_RETURN_NULL(ElementType, len, mtInternal); \
2743     if (result != NULL) {                                                \
2744       /* copy the array to the c chunk */                                \
2745       memcpy(result, a-&gt;Tag##_at_addr(0), sizeof(ElementType)*len);      \
2746       if (isCopy) {                                                      \
2747         *isCopy = JNI_TRUE;                                              \
2748       }                                                                  \
2749     }                                                                    \
2750   } \
2751   ReturnProbe; \
2752   return result; \
2753 JNI_END
2754 
2755 DEFINE_GETSCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2756                               , HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2757                               HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_RETURN((uintptr_t*)result))
2758 DEFINE_GETSCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2759                               , HOTSPOT_JNI_GETBYTEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2760                               HOTSPOT_JNI_GETBYTEARRAYELEMENTS_RETURN((char*)result))
2761 DEFINE_GETSCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2762                               , HOTSPOT_JNI_GETSHORTARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2763                               HOTSPOT_JNI_GETSHORTARRAYELEMENTS_RETURN((uint16_t*)result))
2764 DEFINE_GETSCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2765                               , HOTSPOT_JNI_GETCHARARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2766                               HOTSPOT_JNI_GETCHARARRAYELEMENTS_RETURN(result))
2767 DEFINE_GETSCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2768                               , HOTSPOT_JNI_GETINTARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2769                               HOTSPOT_JNI_GETINTARRAYELEMENTS_RETURN((uint32_t*)result))
2770 DEFINE_GETSCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2771                               , HOTSPOT_JNI_GETLONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2772                               HOTSPOT_JNI_GETLONGARRAYELEMENTS_RETURN(((uintptr_t*)result)))
2773 // Float and double probes don't return value because dtrace doesn't currently support it
2774 DEFINE_GETSCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2775                               , HOTSPOT_JNI_GETFLOATARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2776                               HOTSPOT_JNI_GETFLOATARRAYELEMENTS_RETURN(result))
2777 DEFINE_GETSCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2778                               , HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2779                               HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_RETURN(result))
2780 
2781 
2782 #define DEFINE_RELEASESCALARARRAYELEMENTS(ElementTag,ElementType,Result,Tag \
2783                                           , EntryProbe, ReturnProbe);\
2784 \
2785 JNI_QUICK_ENTRY(void, \
2786           jni_Release##Result##ArrayElements(JNIEnv *env, ElementType##Array array, \
2787                                              ElementType *buf, jint mode)) \
2788   JNIWrapper("Release" XSTR(Result) "ArrayElements"); \
2789   EntryProbe; \
2790   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2791   int len = a-&gt;length(); \
2792   if (len != 0) {   /* Empty array:  nothing to free or copy. */  \
2793     if ((mode == 0) || (mode == JNI_COMMIT)) { \
2794       memcpy(a-&gt;Tag##_at_addr(0), buf, sizeof(ElementType)*len); \
2795     } \
2796     if ((mode == 0) || (mode == JNI_ABORT)) { \
2797       FreeHeap(buf); \
2798     } \
2799   } \
2800   ReturnProbe; \
2801 JNI_END
2802 
2803 DEFINE_RELEASESCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2804                                   , HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2805                                   HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_RETURN())
2806 DEFINE_RELEASESCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2807                                   , HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_ENTRY(env, array, (char *) buf, mode),
2808                                   HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_RETURN())
2809 DEFINE_RELEASESCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2810                                   ,  HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2811                                   HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_RETURN())
2812 DEFINE_RELEASESCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2813                                   ,  HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2814                                   HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_RETURN())
2815 DEFINE_RELEASESCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2816                                   , HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_ENTRY(env, array, (uint32_t *) buf, mode),
2817                                   HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_RETURN())
2818 DEFINE_RELEASESCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2819                                   , HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2820                                   HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_RETURN())
2821 DEFINE_RELEASESCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2822                                   , HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_ENTRY(env, array, (float *) buf, mode),
2823                                   HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_RETURN())
2824 DEFINE_RELEASESCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2825                                   , HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_ENTRY(env, array, (double *) buf, mode),
2826                                   HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_RETURN())
2827 
2828 
2829 #define DEFINE_GETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2830                                     , EntryProbe, ReturnProbe); \
2831   DT_VOID_RETURN_MARK_DECL(Get##Result##ArrayRegion \
2832                            , ReturnProbe); \
2833 \
2834 JNI_ENTRY(void, \
2835 jni_Get##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2836              jsize len, ElementType *buf)) \
2837   JNIWrapper("Get" XSTR(Result) "ArrayRegion"); \
2838   EntryProbe; \
2839   DT_VOID_RETURN_MARK(Get##Result##ArrayRegion); \
2840   typeArrayOop src = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2841   if (start &lt; 0 || len &lt; 0 || ((unsigned int)start + (unsigned int)len &gt; (unsigned int)src-&gt;length())) { \
2842     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException()); \
2843   } else { \
2844     if (len &gt; 0) { \
2845       int sc = TypeArrayKlass::cast(src-&gt;klass())-&gt;log2_element_size(); \
2846       memcpy((u_char*) buf, \
2847              (u_char*) src-&gt;Tag##_at_addr(start), \
2848              len &lt;&lt; sc);                          \
2849     } \
2850   } \
2851 JNI_END
2852 
2853 DEFINE_GETSCALARARRAYREGION(T_BOOLEAN, jboolean,Boolean, bool
2854                             , HOTSPOT_JNI_GETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2855                             HOTSPOT_JNI_GETBOOLEANARRAYREGION_RETURN());
2856 DEFINE_GETSCALARARRAYREGION(T_BYTE,    jbyte,   Byte,    byte
2857                             ,  HOTSPOT_JNI_GETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2858                             HOTSPOT_JNI_GETBYTEARRAYREGION_RETURN());
2859 DEFINE_GETSCALARARRAYREGION(T_SHORT,   jshort,  Short,   short
2860                             , HOTSPOT_JNI_GETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2861                             HOTSPOT_JNI_GETSHORTARRAYREGION_RETURN());
2862 DEFINE_GETSCALARARRAYREGION(T_CHAR,    jchar,   Char,    char
2863                             ,  HOTSPOT_JNI_GETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t*) buf),
2864                             HOTSPOT_JNI_GETCHARARRAYREGION_RETURN());
2865 DEFINE_GETSCALARARRAYREGION(T_INT,     jint,    Int,     int
2866                             , HOTSPOT_JNI_GETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t*) buf),
2867                             HOTSPOT_JNI_GETINTARRAYREGION_RETURN());
2868 DEFINE_GETSCALARARRAYREGION(T_LONG,    jlong,   Long,    long
2869                             ,  HOTSPOT_JNI_GETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2870                             HOTSPOT_JNI_GETLONGARRAYREGION_RETURN());
2871 DEFINE_GETSCALARARRAYREGION(T_FLOAT,   jfloat,  Float,   float
2872                             , HOTSPOT_JNI_GETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2873                             HOTSPOT_JNI_GETFLOATARRAYREGION_RETURN());
2874 DEFINE_GETSCALARARRAYREGION(T_DOUBLE,  jdouble, Double,  double
2875                             , HOTSPOT_JNI_GETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2876                             HOTSPOT_JNI_GETDOUBLEARRAYREGION_RETURN());
2877 
2878 
2879 #define DEFINE_SETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2880                                     , EntryProbe, ReturnProbe); \
2881   DT_VOID_RETURN_MARK_DECL(Set##Result##ArrayRegion \
2882                            ,ReturnProbe);           \
2883 \
2884 JNI_ENTRY(void, \
2885 jni_Set##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2886              jsize len, const ElementType *buf)) \
2887   JNIWrapper("Set" XSTR(Result) "ArrayRegion"); \
2888   EntryProbe; \
2889   DT_VOID_RETURN_MARK(Set##Result##ArrayRegion); \
2890   typeArrayOop dst = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2891   if (start &lt; 0 || len &lt; 0 || ((unsigned int)start + (unsigned int)len &gt; (unsigned int)dst-&gt;length())) { \
2892     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException()); \
2893   } else { \
2894     if (len &gt; 0) { \
2895       int sc = TypeArrayKlass::cast(dst-&gt;klass())-&gt;log2_element_size(); \
2896       memcpy((u_char*) dst-&gt;Tag##_at_addr(start), \
2897              (u_char*) buf, \
2898              len &lt;&lt; sc);    \
2899     } \
2900   } \
2901 JNI_END
2902 
2903 DEFINE_SETSCALARARRAYREGION(T_BOOLEAN, jboolean, Boolean, bool
2904                             , HOTSPOT_JNI_SETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *)buf),
2905                             HOTSPOT_JNI_SETBOOLEANARRAYREGION_RETURN())
2906 DEFINE_SETSCALARARRAYREGION(T_BYTE,    jbyte,    Byte,    byte
2907                             , HOTSPOT_JNI_SETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2908                             HOTSPOT_JNI_SETBYTEARRAYREGION_RETURN())
2909 DEFINE_SETSCALARARRAYREGION(T_SHORT,   jshort,   Short,   short
2910                             , HOTSPOT_JNI_SETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2911                             HOTSPOT_JNI_SETSHORTARRAYREGION_RETURN())
2912 DEFINE_SETSCALARARRAYREGION(T_CHAR,    jchar,    Char,    char
2913                             , HOTSPOT_JNI_SETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2914                             HOTSPOT_JNI_SETCHARARRAYREGION_RETURN())
2915 DEFINE_SETSCALARARRAYREGION(T_INT,     jint,     Int,     int
2916                             , HOTSPOT_JNI_SETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t *) buf),
2917                             HOTSPOT_JNI_SETINTARRAYREGION_RETURN())
2918 DEFINE_SETSCALARARRAYREGION(T_LONG,    jlong,    Long,    long
2919                             , HOTSPOT_JNI_SETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2920                             HOTSPOT_JNI_SETLONGARRAYREGION_RETURN())
2921 DEFINE_SETSCALARARRAYREGION(T_FLOAT,   jfloat,   Float,   float
2922                             , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2923                             HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
2924 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
2925                             , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2926                             HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
2927 
2928 
2929 //
2930 // Interception of natives
2931 //
2932 
2933 // The RegisterNatives call being attempted tried to register with a method that
2934 // is not native.  Ask JVM TI what prefixes have been specified.  Then check
2935 // to see if the native method is now wrapped with the prefixes.  See the
2936 // SetNativeMethodPrefix(es) functions in the JVM TI Spec for details.
2937 static Method* find_prefixed_native(KlassHandle k,
2938                                       Symbol* name, Symbol* signature, TRAPS) {
2939 #if INCLUDE_JVMTI
2940   ResourceMark rm(THREAD);
2941   Method* method;
2942   int name_len = name-&gt;utf8_length();
2943   char* name_str = name-&gt;as_utf8();
2944   int prefix_count;
2945   char** prefixes = JvmtiExport::get_all_native_method_prefixes(&amp;prefix_count);
2946   for (int i = 0; i &lt; prefix_count; i++) {
2947     char* prefix = prefixes[i];
2948     int prefix_len = (int)strlen(prefix);
2949 
2950     // try adding this prefix to the method name and see if it matches another method name
2951     int trial_len = name_len + prefix_len;
2952     char* trial_name_str = NEW_RESOURCE_ARRAY(char, trial_len + 1);
2953     strcpy(trial_name_str, prefix);
2954     strcat(trial_name_str, name_str);
2955     TempNewSymbol trial_name = SymbolTable::probe(trial_name_str, trial_len);
2956     if (trial_name == NULL) {
2957       continue; // no such symbol, so this prefix wasn't used, try the next prefix
2958     }
2959     method = k()-&gt;lookup_method(trial_name, signature);
2960     if (method == NULL) {
2961       continue; // signature doesn't match, try the next prefix
2962     }
2963     if (method-&gt;is_native()) {
2964       method-&gt;set_is_prefixed_native();
2965       return method; // wahoo, we found a prefixed version of the method, return it
2966     }
2967     // found as non-native, so prefix is good, add it, probably just need more prefixes
2968     name_len = trial_len;
2969     name_str = trial_name_str;
2970   }
2971 #endif // INCLUDE_JVMTI
2972   return NULL; // not found
2973 }
2974 
2975 static bool register_native(KlassHandle k, Symbol* name, Symbol* signature, address entry, TRAPS) {
2976   Method* method = k()-&gt;lookup_method(name, signature);
2977   if (method == NULL) {
2978     ResourceMark rm;
2979     stringStream st;
2980     st.print("Method %s name or signature does not match",
2981              Method::name_and_sig_as_C_string(k(), name, signature));
2982     THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), false);
2983   }
2984   if (!method-&gt;is_native()) {
2985     // trying to register to a non-native method, see if a JVM TI agent has added prefix(es)
2986     method = find_prefixed_native(k, name, signature, THREAD);
2987     if (method == NULL) {
2988       ResourceMark rm;
2989       stringStream st;
2990       st.print("Method %s is not declared as native",
2991                Method::name_and_sig_as_C_string(k(), name, signature));
2992       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), false);
2993     }
2994   }
2995 
2996   if (entry != NULL) {
2997     method-&gt;set_native_function(entry,
2998       Method::native_bind_event_is_interesting);
2999   } else {
3000     method-&gt;clear_native_function();
3001   }
3002   if (PrintJNIResolving) {
3003     ResourceMark rm(THREAD);
3004     tty-&gt;print_cr("[Registering JNI native method %s.%s]",
3005       method-&gt;method_holder()-&gt;external_name(),
3006       method-&gt;name()-&gt;as_C_string());
3007   }
3008   return true;
3009 }
3010 
3011 DT_RETURN_MARK_DECL(RegisterNatives, jint
3012                     , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
3013 
3014 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
3015                                     const JNINativeMethod *methods,
3016                                     jint nMethods))
3017   JNIWrapper("RegisterNatives");
3018   HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
3019   jint ret = 0;
3020   DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
3021 
3022   KlassHandle h_k(thread, java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
3023 
3024   for (int index = 0; index &lt; nMethods; index++) {
3025     const char* meth_name = methods[index].name;
3026     const char* meth_sig = methods[index].signature;
3027     int meth_name_len = (int)strlen(meth_name);
3028 
3029     // The class should have been loaded (we have an instance of the class
3030     // passed in) so the method and signature should already be in the symbol
3031     // table.  If they're not there, the method doesn't exist.
3032     TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
3033     TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
3034 
3035     if (name == NULL || signature == NULL) {
3036       ResourceMark rm;
3037       stringStream st;
3038       st.print("Method %s.%s%s not found", h_k()-&gt;external_name(), meth_name, meth_sig);
3039       // Must return negative value on failure
3040       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
3041     }
3042 
3043     bool res = register_native(h_k, name, signature,
3044                                (address) methods[index].fnPtr, THREAD);
3045     if (!res) {
3046       ret = -1;
3047       break;
3048     }
3049   }
3050   return ret;
3051 JNI_END
3052 
3053 
3054 JNI_ENTRY(jint, jni_UnregisterNatives(JNIEnv *env, jclass clazz))
3055   JNIWrapper("UnregisterNatives");
3056  HOTSPOT_JNI_UNREGISTERNATIVES_ENTRY(env, clazz);
3057   Klass* k   = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
3058   //%note jni_2
3059   if (k-&gt;oop_is_instance()) {
3060     for (int index = 0; index &lt; InstanceKlass::cast(k)-&gt;methods()-&gt;length(); index++) {
3061       Method* m = InstanceKlass::cast(k)-&gt;methods()-&gt;at(index);
3062       if (m-&gt;is_native()) {
3063         m-&gt;clear_native_function();
3064         m-&gt;set_signature_handler(NULL);
3065       }
3066     }
3067   }
3068  HOTSPOT_JNI_UNREGISTERNATIVES_RETURN(0);
3069   return 0;
3070 JNI_END
3071 
3072 //
3073 // Monitor functions
3074 //
3075 
3076 DT_RETURN_MARK_DECL(MonitorEnter, jint
3077                     , HOTSPOT_JNI_MONITORENTER_RETURN(_ret_ref));
3078 
3079 JNI_ENTRY(jint, jni_MonitorEnter(JNIEnv *env, jobject jobj))
3080  HOTSPOT_JNI_MONITORENTER_ENTRY(env, jobj);
3081   jint ret = JNI_ERR;
3082   DT_RETURN_MARK(MonitorEnter, jint, (const jint&amp;)ret);
3083 
3084   // If the object is null, we can't do anything with it
3085   if (jobj == NULL) {
3086     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
3087   }
3088 
3089   Handle obj(thread, JNIHandles::resolve_non_null(jobj));
3090   ObjectSynchronizer::jni_enter(obj, CHECK_(JNI_ERR));
3091   ret = JNI_OK;
3092   return ret;
3093 JNI_END
3094 
3095 DT_RETURN_MARK_DECL(MonitorExit, jint
3096                     , HOTSPOT_JNI_MONITOREXIT_RETURN(_ret_ref));
3097 
3098 JNI_ENTRY(jint, jni_MonitorExit(JNIEnv *env, jobject jobj))
3099  HOTSPOT_JNI_MONITOREXIT_ENTRY(env, jobj);
3100   jint ret = JNI_ERR;
3101   DT_RETURN_MARK(MonitorExit, jint, (const jint&amp;)ret);
3102 
3103   // Don't do anything with a null object
3104   if (jobj == NULL) {
3105     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
3106   }
3107 
3108   Handle obj(THREAD, JNIHandles::resolve_non_null(jobj));
3109   ObjectSynchronizer::jni_exit(obj(), CHECK_(JNI_ERR));
3110 
3111   ret = JNI_OK;
3112   return ret;
3113 JNI_END
3114 
3115 //
3116 // Extensions
3117 //
3118 
3119 DT_VOID_RETURN_MARK_DECL(GetStringRegion
3120                          , HOTSPOT_JNI_GETSTRINGREGION_RETURN());
3121 
3122 JNI_ENTRY(void, jni_GetStringRegion(JNIEnv *env, jstring string, jsize start, jsize len, jchar *buf))
3123   JNIWrapper("GetStringRegion");
3124  HOTSPOT_JNI_GETSTRINGREGION_ENTRY(env, string, start, len, buf);
3125   DT_VOID_RETURN_MARK(GetStringRegion);
3126   oop s = JNIHandles::resolve_non_null(string);
3127   int s_len = java_lang_String::length(s);
3128   if (start &lt; 0 || len &lt; 0 || start + len &gt; s_len) {
3129     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
3130   } else {
3131     if (len &gt; 0) {
3132       int s_offset = java_lang_String::offset(s);
3133       typeArrayOop s_value = java_lang_String::value(s);
3134       memcpy(buf, s_value-&gt;char_at_addr(s_offset+start), sizeof(jchar)*len);
3135     }
3136   }
3137 JNI_END
3138 
3139 DT_VOID_RETURN_MARK_DECL(GetStringUTFRegion
3140                          , HOTSPOT_JNI_GETSTRINGUTFREGION_RETURN());
3141 
3142 JNI_ENTRY(void, jni_GetStringUTFRegion(JNIEnv *env, jstring string, jsize start, jsize len, char *buf))
3143   JNIWrapper("GetStringUTFRegion");
3144  HOTSPOT_JNI_GETSTRINGUTFREGION_ENTRY(env, string, start, len, buf);
3145   DT_VOID_RETURN_MARK(GetStringUTFRegion);
3146   oop s = JNIHandles::resolve_non_null(string);
3147   int s_len = java_lang_String::length(s);
3148   if (start &lt; 0 || len &lt; 0 || start + len &gt; s_len) {
3149     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
3150   } else {
3151     //%note jni_7
3152     if (len &gt; 0) {
3153       ResourceMark rm(THREAD);
3154       char *utf_region = java_lang_String::as_utf8_string(s, start, len);
3155       int utf_len = (int)strlen(utf_region);
3156       memcpy(buf, utf_region, utf_len);
3157       buf[utf_len] = 0;
3158     } else {
3159       // JDK null-terminates the buffer even in len is zero
3160       if (buf != NULL) {
3161         buf[0] = 0;
3162       }
3163     }
3164   }
3165 JNI_END
3166 
3167 
3168 JNI_ENTRY(void*, jni_GetPrimitiveArrayCritical(JNIEnv *env, jarray array, jboolean *isCopy))
3169   JNIWrapper("GetPrimitiveArrayCritical");
3170  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_ENTRY(env, array, (uintptr_t *) isCopy);
3171   GC_locker::lock_critical(thread);
3172   if (isCopy != NULL) {
3173     *isCopy = JNI_FALSE;
3174   }
3175   oop a = JNIHandles::resolve_non_null(array);
3176   assert(a-&gt;is_array(), "just checking");
3177   BasicType type;
3178   if (a-&gt;is_objArray()) {
3179     type = T_OBJECT;
3180   } else {
3181     type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
3182   }
3183   void* ret = arrayOop(a)-&gt;base(type);
3184  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_RETURN(ret);
3185   return ret;
3186 JNI_END
3187 
3188 
3189 JNI_ENTRY(void, jni_ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode))
3190   JNIWrapper("ReleasePrimitiveArrayCritical");
3191   HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_ENTRY(env, array, carray, mode);
3192   // The array, carray and mode arguments are ignored
3193   GC_locker::unlock_critical(thread);
3194 HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_RETURN();
3195 JNI_END
3196 
3197 
3198 JNI_ENTRY(const jchar*, jni_GetStringCritical(JNIEnv *env, jstring string, jboolean *isCopy))
3199   JNIWrapper("GetStringCritical");
3200   HOTSPOT_JNI_GETSTRINGCRITICAL_ENTRY(env, string, (uintptr_t *) isCopy);
3201   GC_locker::lock_critical(thread);
3202   if (isCopy != NULL) {
3203     *isCopy = JNI_FALSE;
3204   }
3205   oop s = JNIHandles::resolve_non_null(string);
3206   int s_len = java_lang_String::length(s);
3207   typeArrayOop s_value = java_lang_String::value(s);
3208   int s_offset = java_lang_String::offset(s);
3209   const jchar* ret;
3210   if (s_len &gt; 0) {
3211     ret = s_value-&gt;char_at_addr(s_offset);
3212   } else {
3213     ret = (jchar*) s_value-&gt;base(T_CHAR);
3214   }
3215  HOTSPOT_JNI_GETSTRINGCRITICAL_RETURN((uint16_t *) ret);
3216   return ret;
3217 JNI_END
3218 
3219 
3220 JNI_ENTRY(void, jni_ReleaseStringCritical(JNIEnv *env, jstring str, const jchar *chars))
3221   JNIWrapper("ReleaseStringCritical");
3222   HOTSPOT_JNI_RELEASESTRINGCRITICAL_ENTRY(env, str, (uint16_t *) chars);
3223   // The str and chars arguments are ignored
3224   GC_locker::unlock_critical(thread);
3225 HOTSPOT_JNI_RELEASESTRINGCRITICAL_RETURN();
3226 JNI_END
3227 
3228 
3229 JNI_ENTRY(jweak, jni_NewWeakGlobalRef(JNIEnv *env, jobject ref))
3230   JNIWrapper("jni_NewWeakGlobalRef");
3231  HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY(env, ref);
3232   Handle ref_handle(thread, JNIHandles::resolve(ref));
3233   jweak ret = JNIHandles::make_weak_global(ref_handle);
3234  HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN(ret);
3235   return ret;
3236 JNI_END
3237 
3238 // Must be JNI_ENTRY (with HandleMark)
3239 JNI_ENTRY(void, jni_DeleteWeakGlobalRef(JNIEnv *env, jweak ref))
3240   JNIWrapper("jni_DeleteWeakGlobalRef");
3241   HOTSPOT_JNI_DELETEWEAKGLOBALREF_ENTRY(env, ref);
3242   JNIHandles::destroy_weak_global(ref);
3243   HOTSPOT_JNI_DELETEWEAKGLOBALREF_RETURN();
3244 JNI_END
3245 
3246 
3247 JNI_QUICK_ENTRY(jboolean, jni_ExceptionCheck(JNIEnv *env))
3248   JNIWrapper("jni_ExceptionCheck");
3249  HOTSPOT_JNI_EXCEPTIONCHECK_ENTRY(env);
3250   jni_check_async_exceptions(thread);
3251   jboolean ret = (thread-&gt;has_pending_exception()) ? JNI_TRUE : JNI_FALSE;
3252  HOTSPOT_JNI_EXCEPTIONCHECK_RETURN(ret);
3253   return ret;
3254 JNI_END
3255 
3256 
3257 // Initialization state for three routines below relating to
3258 // java.nio.DirectBuffers
3259 static          jint directBufferSupportInitializeStarted = 0;
3260 static volatile jint directBufferSupportInitializeEnded   = 0;
3261 static volatile jint directBufferSupportInitializeFailed  = 0;
3262 static jclass    bufferClass                 = NULL;
3263 static jclass    directBufferClass           = NULL;
3264 static jclass    directByteBufferClass       = NULL;
3265 static jmethodID directByteBufferConstructor = NULL;
3266 static jfieldID  directBufferAddressField    = NULL;
3267 static jfieldID  bufferCapacityField         = NULL;
3268 
3269 static jclass lookupOne(JNIEnv* env, const char* name, TRAPS) {
3270   Handle loader;            // null (bootstrap) loader
3271   Handle protection_domain; // null protection domain
3272 
3273   TempNewSymbol sym = SymbolTable::new_symbol(name, CHECK_NULL);
3274   jclass result =  find_class_from_class_loader(env, sym, true, loader, protection_domain, true, CHECK_NULL);
3275 
3276   if (TraceClassResolution &amp;&amp; result != NULL) {
3277     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
3278   }
3279   return result;
3280 }
3281 
3282 // These lookups are done with the NULL (bootstrap) ClassLoader to
3283 // circumvent any security checks that would be done by jni_FindClass.
3284 JNI_ENTRY(bool, lookupDirectBufferClasses(JNIEnv* env))
3285 {
3286   if ((bufferClass           = lookupOne(env, "java/nio/Buffer", thread))           == NULL) { return false; }
3287   if ((directBufferClass     = lookupOne(env, "sun/nio/ch/DirectBuffer", thread))   == NULL) { return false; }
3288   if ((directByteBufferClass = lookupOne(env, "java/nio/DirectByteBuffer", thread)) == NULL) { return false; }
3289   return true;
3290 }
3291 JNI_END
3292 
3293 
3294 static bool initializeDirectBufferSupport(JNIEnv* env, JavaThread* thread) {
3295   if (directBufferSupportInitializeFailed) {
3296     return false;
3297   }
3298 
3299   if (Atomic::cmpxchg(1, &amp;directBufferSupportInitializeStarted, 0) == 0) {
3300     if (!lookupDirectBufferClasses(env)) {
3301       directBufferSupportInitializeFailed = 1;
3302       return false;
3303     }
3304 
3305     // Make global references for these
3306     bufferClass           = (jclass) env-&gt;NewGlobalRef(bufferClass);
3307     directBufferClass     = (jclass) env-&gt;NewGlobalRef(directBufferClass);
3308     directByteBufferClass = (jclass) env-&gt;NewGlobalRef(directByteBufferClass);
3309 
3310     // Get needed field and method IDs
3311     directByteBufferConstructor = env-&gt;GetMethodID(directByteBufferClass, "&lt;init&gt;", "(JI)V");
3312     if (env-&gt;ExceptionCheck()) {
3313       env-&gt;ExceptionClear();
3314       directBufferSupportInitializeFailed = 1;
3315       return false;
3316     }
3317     directBufferAddressField    = env-&gt;GetFieldID(bufferClass, "address", "J");
3318     if (env-&gt;ExceptionCheck()) {
3319       env-&gt;ExceptionClear();
3320       directBufferSupportInitializeFailed = 1;
3321       return false;
3322     }
3323     bufferCapacityField         = env-&gt;GetFieldID(bufferClass, "capacity", "I");
3324     if (env-&gt;ExceptionCheck()) {
3325       env-&gt;ExceptionClear();
3326       directBufferSupportInitializeFailed = 1;
3327       return false;
3328     }
3329 
3330     if ((directByteBufferConstructor == NULL) ||
3331         (directBufferAddressField    == NULL) ||
3332         (bufferCapacityField         == NULL)) {
3333       directBufferSupportInitializeFailed = 1;
3334       return false;
3335     }
3336 
3337     directBufferSupportInitializeEnded = 1;
3338   } else {
3339     while (!directBufferSupportInitializeEnded &amp;&amp; !directBufferSupportInitializeFailed) {
3340       // Set state as yield_all can call os:sleep. On Solaris, yield_all calls
3341       // os::sleep which requires the VM state transition. On other platforms, it
3342       // is not necessary. The following call to change the VM state is purposely
3343       // put inside the loop to avoid potential deadlock when multiple threads
3344       // try to call this method. See 6791815 for more details.
3345       ThreadInVMfromNative tivn(thread);
3346       os::yield_all();
3347     }
3348   }
3349 
3350   return !directBufferSupportInitializeFailed;
3351 }
3352 
3353 extern "C" jobject JNICALL jni_NewDirectByteBuffer(JNIEnv *env, void* address, jlong capacity)
3354 {
3355   // thread_from_jni_environment() will block if VM is gone.
3356   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3357 
3358   JNIWrapper("jni_NewDirectByteBuffer");
3359  HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_ENTRY(env, address, capacity);
3360 
3361   if (!directBufferSupportInitializeEnded) {
3362     if (!initializeDirectBufferSupport(env, thread)) {
3363       HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(NULL);
3364       return NULL;
3365     }
3366   }
3367 
3368   // Being paranoid about accidental sign extension on address
3369   jlong addr = (jlong) ((uintptr_t) address);
3370   // NOTE that package-private DirectByteBuffer constructor currently
3371   // takes int capacity
3372   jint  cap  = (jint)  capacity;
3373   jobject ret = env-&gt;NewObject(directByteBufferClass, directByteBufferConstructor, addr, cap);
3374   HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(ret);
3375   return ret;
3376 }
3377 
3378 DT_RETURN_MARK_DECL(GetDirectBufferAddress, void*
3379                     , HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_RETURN((void*) _ret_ref));
3380 
3381 extern "C" void* JNICALL jni_GetDirectBufferAddress(JNIEnv *env, jobject buf)
3382 {
3383   // thread_from_jni_environment() will block if VM is gone.
3384   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3385 
3386   JNIWrapper("jni_GetDirectBufferAddress");
3387   HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_ENTRY(env, buf);
3388   void* ret = NULL;
3389   DT_RETURN_MARK(GetDirectBufferAddress, void*, (const void*&amp;)ret);
3390 
3391   if (!directBufferSupportInitializeEnded) {
3392     if (!initializeDirectBufferSupport(env, thread)) {
3393       return 0;
3394     }
3395   }
3396 
3397   if ((buf != NULL) &amp;&amp; (!env-&gt;IsInstanceOf(buf, directBufferClass))) {
3398     return 0;
3399   }
3400 
3401   ret = (void*)(intptr_t)env-&gt;GetLongField(buf, directBufferAddressField);
3402   return ret;
3403 }
3404 
3405 DT_RETURN_MARK_DECL(GetDirectBufferCapacity, jlong
3406                     , HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_RETURN(_ret_ref));
3407 
3408 extern "C" jlong JNICALL jni_GetDirectBufferCapacity(JNIEnv *env, jobject buf)
3409 {
3410   // thread_from_jni_environment() will block if VM is gone.
3411   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3412 
3413   JNIWrapper("jni_GetDirectBufferCapacity");
3414   HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_ENTRY(env, buf);
3415   jlong ret = -1;
3416   DT_RETURN_MARK(GetDirectBufferCapacity, jlong, (const jlong&amp;)ret);
3417 
3418   if (!directBufferSupportInitializeEnded) {
3419     if (!initializeDirectBufferSupport(env, thread)) {
3420       ret = 0;
3421       return ret;
3422     }
3423   }
3424 
3425   if (buf == NULL) {
3426     return -1;
3427   }
3428 
3429   if (!env-&gt;IsInstanceOf(buf, directBufferClass)) {
3430     return -1;
3431   }
3432 
3433   // NOTE that capacity is currently an int in the implementation
3434   ret = env-&gt;GetIntField(buf, bufferCapacityField);
3435   return ret;
3436 }
3437 
3438 
3439 JNI_LEAF(jint, jni_GetVersion(JNIEnv *env))
3440   JNIWrapper("GetVersion");
3441   HOTSPOT_JNI_GETVERSION_ENTRY(env);
3442   HOTSPOT_JNI_GETVERSION_RETURN(CurrentVersion);
3443   return CurrentVersion;
3444 JNI_END
3445 
3446 extern struct JavaVM_ main_vm;
3447 
3448 JNI_LEAF(jint, jni_GetJavaVM(JNIEnv *env, JavaVM **vm))
3449   JNIWrapper("jni_GetJavaVM");
3450   HOTSPOT_JNI_GETJAVAVM_ENTRY(env, (void **) vm);
3451   *vm  = (JavaVM *)(&amp;main_vm);
3452   HOTSPOT_JNI_GETJAVAVM_RETURN(JNI_OK);
3453   return JNI_OK;
3454 JNI_END
3455 
3456 // Structure containing all jni functions
3457 struct JNINativeInterface_ jni_NativeInterface = {
3458     NULL,
3459     NULL,
3460     NULL,
3461 
3462     NULL,
3463 
3464     jni_GetVersion,
3465 
3466     jni_DefineClass,
3467     jni_FindClass,
3468 
3469     jni_FromReflectedMethod,
3470     jni_FromReflectedField,
3471 
3472     jni_ToReflectedMethod,
3473 
3474     jni_GetSuperclass,
3475     jni_IsAssignableFrom,
3476 
3477     jni_ToReflectedField,
3478 
3479     jni_Throw,
3480     jni_ThrowNew,
3481     jni_ExceptionOccurred,
3482     jni_ExceptionDescribe,
3483     jni_ExceptionClear,
3484     jni_FatalError,
3485 
3486     jni_PushLocalFrame,
3487     jni_PopLocalFrame,
3488 
3489     jni_NewGlobalRef,
3490     jni_DeleteGlobalRef,
3491     jni_DeleteLocalRef,
3492     jni_IsSameObject,
3493 
3494     jni_NewLocalRef,
3495     jni_EnsureLocalCapacity,
3496 
3497     jni_AllocObject,
3498     jni_NewObject,
3499     jni_NewObjectV,
3500     jni_NewObjectA,
3501 
3502     jni_GetObjectClass,
3503     jni_IsInstanceOf,
3504 
3505     jni_GetMethodID,
3506 
3507     jni_CallObjectMethod,
3508     jni_CallObjectMethodV,
3509     jni_CallObjectMethodA,
3510     jni_CallBooleanMethod,
3511     jni_CallBooleanMethodV,
3512     jni_CallBooleanMethodA,
3513     jni_CallByteMethod,
3514     jni_CallByteMethodV,
3515     jni_CallByteMethodA,
3516     jni_CallCharMethod,
3517     jni_CallCharMethodV,
3518     jni_CallCharMethodA,
3519     jni_CallShortMethod,
3520     jni_CallShortMethodV,
3521     jni_CallShortMethodA,
3522     jni_CallIntMethod,
3523     jni_CallIntMethodV,
3524     jni_CallIntMethodA,
3525     jni_CallLongMethod,
3526     jni_CallLongMethodV,
3527     jni_CallLongMethodA,
3528     jni_CallFloatMethod,
3529     jni_CallFloatMethodV,
3530     jni_CallFloatMethodA,
3531     jni_CallDoubleMethod,
3532     jni_CallDoubleMethodV,
3533     jni_CallDoubleMethodA,
3534     jni_CallVoidMethod,
3535     jni_CallVoidMethodV,
3536     jni_CallVoidMethodA,
3537 
3538     jni_CallNonvirtualObjectMethod,
3539     jni_CallNonvirtualObjectMethodV,
3540     jni_CallNonvirtualObjectMethodA,
3541     jni_CallNonvirtualBooleanMethod,
3542     jni_CallNonvirtualBooleanMethodV,
3543     jni_CallNonvirtualBooleanMethodA,
3544     jni_CallNonvirtualByteMethod,
3545     jni_CallNonvirtualByteMethodV,
3546     jni_CallNonvirtualByteMethodA,
3547     jni_CallNonvirtualCharMethod,
3548     jni_CallNonvirtualCharMethodV,
3549     jni_CallNonvirtualCharMethodA,
3550     jni_CallNonvirtualShortMethod,
3551     jni_CallNonvirtualShortMethodV,
3552     jni_CallNonvirtualShortMethodA,
3553     jni_CallNonvirtualIntMethod,
3554     jni_CallNonvirtualIntMethodV,
3555     jni_CallNonvirtualIntMethodA,
3556     jni_CallNonvirtualLongMethod,
3557     jni_CallNonvirtualLongMethodV,
3558     jni_CallNonvirtualLongMethodA,
3559     jni_CallNonvirtualFloatMethod,
3560     jni_CallNonvirtualFloatMethodV,
3561     jni_CallNonvirtualFloatMethodA,
3562     jni_CallNonvirtualDoubleMethod,
3563     jni_CallNonvirtualDoubleMethodV,
3564     jni_CallNonvirtualDoubleMethodA,
3565     jni_CallNonvirtualVoidMethod,
3566     jni_CallNonvirtualVoidMethodV,
3567     jni_CallNonvirtualVoidMethodA,
3568 
3569     jni_GetFieldID,
3570 
3571     jni_GetObjectField,
3572     jni_GetBooleanField,
3573     jni_GetByteField,
3574     jni_GetCharField,
3575     jni_GetShortField,
3576     jni_GetIntField,
3577     jni_GetLongField,
3578     jni_GetFloatField,
3579     jni_GetDoubleField,
3580 
3581     jni_SetObjectField,
3582     jni_SetBooleanField,
3583     jni_SetByteField,
3584     jni_SetCharField,
3585     jni_SetShortField,
3586     jni_SetIntField,
3587     jni_SetLongField,
3588     jni_SetFloatField,
3589     jni_SetDoubleField,
3590 
3591     jni_GetStaticMethodID,
3592 
3593     jni_CallStaticObjectMethod,
3594     jni_CallStaticObjectMethodV,
3595     jni_CallStaticObjectMethodA,
3596     jni_CallStaticBooleanMethod,
3597     jni_CallStaticBooleanMethodV,
3598     jni_CallStaticBooleanMethodA,
3599     jni_CallStaticByteMethod,
3600     jni_CallStaticByteMethodV,
3601     jni_CallStaticByteMethodA,
3602     jni_CallStaticCharMethod,
3603     jni_CallStaticCharMethodV,
3604     jni_CallStaticCharMethodA,
3605     jni_CallStaticShortMethod,
3606     jni_CallStaticShortMethodV,
3607     jni_CallStaticShortMethodA,
3608     jni_CallStaticIntMethod,
3609     jni_CallStaticIntMethodV,
3610     jni_CallStaticIntMethodA,
3611     jni_CallStaticLongMethod,
3612     jni_CallStaticLongMethodV,
3613     jni_CallStaticLongMethodA,
3614     jni_CallStaticFloatMethod,
3615     jni_CallStaticFloatMethodV,
3616     jni_CallStaticFloatMethodA,
3617     jni_CallStaticDoubleMethod,
3618     jni_CallStaticDoubleMethodV,
3619     jni_CallStaticDoubleMethodA,
3620     jni_CallStaticVoidMethod,
3621     jni_CallStaticVoidMethodV,
3622     jni_CallStaticVoidMethodA,
3623 
3624     jni_GetStaticFieldID,
3625 
3626     jni_GetStaticObjectField,
3627     jni_GetStaticBooleanField,
3628     jni_GetStaticByteField,
3629     jni_GetStaticCharField,
3630     jni_GetStaticShortField,
3631     jni_GetStaticIntField,
3632     jni_GetStaticLongField,
3633     jni_GetStaticFloatField,
3634     jni_GetStaticDoubleField,
3635 
3636     jni_SetStaticObjectField,
3637     jni_SetStaticBooleanField,
3638     jni_SetStaticByteField,
3639     jni_SetStaticCharField,
3640     jni_SetStaticShortField,
3641     jni_SetStaticIntField,
3642     jni_SetStaticLongField,
3643     jni_SetStaticFloatField,
3644     jni_SetStaticDoubleField,
3645 
3646     jni_NewString,
3647     jni_GetStringLength,
3648     jni_GetStringChars,
3649     jni_ReleaseStringChars,
3650 
3651     jni_NewStringUTF,
3652     jni_GetStringUTFLength,
3653     jni_GetStringUTFChars,
3654     jni_ReleaseStringUTFChars,
3655 
3656     jni_GetArrayLength,
3657 
3658     jni_NewObjectArray,
3659     jni_GetObjectArrayElement,
3660     jni_SetObjectArrayElement,
3661 
3662     jni_NewBooleanArray,
3663     jni_NewByteArray,
3664     jni_NewCharArray,
3665     jni_NewShortArray,
3666     jni_NewIntArray,
3667     jni_NewLongArray,
3668     jni_NewFloatArray,
3669     jni_NewDoubleArray,
3670 
3671     jni_GetBooleanArrayElements,
3672     jni_GetByteArrayElements,
3673     jni_GetCharArrayElements,
3674     jni_GetShortArrayElements,
3675     jni_GetIntArrayElements,
3676     jni_GetLongArrayElements,
3677     jni_GetFloatArrayElements,
3678     jni_GetDoubleArrayElements,
3679 
3680     jni_ReleaseBooleanArrayElements,
3681     jni_ReleaseByteArrayElements,
3682     jni_ReleaseCharArrayElements,
3683     jni_ReleaseShortArrayElements,
3684     jni_ReleaseIntArrayElements,
3685     jni_ReleaseLongArrayElements,
3686     jni_ReleaseFloatArrayElements,
3687     jni_ReleaseDoubleArrayElements,
3688 
3689     jni_GetBooleanArrayRegion,
3690     jni_GetByteArrayRegion,
3691     jni_GetCharArrayRegion,
3692     jni_GetShortArrayRegion,
3693     jni_GetIntArrayRegion,
3694     jni_GetLongArrayRegion,
3695     jni_GetFloatArrayRegion,
3696     jni_GetDoubleArrayRegion,
3697 
3698     jni_SetBooleanArrayRegion,
3699     jni_SetByteArrayRegion,
3700     jni_SetCharArrayRegion,
3701     jni_SetShortArrayRegion,
3702     jni_SetIntArrayRegion,
3703     jni_SetLongArrayRegion,
3704     jni_SetFloatArrayRegion,
3705     jni_SetDoubleArrayRegion,
3706 
3707     jni_RegisterNatives,
3708     jni_UnregisterNatives,
3709 
3710     jni_MonitorEnter,
3711     jni_MonitorExit,
3712 
3713     jni_GetJavaVM,
3714 
3715     jni_GetStringRegion,
3716     jni_GetStringUTFRegion,
3717 
3718     jni_GetPrimitiveArrayCritical,
3719     jni_ReleasePrimitiveArrayCritical,
3720 
3721     jni_GetStringCritical,
3722     jni_ReleaseStringCritical,
3723 
3724     jni_NewWeakGlobalRef,
3725     jni_DeleteWeakGlobalRef,
3726 
3727     jni_ExceptionCheck,
3728 
3729     jni_NewDirectByteBuffer,
3730     jni_GetDirectBufferAddress,
3731     jni_GetDirectBufferCapacity,
3732 
3733     // New 1_6 features
3734 
3735     jni_GetObjectRefType
3736 };
3737 
3738 
3739 // For jvmti use to modify jni function table.
3740 // Java threads in native contiues to run until it is transitioned
3741 // to VM at safepoint. Before the transition or before it is blocked
3742 // for safepoint it may access jni function table. VM could crash if
3743 // any java thread access the jni function table in the middle of memcpy.
3744 // To avoid this each function pointers are copied automically.
3745 void copy_jni_function_table(const struct JNINativeInterface_ *new_jni_NativeInterface) {
3746   assert(SafepointSynchronize::is_at_safepoint(), "must be at safepoint");
3747   intptr_t *a = (intptr_t *) jni_functions();
3748   intptr_t *b = (intptr_t *) new_jni_NativeInterface;
3749   for (uint i=0; i &lt;  sizeof(struct JNINativeInterface_)/sizeof(void *); i++) {
3750     Atomic::store_ptr(*b++, a++);
3751   }
3752 }
3753 
3754 void quicken_jni_functions() {
3755   // Replace Get&lt;Primitive&gt;Field with fast versions
3756   if (UseFastJNIAccessors &amp;&amp; !JvmtiExport::can_post_field_access()
3757       &amp;&amp; !VerifyJNIFields &amp;&amp; !TraceJNICalls &amp;&amp; !CountJNICalls &amp;&amp; !CheckJNICalls
3758 #if defined(_WINDOWS) &amp;&amp; defined(IA32) &amp;&amp; defined(COMPILER2)
3759       // windows x86 currently needs SEH wrapper and the gain of the fast
3760       // versions currently isn't certain for server vm on uniprocessor.
3761       &amp;&amp; os::is_MP()
3762 #endif
3763   ) {
3764     address func;
3765     func = JNI_FastGetField::generate_fast_get_boolean_field();
3766     if (func != (address)-1) {
3767       jni_NativeInterface.GetBooleanField = (GetBooleanField_t)func;
3768     }
3769     func = JNI_FastGetField::generate_fast_get_byte_field();
3770     if (func != (address)-1) {
3771       jni_NativeInterface.GetByteField = (GetByteField_t)func;
3772     }
3773     func = JNI_FastGetField::generate_fast_get_char_field();
3774     if (func != (address)-1) {
3775       jni_NativeInterface.GetCharField = (GetCharField_t)func;
3776     }
3777     func = JNI_FastGetField::generate_fast_get_short_field();
3778     if (func != (address)-1) {
3779       jni_NativeInterface.GetShortField = (GetShortField_t)func;
3780     }
3781     func = JNI_FastGetField::generate_fast_get_int_field();
3782     if (func != (address)-1) {
3783       jni_NativeInterface.GetIntField = (GetIntField_t)func;
3784     }
3785     func = JNI_FastGetField::generate_fast_get_long_field();
3786     if (func != (address)-1) {
3787       jni_NativeInterface.GetLongField = (GetLongField_t)func;
3788     }
3789     func = JNI_FastGetField::generate_fast_get_float_field();
3790     if (func != (address)-1) {
3791       jni_NativeInterface.GetFloatField = (GetFloatField_t)func;
3792     }
3793     func = JNI_FastGetField::generate_fast_get_double_field();
3794     if (func != (address)-1) {
3795       jni_NativeInterface.GetDoubleField = (GetDoubleField_t)func;
3796     }
3797   }
3798 }
3799 
3800 // Returns the function structure
3801 struct JNINativeInterface_* jni_functions() {
3802 #if INCLUDE_JNI_CHECK
3803   if (CheckJNICalls) return jni_functions_check();
3804 #endif // INCLUDE_JNI_CHECK
3805   return &amp;jni_NativeInterface;
3806 }
3807 
3808 // Returns the function structure
3809 struct JNINativeInterface_* jni_functions_nocheck() {
3810   return &amp;jni_NativeInterface;
3811 }
3812 
3813 
3814 // Invocation API
3815 
3816 
3817 // Forward declaration
3818 extern const struct JNIInvokeInterface_ jni_InvokeInterface;
3819 
3820 // Global invocation API vars
3821 volatile jint vm_created = 0;
3822 // Indicate whether it is safe to recreate VM
3823 volatile jint safe_to_recreate_vm = 1;
3824 struct JavaVM_ main_vm = {&amp;jni_InvokeInterface};
3825 
3826 
3827 #define JAVASTACKSIZE (400 * 1024)    /* Default size of a thread java stack */
3828 enum { VERIFY_NONE, VERIFY_REMOTE, VERIFY_ALL };
3829 
3830 DT_RETURN_MARK_DECL(GetDefaultJavaVMInitArgs, jint
3831                     , HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_RETURN(_ret_ref));
3832 
3833 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args_) {
3834   HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_ENTRY(args_);
3835   JDK1_1InitArgs *args = (JDK1_1InitArgs *)args_;
3836   jint ret = JNI_ERR;
3837   DT_RETURN_MARK(GetDefaultJavaVMInitArgs, jint, (const jint&amp;)ret);
3838 
3839   if (Threads::is_supported_jni_version(args-&gt;version)) {
3840     ret = JNI_OK;
3841   }
3842   // 1.1 style no longer supported in hotspot.
3843   // According the JNI spec, we should update args-&gt;version on return.
3844   // We also use the structure to communicate with launcher about default
3845   // stack size.
3846   if (args-&gt;version == JNI_VERSION_1_1) {
3847     args-&gt;version = JNI_VERSION_1_2;
3848     // javaStackSize is int in arguments structure
3849     assert(jlong(ThreadStackSize) * K &lt; INT_MAX, "integer overflow");
3850     args-&gt;javaStackSize = (jint)(ThreadStackSize * K);
3851   }
3852   return ret;
3853 }
3854 
3855 #ifndef PRODUCT
3856 
3857 #include "gc_implementation/shared/gcTimer.hpp"
3858 #include "gc_interface/collectedHeap.hpp"
3859 #if INCLUDE_ALL_GCS
3860 #include "gc_implementation/g1/heapRegionRemSet.hpp"
3861 #endif
3862 #include "utilities/quickSort.hpp"
3863 #include "utilities/ostream.hpp"
3864 #if INCLUDE_VM_STRUCTS
3865 #include "runtime/vmStructs.hpp"
3866 #endif
3867 
3868 #define run_unit_test(unit_test_function_call)              \
3869   tty-&gt;print_cr("Running test: " #unit_test_function_call); \
3870   unit_test_function_call
3871 
3872 // Forward declaration
3873 void TestReservedSpace_test();
3874 void TestReserveMemorySpecial_test();
3875 void TestVirtualSpace_test();
3876 void TestMetaspaceAux_test();
3877 void TestMetachunk_test();
3878 void TestVirtualSpaceNode_test();
3879 void TestNewSize_test();
3880 void TestOldSize_test();
3881 void TestKlass_test();
3882 void TestBitMap_test();
3883 #if INCLUDE_ALL_GCS
3884 void TestOldFreeSpaceCalculation_test();
3885 void TestG1BiasedArray_test();
3886 void TestBufferingOopClosure_test();
3887 void TestCodeCacheRemSet_test();
3888 #endif
3889 
3890 void execute_internal_vm_tests() {
3891   if (ExecuteInternalVMTests) {
3892     tty-&gt;print_cr("Running internal VM tests");
3893     run_unit_test(TestReservedSpace_test());
3894     run_unit_test(TestReserveMemorySpecial_test());
3895     run_unit_test(TestVirtualSpace_test());
3896     run_unit_test(TestMetaspaceAux_test());
3897     run_unit_test(TestMetachunk_test());
3898     run_unit_test(TestVirtualSpaceNode_test());
3899     run_unit_test(GlobalDefinitions::test_globals());
3900     run_unit_test(GCTimerAllTest::all());
3901     run_unit_test(arrayOopDesc::test_max_array_length());
3902     run_unit_test(CollectedHeap::test_is_in());
3903     run_unit_test(QuickSort::test_quick_sort());
3904     run_unit_test(AltHashing::test_alt_hash());
3905     run_unit_test(test_loggc_filename());
3906     run_unit_test(TestNewSize_test());
3907     run_unit_test(TestOldSize_test());
3908     run_unit_test(TestKlass_test());
3909     run_unit_test(TestBitMap_test());
3910 #if INCLUDE_VM_STRUCTS
3911     run_unit_test(VMStructs::test());
3912 #endif
3913 #if INCLUDE_ALL_GCS
3914     run_unit_test(TestOldFreeSpaceCalculation_test());
3915     run_unit_test(TestG1BiasedArray_test());
3916     run_unit_test(HeapRegionRemSet::test_prt());
3917     run_unit_test(TestBufferingOopClosure_test());
3918     run_unit_test(TestCodeCacheRemSet_test());
3919 #endif
3920     tty-&gt;print_cr("All internal VM tests passed");
3921   }
3922 }
3923 
3924 #undef run_unit_test
3925 
3926 #endif
3927 
3928 DT_RETURN_MARK_DECL(CreateJavaVM, jint
3929                     , HOTSPOT_JNI_CREATEJAVAVM_RETURN(_ret_ref));
3930 
3931 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) {
3932   HOTSPOT_JNI_CREATEJAVAVM_ENTRY((void **) vm, penv, args);
3933 
3934   jint result = JNI_ERR;
3935   DT_RETURN_MARK(CreateJavaVM, jint, (const jint&amp;)result);
3936 
3937   // We're about to use Atomic::xchg for synchronization.  Some Zero
3938   // platforms use the GCC builtin __sync_lock_test_and_set for this,
3939   // but __sync_lock_test_and_set is not guaranteed to do what we want
3940   // on all architectures.  So we check it works before relying on it.
3941 #if defined(ZERO) &amp;&amp; defined(ASSERT)
3942   {
3943     jint a = 0xcafebabe;
3944     jint b = Atomic::xchg(0xdeadbeef, &amp;a);
3945     void *c = &amp;a;
3946     void *d = Atomic::xchg_ptr(&amp;b, &amp;c);
3947     assert(a == (jint) 0xdeadbeef &amp;&amp; b == (jint) 0xcafebabe, "Atomic::xchg() works");
3948     assert(c == &amp;b &amp;&amp; d == &amp;a, "Atomic::xchg_ptr() works");
3949   }
3950 #endif // ZERO &amp;&amp; ASSERT
3951 
3952   // At the moment it's only possible to have one Java VM,
3953   // since some of the runtime state is in global variables.
3954 
3955   // We cannot use our mutex locks here, since they only work on
3956   // Threads. We do an atomic compare and exchange to ensure only
3957   // one thread can call this method at a time
3958 
3959   // We use Atomic::xchg rather than Atomic::add/dec since on some platforms
3960   // the add/dec implementations are dependent on whether we are running
3961   // on a multiprocessor, and at this stage of initialization the os::is_MP
3962   // function used to determine this will always return false. Atomic::xchg
3963   // does not have this problem.
3964   if (Atomic::xchg(1, &amp;vm_created) == 1) {
3965     return JNI_EEXIST;   // already created, or create attempt in progress
3966   }
3967   if (Atomic::xchg(0, &amp;safe_to_recreate_vm) == 0) {
3968     return JNI_ERR;  // someone tried and failed and retry not allowed.
3969   }
3970 
3971   assert(vm_created == 1, "vm_created is true during the creation");
3972 
3973   /**
3974    * Certain errors during initialization are recoverable and do not
3975    * prevent this method from being called again at a later time
3976    * (perhaps with different arguments).  However, at a certain
3977    * point during initialization if an error occurs we cannot allow
3978    * this function to be called again (or it will crash).  In those
3979    * situations, the 'canTryAgain' flag is set to false, which atomically
3980    * sets safe_to_recreate_vm to 1, such that any new call to
3981    * JNI_CreateJavaVM will immediately fail using the above logic.
3982    */
3983   bool can_try_again = true;
3984 
3985   result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again);
3986   if (result == JNI_OK) {
3987     JavaThread *thread = JavaThread::current();
3988     assert(!thread-&gt;has_pending_exception(), "should have returned not OK");
3989     /* thread is thread_in_vm here */
3990     *vm = (JavaVM *)(&amp;main_vm);
3991     *(JNIEnv**)penv = thread-&gt;jni_environment();
3992 
3993     // Tracks the time application was running before GC
3994     RuntimeService::record_application_start();
3995 
3996     // Notify JVMTI
3997     if (JvmtiExport::should_post_thread_life()) {
3998        JvmtiExport::post_thread_start(thread);
3999     }
4000 
4001     EventThreadStart event;
4002     if (event.should_commit()) {
4003       event.set_javalangthread(java_lang_Thread::thread_id(thread-&gt;threadObj()));
4004       event.commit();
4005     }
4006 
4007 #ifndef PRODUCT
4008   #ifndef CALL_TEST_FUNC_WITH_WRAPPER_IF_NEEDED
4009     #define CALL_TEST_FUNC_WITH_WRAPPER_IF_NEEDED(f) f()
4010   #endif
4011 
4012     // Check if we should compile all classes on bootclasspath
4013     if (CompileTheWorld) ClassLoader::compile_the_world();
4014     if (ReplayCompiles) ciReplay::replay(thread);
4015 
4016     // Some platforms (like Win*) need a wrapper around these test
4017     // functions in order to properly handle error conditions.
4018     CALL_TEST_FUNC_WITH_WRAPPER_IF_NEEDED(test_error_handler);
4019     CALL_TEST_FUNC_WITH_WRAPPER_IF_NEEDED(execute_internal_vm_tests);
4020 #endif
4021 
4022     // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
4023     ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);
4024   } else {
4025     // If create_vm exits because of a pending exception, exit with that
4026     // exception.  In the future when we figure out how to reclaim memory,
4027     // we may be able to exit with JNI_ERR and allow the calling application
4028     // to continue.
4029     if (Universe::is_fully_initialized()) {
4030       // otherwise no pending exception possible - VM will already have aborted
4031       JavaThread* THREAD = JavaThread::current();
4032       if (HAS_PENDING_EXCEPTION) {
4033         HandleMark hm;
4034         vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
4035       }
4036     }
4037 
4038     if (can_try_again) {
4039       // reset safe_to_recreate_vm to 1 so that retrial would be possible
4040       safe_to_recreate_vm = 1;
4041     }
4042 
4043     // Creation failed. We must reset vm_created
4044     *vm = 0;
4045     *(JNIEnv**)penv = 0;
4046     // reset vm_created last to avoid race condition. Use OrderAccess to
4047     // control both compiler and architectural-based reordering.
4048     OrderAccess::release_store(&amp;vm_created, 0);
4049   }
4050 
4051   return result;
4052 }
4053 
4054 
4055 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetCreatedJavaVMs(JavaVM **vm_buf, jsize bufLen, jsize *numVMs) {
4056   // See bug 4367188, the wrapper can sometimes cause VM crashes
4057   // JNIWrapper("GetCreatedJavaVMs");
4058 
4059   HOTSPOT_JNI_GETCREATEDJAVAVMS_ENTRY((void **) vm_buf, bufLen, (uintptr_t *) numVMs);
4060 
4061   if (vm_created) {
4062     if (numVMs != NULL) *numVMs = 1;
4063     if (bufLen &gt; 0)     *vm_buf = (JavaVM *)(&amp;main_vm);
4064   } else {
4065     if (numVMs != NULL) *numVMs = 0;
4066   }
4067   HOTSPOT_JNI_GETCREATEDJAVAVMS_RETURN(JNI_OK);
4068   return JNI_OK;
4069 }
4070 
4071 extern "C" {
4072 
4073 DT_RETURN_MARK_DECL(DestroyJavaVM, jint
4074                     , HOTSPOT_JNI_DESTROYJAVAVM_RETURN(_ret_ref));
4075 
4076 jint JNICALL jni_DestroyJavaVM(JavaVM *vm) {
4077   HOTSPOT_JNI_DESTROYJAVAVM_ENTRY(vm);
4078   jint res = JNI_ERR;
4079   DT_RETURN_MARK(DestroyJavaVM, jint, (const jint&amp;)res);
4080 
4081   if (!vm_created) {
4082     res = JNI_ERR;
4083     return res;
4084   }
4085 
4086   JNIWrapper("DestroyJavaVM");
4087   JNIEnv *env;
4088   JavaVMAttachArgs destroyargs;
4089   destroyargs.version = CurrentVersion;
4090   destroyargs.name = (char *)"DestroyJavaVM";
4091   destroyargs.group = NULL;
4092   res = vm-&gt;AttachCurrentThread((void **)&amp;env, (void *)&amp;destroyargs);
4093   if (res != JNI_OK) {
4094     return res;
4095   }
4096 
4097   // Since this is not a JVM_ENTRY we have to set the thread state manually before entering.
4098   JavaThread* thread = JavaThread::current();
4099   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4100   if (Threads::destroy_vm()) {
4101     // Should not change thread state, VM is gone
4102     vm_created = false;
4103     res = JNI_OK;
4104     return res;
4105   } else {
4106     ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);
4107     res = JNI_ERR;
4108     return res;
4109   }
4110 }
4111 
4112 
4113 static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool daemon) {
4114   JavaVMAttachArgs *args = (JavaVMAttachArgs *) _args;
4115 
4116   // Check below commented out from JDK1.2fcs as well
4117   /*
4118   if (args &amp;&amp; (args-&gt;version != JNI_VERSION_1_1 || args-&gt;version != JNI_VERSION_1_2)) {
4119     return JNI_EVERSION;
4120   }
4121   */
4122 
4123   Thread* t = ThreadLocalStorage::get_thread_slow();
4124   if (t != NULL) {
4125     // If the thread has been attached this operation is a no-op
4126     *(JNIEnv**)penv = ((JavaThread*) t)-&gt;jni_environment();
4127     return JNI_OK;
4128   }
4129 
4130   // Create a thread and mark it as attaching so it will be skipped by the
4131   // ThreadsListEnumerator - see CR 6404306
4132   JavaThread* thread = new JavaThread(true);
4133 
4134   // Set correct safepoint info. The thread is going to call into Java when
4135   // initializing the Java level thread object. Hence, the correct state must
4136   // be set in order for the Safepoint code to deal with it correctly.
4137   thread-&gt;set_thread_state(_thread_in_vm);
4138   // Must do this before initialize_thread_local_storage
4139   thread-&gt;record_stack_base_and_size();
4140 
4141   thread-&gt;initialize_thread_local_storage();
4142 
4143   if (!os::create_attached_thread(thread)) {
4144     delete thread;
4145     return JNI_ERR;
4146   }
4147   // Enable stack overflow checks
4148   thread-&gt;create_stack_guard_pages();
4149 
4150   thread-&gt;initialize_tlab();
4151 
4152   thread-&gt;cache_global_variables();
4153 
4154   // Crucial that we do not have a safepoint check for this thread, since it has
4155   // not been added to the Thread list yet.
4156   { Threads_lock-&gt;lock_without_safepoint_check();
4157     // This must be inside this lock in order to get FullGCALot to work properly, i.e., to
4158     // avoid this thread trying to do a GC before it is added to the thread-list
4159     thread-&gt;set_active_handles(JNIHandleBlock::allocate_block());
4160     Threads::add(thread, daemon);
4161     Threads_lock-&gt;unlock();
4162   }
4163   // Create thread group and name info from attach arguments
4164   oop group = NULL;
4165   char* thread_name = NULL;
4166   if (args != NULL &amp;&amp; Threads::is_supported_jni_version(args-&gt;version)) {
4167     group = JNIHandles::resolve(args-&gt;group);
4168     thread_name = args-&gt;name; // may be NULL
4169   }
4170   if (group == NULL) group = Universe::main_thread_group();
4171 
4172   // Create Java level thread object and attach it to this thread
4173   bool attach_failed = false;
4174   {
4175     EXCEPTION_MARK;
4176     HandleMark hm(THREAD);
4177     Handle thread_group(THREAD, group);
4178     thread-&gt;allocate_threadObj(thread_group, thread_name, daemon, THREAD);
4179     if (HAS_PENDING_EXCEPTION) {
4180       CLEAR_PENDING_EXCEPTION;
4181       // cleanup outside the handle mark.
4182       attach_failed = true;
4183     }
4184   }
4185 
4186   if (attach_failed) {
4187     // Added missing cleanup
4188     thread-&gt;cleanup_failed_attach_current_thread();
4189     return JNI_ERR;
4190   }
4191 
4192   // mark the thread as no longer attaching
4193   // this uses a fence to push the change through so we don't have
4194   // to regrab the threads_lock
4195   thread-&gt;set_done_attaching_via_jni();
4196 
4197   // Set java thread status.
4198   java_lang_Thread::set_thread_status(thread-&gt;threadObj(),
4199               java_lang_Thread::RUNNABLE);
4200 
4201   // Notify the debugger
4202   if (JvmtiExport::should_post_thread_life()) {
4203     JvmtiExport::post_thread_start(thread);
4204   }
4205 
4206   EventThreadStart event;
4207   if (event.should_commit()) {
4208     event.set_javalangthread(java_lang_Thread::thread_id(thread-&gt;threadObj()));
4209     event.commit();
4210   }
4211 
4212   *(JNIEnv**)penv = thread-&gt;jni_environment();
4213 
4214   // Now leaving the VM, so change thread_state. This is normally automatically taken care
4215   // of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by
4216   // using ThreadStateTransition::transition, we do a callback to the safepoint code if
4217   // needed.
4218 
4219   ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);
4220 
4221   // Perform any platform dependent FPU setup
4222   os::setup_fpu();
4223 
4224   return JNI_OK;
4225 }
4226 
4227 
4228 jint JNICALL jni_AttachCurrentThread(JavaVM *vm, void **penv, void *_args) {
4229   HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(vm, penv, _args);
4230   if (!vm_created) {
4231   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4232     return JNI_ERR;
4233   }
4234 
4235   JNIWrapper("AttachCurrentThread");
4236   jint ret = attach_current_thread(vm, penv, _args, false);
4237   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(ret);
4238   return ret;
4239 }
4240 
4241 
4242 jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
4243   HOTSPOT_JNI_DETACHCURRENTTHREAD_ENTRY(vm);
4244   VM_Exit::block_if_vm_exited();
4245 
4246   JNIWrapper("DetachCurrentThread");
4247 
4248   // If the thread has been deattacted the operations is a no-op
4249   if (ThreadLocalStorage::thread() == NULL) {
4250   HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4251     return JNI_OK;
4252   }
4253 
4254   JavaThread* thread = JavaThread::current();
4255   if (thread-&gt;has_last_Java_frame()) {
4256   HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4257     // Can't detach a thread that's running java, that can't work.
4258     return JNI_ERR;
4259   }
4260 
4261   // Safepoint support. Have to do call-back to safepoint code, if in the
4262   // middel of a safepoint operation
4263   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4264 
4265   // XXX: Note that JavaThread::exit() call below removes the guards on the
4266   // stack pages set up via enable_stack_{red,yellow}_zone() calls
4267   // above in jni_AttachCurrentThread. Unfortunately, while the setting
4268   // of the guards is visible in jni_AttachCurrentThread above,
4269   // the removal of the guards is buried below in JavaThread::exit()
4270   // here. The abstraction should be more symmetrically either exposed
4271   // or hidden (e.g. it could probably be hidden in the same
4272   // (platform-dependent) methods where we do alternate stack
4273   // maintenance work?)
4274   thread-&gt;exit(false, JavaThread::jni_detach);
4275   delete thread;
4276 
4277   HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4278   return JNI_OK;
4279 }
4280 
4281 DT_RETURN_MARK_DECL(GetEnv, jint
4282                     , HOTSPOT_JNI_GETENV_RETURN(_ret_ref));
4283 
4284 jint JNICALL jni_GetEnv(JavaVM *vm, void **penv, jint version) {
4285   HOTSPOT_JNI_GETENV_ENTRY(vm, penv, version);
4286   jint ret = JNI_ERR;
4287   DT_RETURN_MARK(GetEnv, jint, (const jint&amp;)ret);
4288 
4289   if (!vm_created) {
4290     *penv = NULL;
4291     ret = JNI_EDETACHED;
4292     return ret;
4293   }
4294 
4295   if (JniExportedInterface::GetExportedInterface(vm, penv, version, &amp;ret)) {
4296     return ret;
4297   }
4298 
4299 #ifndef JVMPI_VERSION_1
4300 // need these in order to be polite about older agents
4301 #define JVMPI_VERSION_1   ((jint)0x10000001)
4302 #define JVMPI_VERSION_1_1 ((jint)0x10000002)
4303 #define JVMPI_VERSION_1_2 ((jint)0x10000003)
4304 #endif // !JVMPI_VERSION_1
4305 
4306   Thread* thread = ThreadLocalStorage::thread();
4307   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread()) {
4308     if (Threads::is_supported_jni_version_including_1_1(version)) {
4309       *(JNIEnv**)penv = ((JavaThread*) thread)-&gt;jni_environment();
4310       ret = JNI_OK;
4311       return ret;
4312 
4313     } else if (version == JVMPI_VERSION_1 ||
4314                version == JVMPI_VERSION_1_1 ||
4315                version == JVMPI_VERSION_1_2) {
4316       tty-&gt;print_cr("ERROR: JVMPI, an experimental interface, is no longer supported.");
4317       tty-&gt;print_cr("Please use the supported interface: the JVM Tool Interface (JVM TI).");
4318       ret = JNI_EVERSION;
4319       return ret;
4320     } else if (JvmtiExport::is_jvmdi_version(version)) {
4321       tty-&gt;print_cr("FATAL ERROR: JVMDI is no longer supported.");
4322       tty-&gt;print_cr("Please use the supported interface: the JVM Tool Interface (JVM TI).");
4323       ret = JNI_EVERSION;
4324       return ret;
4325     } else {
4326       *penv = NULL;
4327       ret = JNI_EVERSION;
4328       return ret;
4329     }
4330   } else {
4331     *penv = NULL;
4332     ret = JNI_EDETACHED;
4333     return ret;
4334   }
4335 }
4336 
4337 
4338 jint JNICALL jni_AttachCurrentThreadAsDaemon(JavaVM *vm, void **penv, void *_args) {
4339   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_ENTRY(vm, penv, _args);
4340   if (!vm_created) {
4341   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN((uint32_t) JNI_ERR);
4342     return JNI_ERR;
4343   }
4344 
4345   JNIWrapper("AttachCurrentThreadAsDaemon");
4346   jint ret = attach_current_thread(vm, penv, _args, true);
4347   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN(ret);
4348   return ret;
4349 }
4350 
4351 
4352 } // End extern "C"
4353 
4354 const struct JNIInvokeInterface_ jni_InvokeInterface = {
4355     NULL,
4356     NULL,
4357     NULL,
4358 
4359     jni_DestroyJavaVM,
4360     jni_AttachCurrentThread,
4361     jni_DetachCurrentThread,
4362     jni_GetEnv,
4363     jni_AttachCurrentThreadAsDaemon
4364 };
</pre></body></html>
