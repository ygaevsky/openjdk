<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/share/vm/interpreter/linkResolver.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 #include "classfile/defaultMethods.hpp"
  27 #include "classfile/systemDictionary.hpp"
  28 #include "classfile/vmSymbols.hpp"
  29 #include "compiler/compileBroker.hpp"
  30 #include "gc_interface/collectedHeap.inline.hpp"
  31 #include "interpreter/bytecode.hpp"
  32 #include "interpreter/interpreterRuntime.hpp"
  33 #include "interpreter/linkResolver.hpp"
  34 #include "memory/resourceArea.hpp"
  35 #include "memory/universe.inline.hpp"
  36 #include "oops/instanceKlass.hpp"
  37 #include "oops/objArrayOop.hpp"
  38 #include "prims/methodHandles.hpp"
  39 #include "prims/nativeLookup.hpp"
  40 #include "runtime/compilationPolicy.hpp"
  41 #include "runtime/fieldDescriptor.hpp"
  42 #include "runtime/frame.inline.hpp"
  43 #include "runtime/handles.inline.hpp"
  44 #include "runtime/reflection.hpp"
  45 #include "runtime/signature.hpp"
  46 #include "runtime/thread.inline.hpp"
  47 #include "runtime/vmThread.hpp"
  48 
  49 
  50 //------------------------------------------------------------------------------------------------------------------------
  51 // Implementation of CallInfo
  52 
  53 
  54 void CallInfo::set_static(KlassHandle resolved_klass, methodHandle resolved_method, TRAPS) {
  55   int vtable_index = Method::nonvirtual_vtable_index;
  56   set_common(resolved_klass, resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);
  57 }
  58 
  59 
  60 void CallInfo::set_interface(KlassHandle resolved_klass, KlassHandle selected_klass, methodHandle resolved_method, methodHandle selected_method, int itable_index, TRAPS) {
  61   // This is only called for interface methods. If the resolved_method
  62   // comes from java/lang/Object, it can be the subject of a virtual call, so
  63   // we should pick the vtable index from the resolved method.
  64   // In that case, the caller must call set_virtual instead of set_interface.
  65   assert(resolved_method-&gt;method_holder()-&gt;is_interface(), "");
  66   assert(itable_index == resolved_method()-&gt;itable_index(), "");
  67   set_common(resolved_klass, selected_klass, resolved_method, selected_method, CallInfo::itable_call, itable_index, CHECK);
  68 }
  69 
  70 void CallInfo::set_virtual(KlassHandle resolved_klass, KlassHandle selected_klass, methodHandle resolved_method, methodHandle selected_method, int vtable_index, TRAPS) {
  71   assert(vtable_index &gt;= 0 || vtable_index == Method::nonvirtual_vtable_index, "valid index");
  72   assert(vtable_index &lt; 0 || !resolved_method-&gt;has_vtable_index() || vtable_index == resolved_method-&gt;vtable_index(), "");
  73   CallKind kind = (vtable_index &gt;= 0 &amp;&amp; !resolved_method-&gt;can_be_statically_bound() ? CallInfo::vtable_call : CallInfo::direct_call);
  74   set_common(resolved_klass, selected_klass, resolved_method, selected_method, kind, vtable_index, CHECK);
  75   assert(!resolved_method-&gt;is_compiled_lambda_form(), "these must be handled via an invokehandle call");
  76 }
  77 
  78 void CallInfo::set_handle(methodHandle resolved_method, Handle resolved_appendix, Handle resolved_method_type, TRAPS) {
  79   if (resolved_method.is_null()) {
  80     THROW_MSG(vmSymbols::java_lang_InternalError(), "resolved method is null");
  81   }
  82   KlassHandle resolved_klass = SystemDictionary::MethodHandle_klass();
  83   assert(resolved_method-&gt;intrinsic_id() == vmIntrinsics::_invokeBasic ||
  84          resolved_method-&gt;is_compiled_lambda_form(),
  85          "linkMethod must return one of these");
  86   int vtable_index = Method::nonvirtual_vtable_index;
  87   assert(!resolved_method-&gt;has_vtable_index(), "");
  88   set_common(resolved_klass, resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);
  89   _resolved_appendix    = resolved_appendix;
  90   _resolved_method_type = resolved_method_type;
  91 }
  92 
  93 void CallInfo::set_common(KlassHandle resolved_klass,
  94                           KlassHandle selected_klass,
  95                           methodHandle resolved_method,
  96                           methodHandle selected_method,
  97                           CallKind kind,
  98                           int index,
  99                           TRAPS) {
 100   assert(resolved_method-&gt;signature() == selected_method-&gt;signature(), "signatures must correspond");
 101   _resolved_klass  = resolved_klass;
 102   _selected_klass  = selected_klass;
 103   _resolved_method = resolved_method;
 104   _selected_method = selected_method;
 105   _call_kind       = kind;
 106   _call_index      = index;
 107   _resolved_appendix = Handle();
 108   DEBUG_ONLY(verify());  // verify before making side effects
 109 
 110   if (CompilationPolicy::must_be_compiled(selected_method)) {
 111     // This path is unusual, mostly used by the '-Xcomp' stress test mode.
 112 
 113     // Note: with several active threads, the must_be_compiled may be true
 114     //       while can_be_compiled is false; remove assert
 115     // assert(CompilationPolicy::can_be_compiled(selected_method), "cannot compile");
 116     if (THREAD-&gt;is_Compiler_thread()) {
 117       // don't force compilation, resolve was on behalf of compiler
 118       return;
 119     }
 120     if (selected_method-&gt;method_holder()-&gt;is_not_initialized()) {
 121       // 'is_not_initialized' means not only '!is_initialized', but also that
 122       // initialization has not been started yet ('!being_initialized')
 123       // Do not force compilation of methods in uninitialized classes.
 124       // Note that doing this would throw an assert later,
 125       // in CompileBroker::compile_method.
 126       // We sometimes use the link resolver to do reflective lookups
 127       // even before classes are initialized.
 128       return;
 129     }
 130     CompileBroker::compile_method(selected_method, InvocationEntryBci,
 131                                   CompilationPolicy::policy()-&gt;initial_compile_level(),
 132                                   methodHandle(), 0, "must_be_compiled", CHECK);
 133   }
 134 }
 135 
 136 // utility query for unreflecting a method
 137 CallInfo::CallInfo(Method* resolved_method, Klass* resolved_klass) {
 138   Klass* resolved_method_holder = resolved_method-&gt;method_holder();
 139   if (resolved_klass == NULL) { // 2nd argument defaults to holder of 1st
 140     resolved_klass = resolved_method_holder;
 141   }
 142   _resolved_klass  = resolved_klass;
 143   _selected_klass  = resolved_klass;
 144   _resolved_method = resolved_method;
 145   _selected_method = resolved_method;
 146   // classify:
 147   CallKind kind = CallInfo::unknown_kind;
 148   int index = resolved_method-&gt;vtable_index();
 149   if (resolved_method-&gt;can_be_statically_bound()) {
 150     kind = CallInfo::direct_call;
 151   } else if (!resolved_method_holder-&gt;is_interface()) {
 152     // Could be an Object method inherited into an interface, but still a vtable call.
 153     kind = CallInfo::vtable_call;
 154   } else if (!resolved_klass-&gt;is_interface()) {
 155     // A default or miranda method.  Compute the vtable index.
 156     ResourceMark rm;
 157     klassVtable* vt = InstanceKlass::cast(resolved_klass)-&gt;vtable();
 158     index = LinkResolver::vtable_index_of_interface_method(resolved_klass,
 159                            resolved_method);
 160     assert(index &gt;= 0 , "we should have valid vtable index at this point");
 161 
 162     kind = CallInfo::vtable_call;
 163   } else if (resolved_method-&gt;has_vtable_index()) {
 164     // Can occur if an interface redeclares a method of Object.
 165 
 166 #ifdef ASSERT
 167     // Ensure that this is really the case.
 168     KlassHandle object_klass = SystemDictionary::Object_klass();
 169     Method * object_resolved_method = object_klass()-&gt;vtable()-&gt;method_at(index);
 170     assert(object_resolved_method-&gt;name() == resolved_method-&gt;name(),
 171       err_msg("Object and interface method names should match at vtable index %d, %s != %s",
 172       index, object_resolved_method-&gt;name()-&gt;as_C_string(), resolved_method-&gt;name()-&gt;as_C_string()));
 173     assert(object_resolved_method-&gt;signature() == resolved_method-&gt;signature(),
 174       err_msg("Object and interface method signatures should match at vtable index %d, %s != %s",
 175       index, object_resolved_method-&gt;signature()-&gt;as_C_string(), resolved_method-&gt;signature()-&gt;as_C_string()));
 176 #endif // ASSERT
 177 
 178     kind = CallInfo::vtable_call;
 179   } else {
 180     // A regular interface call.
 181     kind = CallInfo::itable_call;
 182     index = resolved_method-&gt;itable_index();
 183   }
 184   assert(index == Method::nonvirtual_vtable_index || index &gt;= 0, err_msg("bad index %d", index));
 185   _call_kind  = kind;
 186   _call_index = index;
 187   _resolved_appendix = Handle();
 188   DEBUG_ONLY(verify());
 189 }
 190 
 191 #ifdef ASSERT
 192 void CallInfo::verify() {
 193   switch (call_kind()) {  // the meaning and allowed value of index depends on kind
 194   case CallInfo::direct_call:
 195     if (_call_index == Method::nonvirtual_vtable_index)  break;
 196     // else fall through to check vtable index:
 197   case CallInfo::vtable_call:
 198     assert(resolved_klass()-&gt;verify_vtable_index(_call_index), "");
 199     break;
 200   case CallInfo::itable_call:
 201     assert(resolved_method()-&gt;method_holder()-&gt;verify_itable_index(_call_index), "");
 202     break;
 203   case CallInfo::unknown_kind:
 204     assert(call_kind() != CallInfo::unknown_kind, "CallInfo must be set");
 205     break;
 206   default:
 207     fatal(err_msg_res("Unexpected call kind %d", call_kind()));
 208   }
 209 }
 210 #endif //ASSERT
 211 
 212 
 213 
 214 //------------------------------------------------------------------------------------------------------------------------
 215 // Klass resolution
 216 
 217 void LinkResolver::check_klass_accessability(KlassHandle ref_klass, KlassHandle sel_klass, TRAPS) {
 218   if (!Reflection::verify_class_access(ref_klass(),
 219                                        sel_klass(),
 220                                        true)) {
 221     ResourceMark rm(THREAD);
 222     Exceptions::fthrow(
 223       THREAD_AND_LOCATION,
 224       vmSymbols::java_lang_IllegalAccessError(),
 225       "tried to access class %s from class %s",
 226       sel_klass-&gt;external_name(),
 227       ref_klass-&gt;external_name()
 228     );
 229     return;
 230   }
 231 }
 232 
 233 void LinkResolver::resolve_klass(KlassHandle&amp; result, constantPoolHandle pool, int index, TRAPS) {
 234   Klass* result_oop = pool-&gt;klass_ref_at(index, CHECK);
 235   result = KlassHandle(THREAD, result_oop);
 236 }
 237 
 238 //------------------------------------------------------------------------------------------------------------------------
 239 // Method resolution
 240 //
 241 // According to JVM spec. $5.4.3c &amp; $5.4.3d
 242 
 243 // Look up method in klasses, including static methods
 244 // Then look up local default methods
 245 void LinkResolver::lookup_method_in_klasses(methodHandle&amp; result, KlassHandle klass, Symbol* name, Symbol* signature, bool checkpolymorphism, bool in_imethod_resolve, TRAPS) {
 246   // Ignore overpasses so statics can be found during resolution
 247   Method* result_oop = klass-&gt;uncached_lookup_method(name, signature, Klass::skip_overpass);
 248 
 249   // JDK 8, JVMS 5.4.3.4: Interface method resolution should
 250   // ignore static and non-public methods of java.lang.Object,
 251   // like clone, finalize, registerNatives.
 252   if (in_imethod_resolve &amp;&amp;
 253       result_oop != NULL &amp;&amp;
 254       klass-&gt;is_interface() &amp;&amp;
 255       (result_oop-&gt;is_static() || !result_oop-&gt;is_public()) &amp;&amp;
 256       result_oop-&gt;method_holder() == SystemDictionary::Object_klass()) {
 257     result_oop = NULL;
 258   }
 259 
 260   // Before considering default methods, check for an overpass in the
 261   // current class if a method has not been found.
 262   if (result_oop == NULL) {
 263     result_oop = InstanceKlass::cast(klass())-&gt;find_method(name, signature);
 264   }
 265 
 266   if (result_oop == NULL) {
 267     Array&lt;Method*&gt;* default_methods = InstanceKlass::cast(klass())-&gt;default_methods();
 268     if (default_methods != NULL) {
 269       result_oop = InstanceKlass::find_method(default_methods, name, signature);
 270     }
 271   }
 272 
 273   if (checkpolymorphism &amp;&amp; EnableInvokeDynamic &amp;&amp; result_oop != NULL) {
 274     vmIntrinsics::ID iid = result_oop-&gt;intrinsic_id();
 275     if (MethodHandles::is_signature_polymorphic(iid)) {
 276       // Do not link directly to these.  The VM must produce a synthetic one using lookup_polymorphic_method.
 277       return;
 278     }
 279   }
 280   result = methodHandle(THREAD, result_oop);
 281 }
 282 
 283 // returns first instance method
 284 // Looks up method in classes, then looks up local default methods
 285 void LinkResolver::lookup_instance_method_in_klasses(methodHandle&amp; result, KlassHandle klass, Symbol* name, Symbol* signature, TRAPS) {
 286   Method* result_oop = klass-&gt;uncached_lookup_method(name, signature, Klass::normal);
 287   result = methodHandle(THREAD, result_oop);
 288   while (!result.is_null() &amp;&amp; result-&gt;is_static() &amp;&amp; result-&gt;method_holder()-&gt;super() != NULL) {
 289     KlassHandle super_klass = KlassHandle(THREAD, result-&gt;method_holder()-&gt;super());
 290     result = methodHandle(THREAD, super_klass-&gt;uncached_lookup_method(name, signature, Klass::normal));
 291   }
 292 
 293   if (result.is_null()) {
 294     Array&lt;Method*&gt;* default_methods = InstanceKlass::cast(klass())-&gt;default_methods();
 295     if (default_methods != NULL) {
 296       result = methodHandle(InstanceKlass::find_method(default_methods, name, signature));
 297       assert(result.is_null() || !result-&gt;is_static(), "static defaults not allowed");
 298     }
 299   }
 300 }
 301 
 302 int LinkResolver::vtable_index_of_interface_method(KlassHandle klass,
 303                                           methodHandle resolved_method) {
 304 
 305   int vtable_index = Method::invalid_vtable_index;
 306   Symbol* name = resolved_method-&gt;name();
 307   Symbol* signature = resolved_method-&gt;signature();
 308 
 309   // First check in default method array
 310   if (!resolved_method-&gt;is_abstract() &amp;&amp;
 311     (InstanceKlass::cast(klass())-&gt;default_methods() != NULL)) {
 312     int index = InstanceKlass::find_method_index(InstanceKlass::cast(klass())-&gt;default_methods(), name, signature, false);
 313     if (index &gt;= 0 ) {
 314       vtable_index = InstanceKlass::cast(klass())-&gt;default_vtable_indices()-&gt;at(index);
 315     }
 316   }
 317   if (vtable_index == Method::invalid_vtable_index) {
 318     // get vtable_index for miranda methods
 319     ResourceMark rm;
 320     klassVtable *vt = InstanceKlass::cast(klass())-&gt;vtable();
 321     vtable_index = vt-&gt;index_of_miranda(name, signature);
 322   }
 323   return vtable_index;
 324 }
 325 
 326 void LinkResolver::lookup_method_in_interfaces(methodHandle&amp; result, KlassHandle klass, Symbol* name, Symbol* signature, TRAPS) {
 327   InstanceKlass *ik = InstanceKlass::cast(klass());
 328 
 329   // Specify 'true' in order to skip default methods when searching the
 330   // interfaces.  Function lookup_method_in_klasses() already looked for
 331   // the method in the default methods table.
 332   result = methodHandle(THREAD, ik-&gt;lookup_method_in_all_interfaces(name, signature, Klass::skip_defaults));
 333 }
 334 
 335 void LinkResolver::lookup_polymorphic_method(methodHandle&amp; result,
 336                                              KlassHandle klass, Symbol* name, Symbol* full_signature,
 337                                              KlassHandle current_klass,
 338                                              Handle *appendix_result_or_null,
 339                                              Handle *method_type_result,
 340                                              TRAPS) {
 341   vmIntrinsics::ID iid = MethodHandles::signature_polymorphic_name_id(name);
 342   if (TraceMethodHandles) {
 343     ResourceMark rm(THREAD);
 344     tty-&gt;print_cr("lookup_polymorphic_method iid=%s %s.%s%s",
 345                   vmIntrinsics::name_at(iid), klass-&gt;external_name(),
 346                   name-&gt;as_C_string(), full_signature-&gt;as_C_string());
 347   }
 348   if (EnableInvokeDynamic &amp;&amp;
 349       klass() == SystemDictionary::MethodHandle_klass() &amp;&amp;
 350       iid != vmIntrinsics::_none) {
 351     if (MethodHandles::is_signature_polymorphic_intrinsic(iid)) {
 352       // Most of these do not need an up-call to Java to resolve, so can be done anywhere.
 353       // Do not erase last argument type (MemberName) if it is a static linkTo method.
 354       bool keep_last_arg = MethodHandles::is_signature_polymorphic_static(iid);
 355       TempNewSymbol basic_signature =
 356         MethodHandles::lookup_basic_type_signature(full_signature, keep_last_arg, CHECK);
 357       if (TraceMethodHandles) {
 358         ResourceMark rm(THREAD);
 359         tty-&gt;print_cr("lookup_polymorphic_method %s %s =&gt; basic %s",
 360                       name-&gt;as_C_string(),
 361                       full_signature-&gt;as_C_string(),
 362                       basic_signature-&gt;as_C_string());
 363       }
 364       result = SystemDictionary::find_method_handle_intrinsic(iid,
 365                                                               basic_signature,
 366                                                               CHECK);
 367       if (result.not_null()) {
 368         assert(result-&gt;is_method_handle_intrinsic(), "MH.invokeBasic or MH.linkTo* intrinsic");
 369         assert(result-&gt;intrinsic_id() != vmIntrinsics::_invokeGeneric, "wrong place to find this");
 370         assert(basic_signature == result-&gt;signature(), "predict the result signature");
 371         if (TraceMethodHandles) {
 372           tty-&gt;print("lookup_polymorphic_method =&gt; intrinsic ");
 373           result-&gt;print_on(tty);
 374         }
 375         return;
 376       }
 377     } else if (iid == vmIntrinsics::_invokeGeneric
 378                &amp;&amp; !THREAD-&gt;is_Compiler_thread()
 379                &amp;&amp; appendix_result_or_null != NULL) {
 380       // This is a method with type-checking semantics.
 381       // We will ask Java code to spin an adapter method for it.
 382       if (!MethodHandles::enabled()) {
 383         // Make sure the Java part of the runtime has been booted up.
 384         Klass* natives = SystemDictionary::MethodHandleNatives_klass();
 385         if (natives == NULL || InstanceKlass::cast(natives)-&gt;is_not_initialized()) {
 386           SystemDictionary::resolve_or_fail(vmSymbols::java_lang_invoke_MethodHandleNatives(),
 387                                             Handle(),
 388                                             Handle(),
 389                                             true,
 390                                             CHECK);
 391         }
 392       }
 393 
 394       Handle appendix;
 395       Handle method_type;
 396       result = SystemDictionary::find_method_handle_invoker(name,
 397                                                             full_signature,
 398                                                             current_klass,
 399                                                             &amp;appendix,
 400                                                             &amp;method_type,
 401                                                             CHECK);
 402       if (TraceMethodHandles) {
 403         tty-&gt;print("lookup_polymorphic_method =&gt; (via Java) ");
 404         result-&gt;print_on(tty);
 405         tty-&gt;print("  lookup_polymorphic_method =&gt; appendix = ");
 406         if (appendix.is_null())  tty-&gt;print_cr("(none)");
 407         else                     appendix-&gt;print_on(tty);
 408       }
 409       if (result.not_null()) {
 410 #ifdef ASSERT
 411         ResourceMark rm(THREAD);
 412 
 413         TempNewSymbol basic_signature =
 414           MethodHandles::lookup_basic_type_signature(full_signature, CHECK);
 415         int actual_size_of_params = result-&gt;size_of_parameters();
 416         int expected_size_of_params = ArgumentSizeComputer(basic_signature).size();
 417         // +1 for MethodHandle.this, +1 for trailing MethodType
 418         if (!MethodHandles::is_signature_polymorphic_static(iid))  expected_size_of_params += 1;
 419         if (appendix.not_null())                                   expected_size_of_params += 1;
 420         if (actual_size_of_params != expected_size_of_params) {
 421           tty-&gt;print_cr("*** basic_signature=%s", basic_signature-&gt;as_C_string());
 422           tty-&gt;print_cr("*** result for %s: ", vmIntrinsics::name_at(iid));
 423           result-&gt;print();
 424         }
 425         assert(actual_size_of_params == expected_size_of_params,
 426                err_msg("%d != %d", actual_size_of_params, expected_size_of_params));
 427 #endif //ASSERT
 428 
 429         assert(appendix_result_or_null != NULL, "");
 430         (*appendix_result_or_null) = appendix;
 431         (*method_type_result)      = method_type;
 432         return;
 433       }
 434     }
 435   }
 436 }
 437 
 438 void LinkResolver::check_method_accessability(KlassHandle ref_klass,
 439                                               KlassHandle resolved_klass,
 440                                               KlassHandle sel_klass,
 441                                               methodHandle sel_method,
 442                                               TRAPS) {
 443 
 444   AccessFlags flags = sel_method-&gt;access_flags();
 445 
 446   // Special case:  arrays always override "clone". JVMS 2.15.
 447   // If the resolved klass is an array class, and the declaring class
 448   // is java.lang.Object and the method is "clone", set the flags
 449   // to public.
 450   //
 451   // We'll check for the method name first, as that's most likely
 452   // to be false (so we'll short-circuit out of these tests).
 453   if (sel_method-&gt;name() == vmSymbols::clone_name() &amp;&amp;
 454       sel_klass() == SystemDictionary::Object_klass() &amp;&amp;
 455       resolved_klass-&gt;oop_is_array()) {
 456     // We need to change "protected" to "public".
 457     assert(flags.is_protected(), "clone not protected?");
 458     jint new_flags = flags.as_int();
 459     new_flags = new_flags &amp; (~JVM_ACC_PROTECTED);
 460     new_flags = new_flags | JVM_ACC_PUBLIC;
 461     flags.set_flags(new_flags);
 462   }
 463 //  assert(extra_arg_result_or_null != NULL, "must be able to return extra argument");
 464 
 465   if (!Reflection::verify_field_access(ref_klass(),
 466                                        resolved_klass(),
 467                                        sel_klass(),
 468                                        flags,
 469                                        true)) {
 470     ResourceMark rm(THREAD);
 471     Exceptions::fthrow(
 472       THREAD_AND_LOCATION,
 473       vmSymbols::java_lang_IllegalAccessError(),
 474       "tried to access method %s.%s%s from class %s",
 475       sel_klass-&gt;external_name(),
 476       sel_method-&gt;name()-&gt;as_C_string(),
 477       sel_method-&gt;signature()-&gt;as_C_string(),
 478       ref_klass-&gt;external_name()
 479     );
 480     return;
 481   }
 482 }
 483 
 484 void LinkResolver::resolve_method_statically(methodHandle&amp; resolved_method, KlassHandle&amp; resolved_klass,
 485                                              Bytecodes::Code code, constantPoolHandle pool, int index, TRAPS) {
 486   // This method is used only
 487   // (1) in C2 from InlineTree::ok_to_inline (via ciMethod::check_call),
 488   // and
 489   // (2) in Bytecode_invoke::static_target
 490   // It appears to fail when applied to an invokeinterface call site.
 491   // FIXME: Remove this method and ciMethod::check_call; refactor to use the other LinkResolver entry points.
 492   // resolve klass
 493   if (code == Bytecodes::_invokedynamic) {
 494     resolved_klass = SystemDictionary::MethodHandle_klass();
 495     Symbol* method_name = vmSymbols::invoke_name();
 496     Symbol* method_signature = pool-&gt;signature_ref_at(index);
 497     KlassHandle  current_klass(THREAD, pool-&gt;pool_holder());
 498     resolve_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, true, false, CHECK);
 499     return;
 500   }
 501 
 502   resolve_klass(resolved_klass, pool, index, CHECK);
 503 
 504   Symbol*  method_name       = pool-&gt;name_ref_at(index);
 505   Symbol*  method_signature  = pool-&gt;signature_ref_at(index);
 506   KlassHandle  current_klass(THREAD, pool-&gt;pool_holder());
 507 
 508   if (pool-&gt;has_preresolution()
 509       || (resolved_klass() == SystemDictionary::MethodHandle_klass() &amp;&amp;
 510           MethodHandles::is_signature_polymorphic_name(resolved_klass(), method_name))) {
 511     Method* result_oop = ConstantPool::method_at_if_loaded(pool, index);
 512     if (result_oop != NULL) {
 513       resolved_method = methodHandle(THREAD, result_oop);
 514       return;
 515     }
 516   }
 517 
 518   if (code == Bytecodes::_invokeinterface) {
 519     resolve_interface_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, true, true, CHECK);
 520   } else if (code == Bytecodes::_invokevirtual) {
 521     resolve_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, true, true, CHECK);
 522   } else if (!resolved_klass-&gt;is_interface()) {
 523     resolve_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, true, false, CHECK);
 524   } else {
 525     bool nostatics = (code == Bytecodes::_invokestatic) ? false : true;
 526     resolve_interface_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, true, nostatics, CHECK);
 527   }
 528 }
 529 
 530 void LinkResolver::resolve_method(methodHandle&amp; resolved_method, KlassHandle resolved_klass,
 531                                   Symbol* method_name, Symbol* method_signature,
 532                                   KlassHandle current_klass, bool check_access,
 533                                   bool require_methodref, TRAPS) {
 534 
 535   Handle nested_exception;
 536 
 537   // 1. check if methodref required, that resolved_klass is not interfacemethodref
 538   if (require_methodref &amp;&amp; resolved_klass-&gt;is_interface()) {
 539     ResourceMark rm(THREAD);
 540     char buf[200];
 541     jio_snprintf(buf, sizeof(buf), "Found interface %s, but class was expected",
 542         resolved_klass()-&gt;external_name());
 543     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 544   }
 545 
 546   // 2. lookup method in resolved klass and its super klasses
 547   lookup_method_in_klasses(resolved_method, resolved_klass, method_name, method_signature, true, false, CHECK);
 548 
 549   if (resolved_method.is_null()) { // not found in the class hierarchy
 550     // 3. lookup method in all the interfaces implemented by the resolved klass
 551     lookup_method_in_interfaces(resolved_method, resolved_klass, method_name, method_signature, CHECK);
 552 
 553     if (resolved_method.is_null()) {
 554       // JSR 292:  see if this is an implicitly generated method MethodHandle.linkToVirtual(*...), etc
 555       lookup_polymorphic_method(resolved_method, resolved_klass, method_name, method_signature,
 556                                 current_klass, (Handle*)NULL, (Handle*)NULL, THREAD);
 557       if (HAS_PENDING_EXCEPTION) {
 558         nested_exception = Handle(THREAD, PENDING_EXCEPTION);
 559         CLEAR_PENDING_EXCEPTION;
 560       }
 561     }
 562 
 563     if (resolved_method.is_null()) {
 564       // 4. method lookup failed
 565       ResourceMark rm(THREAD);
 566       THROW_MSG_CAUSE(vmSymbols::java_lang_NoSuchMethodError(),
 567                       Method::name_and_sig_as_C_string(resolved_klass(),
 568                                                               method_name,
 569                                                               method_signature),
 570                       nested_exception);
 571     }
 572   }
 573 
 574   // 5. access checks, access checking may be turned off when calling from within the VM.
 575   if (check_access) {
 576     assert(current_klass.not_null() , "current_klass should not be null");
 577 
 578     // check if method can be accessed by the referring class
 579     check_method_accessability(current_klass,
 580                                resolved_klass,
 581                                KlassHandle(THREAD, resolved_method-&gt;method_holder()),
 582                                resolved_method,
 583                                CHECK);
 584 
 585     // check loader constraints
 586     Handle loader (THREAD, InstanceKlass::cast(current_klass())-&gt;class_loader());
 587     Handle class_loader (THREAD, resolved_method-&gt;method_holder()-&gt;class_loader());
 588     {
 589       ResourceMark rm(THREAD);
 590       Symbol* failed_type_symbol =
 591         SystemDictionary::check_signature_loaders(method_signature, loader,
 592                                                   class_loader, true, CHECK);
 593       if (failed_type_symbol != NULL) {
 594         const char* msg = "loader constraint violation: when resolving method"
 595           " \"%s\" the class loader (instance of %s) of the current class, %s,"
 596           " and the class loader (instance of %s) for the method's defining class, %s, have"
 597           " different Class objects for the type %s used in the signature";
 598         char* sig = Method::name_and_sig_as_C_string(resolved_klass(),method_name,method_signature);
 599         const char* loader1 = SystemDictionary::loader_name(loader());
 600         char* current = InstanceKlass::cast(current_klass())-&gt;name()-&gt;as_C_string();
 601         const char* loader2 = SystemDictionary::loader_name(class_loader());
 602         char* target = InstanceKlass::cast(resolved_method-&gt;method_holder())
 603                        -&gt;name()-&gt;as_C_string();
 604         char* failed_type_name = failed_type_symbol-&gt;as_C_string();
 605         size_t buflen = strlen(msg) + strlen(sig) + strlen(loader1) +
 606           strlen(current) + strlen(loader2) + strlen(target) +
 607           strlen(failed_type_name) + 1;
 608         char* buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, buflen);
 609         jio_snprintf(buf, buflen, msg, sig, loader1, current, loader2,
 610                      target, failed_type_name);
 611         THROW_MSG(vmSymbols::java_lang_LinkageError(), buf);
 612       }
 613     }
 614   }
 615 }
 616 
 617 void LinkResolver::resolve_interface_method(methodHandle&amp; resolved_method,
 618                                             KlassHandle resolved_klass,
 619                                             Symbol* method_name,
 620                                             Symbol* method_signature,
 621                                             KlassHandle current_klass,
 622                                             bool check_access,
 623                                             bool nostatics, TRAPS) {
 624 
 625   // check if klass is interface
 626   if (!resolved_klass-&gt;is_interface()) {
 627     ResourceMark rm(THREAD);
 628     char buf[200];
 629     jio_snprintf(buf, sizeof(buf), "Found class %s, but interface was expected", resolved_klass()-&gt;external_name());
 630     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 631   }
 632 
 633   // lookup method in this interface or its super, java.lang.Object
 634   // JDK8: also look for static methods
 635   lookup_method_in_klasses(resolved_method, resolved_klass, method_name, method_signature, false, true, CHECK);
 636 
 637   if (resolved_method.is_null()) {
 638     // lookup method in all the super-interfaces
 639     lookup_method_in_interfaces(resolved_method, resolved_klass, method_name, method_signature, CHECK);
 640     if (resolved_method.is_null()) {
 641       // no method found
 642       ResourceMark rm(THREAD);
 643       THROW_MSG(vmSymbols::java_lang_NoSuchMethodError(),
 644                 Method::name_and_sig_as_C_string(resolved_klass(),
 645                                                         method_name,
 646                                                         method_signature));
 647     }
 648   }
 649 
 650   if (check_access) {
 651     // JDK8 adds non-public interface methods, and accessability check requirement
 652     assert(current_klass.not_null() , "current_klass should not be null");
 653 
 654     // check if method can be accessed by the referring class
 655     check_method_accessability(current_klass,
 656                                resolved_klass,
 657                                KlassHandle(THREAD, resolved_method-&gt;method_holder()),
 658                                resolved_method,
 659                                CHECK);
 660 
 661     HandleMark hm(THREAD);
 662     Handle loader (THREAD, InstanceKlass::cast(current_klass())-&gt;class_loader());
 663     Handle class_loader (THREAD, resolved_method-&gt;method_holder()-&gt;class_loader());
 664     {
 665       ResourceMark rm(THREAD);
 666       Symbol* failed_type_symbol =
 667         SystemDictionary::check_signature_loaders(method_signature, loader,
 668                                                   class_loader, true, CHECK);
 669       if (failed_type_symbol != NULL) {
 670         const char* msg = "loader constraint violation: when resolving "
 671           "interface method \"%s\" the class loader (instance of %s) of the "
 672           "current class, %s, and the class loader (instance of %s) for "
 673           "the method's defining class, %s, have different Class objects for the type %s "
 674           "used in the signature";
 675         char* sig = Method::name_and_sig_as_C_string(resolved_klass(),method_name,method_signature);
 676         const char* loader1 = SystemDictionary::loader_name(loader());
 677         char* current = InstanceKlass::cast(current_klass())-&gt;name()-&gt;as_C_string();
 678         const char* loader2 = SystemDictionary::loader_name(class_loader());
 679         char* target = InstanceKlass::cast(resolved_method-&gt;method_holder())
 680                        -&gt;name()-&gt;as_C_string();
 681         char* failed_type_name = failed_type_symbol-&gt;as_C_string();
 682         size_t buflen = strlen(msg) + strlen(sig) + strlen(loader1) +
 683           strlen(current) + strlen(loader2) + strlen(target) +
 684           strlen(failed_type_name) + 1;
 685         char* buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, buflen);
 686         jio_snprintf(buf, buflen, msg, sig, loader1, current, loader2,
 687                      target, failed_type_name);
 688         THROW_MSG(vmSymbols::java_lang_LinkageError(), buf);
 689       }
 690     }
 691   }
 692 
 693   if (nostatics &amp;&amp; resolved_method-&gt;is_static()) {
 694     ResourceMark rm(THREAD);
 695     char buf[200];
 696     jio_snprintf(buf, sizeof(buf), "Expected instance not static method %s",
 697                  Method::name_and_sig_as_C_string(resolved_klass(),
 698                  resolved_method-&gt;name(), resolved_method-&gt;signature()));
 699     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 700   }
 701 
 702   if (TraceItables &amp;&amp; Verbose) {
 703     ResourceMark rm(THREAD);
 704     tty-&gt;print("invokeinterface resolved method: caller-class:%s, compile-time-class:%s, method:%s, method_holder:%s, access_flags: ",
 705                    (current_klass.is_null() ? "&lt;NULL&gt;" : current_klass-&gt;internal_name()),
 706                    (resolved_klass.is_null() ? "&lt;NULL&gt;" : resolved_klass-&gt;internal_name()),
 707                    Method::name_and_sig_as_C_string(resolved_klass(),
 708                                                     resolved_method-&gt;name(),
 709                                                     resolved_method-&gt;signature()),
 710                    resolved_method-&gt;method_holder()-&gt;internal_name()
 711                   );
 712     resolved_method-&gt;access_flags().print_on(tty);
 713     if (resolved_method-&gt;is_default_method()) {
 714       tty-&gt;print("default ");
 715     }
 716     if (resolved_method-&gt;is_overpass()) {
 717       tty-&gt;print("overpass");
 718     }
 719     tty-&gt;cr();
 720   }
 721 }
 722 
 723 //------------------------------------------------------------------------------------------------------------------------
 724 // Field resolution
 725 
 726 void LinkResolver::check_field_accessability(KlassHandle ref_klass,
 727                                              KlassHandle resolved_klass,
 728                                              KlassHandle sel_klass,
 729                                              fieldDescriptor&amp; fd,
 730                                              TRAPS) {
 731   if (!Reflection::verify_field_access(ref_klass(),
 732                                        resolved_klass(),
 733                                        sel_klass(),
 734                                        fd.access_flags(),
 735                                        true)) {
 736     ResourceMark rm(THREAD);
 737     Exceptions::fthrow(
 738       THREAD_AND_LOCATION,
 739       vmSymbols::java_lang_IllegalAccessError(),
 740       "tried to access field %s.%s from class %s",
 741       sel_klass-&gt;external_name(),
 742       fd.name()-&gt;as_C_string(),
 743       ref_klass-&gt;external_name()
 744     );
 745     return;
 746   }
 747 }
 748 
 749 void LinkResolver::resolve_field_access(fieldDescriptor&amp; result, constantPoolHandle pool, int index, Bytecodes::Code byte, TRAPS) {
 750   // Load these early in case the resolve of the containing klass fails
 751   Symbol* field = pool-&gt;name_ref_at(index);
 752   Symbol* sig   = pool-&gt;signature_ref_at(index);
 753 
 754   // resolve specified klass
 755   KlassHandle resolved_klass;
 756   resolve_klass(resolved_klass, pool, index, CHECK);
 757 
 758   KlassHandle  current_klass(THREAD, pool-&gt;pool_holder());
 759   resolve_field(result, resolved_klass, field, sig, current_klass, byte, true, true, CHECK);
 760 }
 761 
 762 void LinkResolver::resolve_field(fieldDescriptor&amp; fd, KlassHandle resolved_klass, Symbol* field, Symbol* sig,
 763                                  KlassHandle current_klass, Bytecodes::Code byte, bool check_access, bool initialize_class,
 764                                  TRAPS) {
 765   assert(byte == Bytecodes::_getstatic || byte == Bytecodes::_putstatic ||
 766          byte == Bytecodes::_getfield  || byte == Bytecodes::_putfield  ||
 767          (byte == Bytecodes::_nop &amp;&amp; !check_access), "bad field access bytecode");
 768 
 769   bool is_static = (byte == Bytecodes::_getstatic || byte == Bytecodes::_putstatic);
 770   bool is_put    = (byte == Bytecodes::_putfield  || byte == Bytecodes::_putstatic);
 771 
 772   // Check if there's a resolved klass containing the field
 773   if (resolved_klass.is_null()) {
 774     ResourceMark rm(THREAD);
 775     THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), field-&gt;as_C_string());
 776   }
 777 
 778   // Resolve instance field
 779   KlassHandle sel_klass(THREAD, InstanceKlass::cast(resolved_klass())-&gt;find_field(field, sig, &amp;fd));
 780   // check if field exists; i.e., if a klass containing the field def has been selected
 781   if (sel_klass.is_null()) {
 782     ResourceMark rm(THREAD);
 783     THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), field-&gt;as_C_string());
 784   }
 785 
 786   if (!check_access)
 787     // Access checking may be turned off when calling from within the VM.
 788     return;
 789 
 790   // check access
 791   check_field_accessability(current_klass, resolved_klass, sel_klass, fd, CHECK);
 792 
 793   // check for errors
 794   if (is_static != fd.is_static()) {
 795     ResourceMark rm(THREAD);
 796     char msg[200];
 797     jio_snprintf(msg, sizeof(msg), "Expected %s field %s.%s", is_static ? "static" : "non-static", resolved_klass()-&gt;external_name(), fd.name()-&gt;as_C_string());
 798     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);
 799   }
 800 
 801   // Final fields can only be accessed from its own class.
 802   if (is_put &amp;&amp; fd.access_flags().is_final() &amp;&amp; sel_klass() != current_klass()) {
 803     THROW(vmSymbols::java_lang_IllegalAccessError());
 804   }
 805 
 806   // initialize resolved_klass if necessary
 807   // note 1: the klass which declared the field must be initialized (i.e, sel_klass)
 808   //         according to the newest JVM spec (5.5, p.170) - was bug (gri 7/28/99)
 809   //
 810   // note 2: we don't want to force initialization if we are just checking
 811   //         if the field access is legal; e.g., during compilation
 812   if (is_static &amp;&amp; initialize_class) {
 813     sel_klass-&gt;initialize(CHECK);
 814   }
 815 
 816   if (sel_klass() != current_klass()) {
 817     HandleMark hm(THREAD);
 818     Handle ref_loader (THREAD, InstanceKlass::cast(current_klass())-&gt;class_loader());
 819     Handle sel_loader (THREAD, InstanceKlass::cast(sel_klass())-&gt;class_loader());
 820     {
 821       ResourceMark rm(THREAD);
 822       Symbol* failed_type_symbol =
 823         SystemDictionary::check_signature_loaders(sig,
 824                                                   ref_loader, sel_loader,
 825                                                   false,
 826                                                   CHECK);
 827       if (failed_type_symbol != NULL) {
 828         const char* msg = "loader constraint violation: when resolving field"
 829           " \"%s\" the class loader (instance of %s) of the referring class, "
 830           "%s, and the class loader (instance of %s) for the field's resolved "
 831           "type, %s, have different Class objects for that type";
 832         char* field_name = field-&gt;as_C_string();
 833         const char* loader1 = SystemDictionary::loader_name(ref_loader());
 834         char* sel = InstanceKlass::cast(sel_klass())-&gt;name()-&gt;as_C_string();
 835         const char* loader2 = SystemDictionary::loader_name(sel_loader());
 836         char* failed_type_name = failed_type_symbol-&gt;as_C_string();
 837         size_t buflen = strlen(msg) + strlen(field_name) + strlen(loader1) +
 838           strlen(sel) + strlen(loader2) + strlen(failed_type_name) + 1;
 839         char* buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, buflen);
 840         jio_snprintf(buf, buflen, msg, field_name, loader1, sel, loader2,
 841                      failed_type_name);
 842         THROW_MSG(vmSymbols::java_lang_LinkageError(), buf);
 843       }
 844     }
 845   }
 846 
 847   // return information. note that the klass is set to the actual klass containing the
 848   // field, otherwise access of static fields in superclasses will not work.
 849 }
 850 
 851 
 852 //------------------------------------------------------------------------------------------------------------------------
 853 // Invoke resolution
 854 //
 855 // Naming conventions:
 856 //
 857 // resolved_method    the specified method (i.e., static receiver specified via constant pool index)
 858 // sel_method         the selected method  (selected via run-time lookup; e.g., based on dynamic receiver class)
 859 // resolved_klass     the specified klass  (i.e., specified via constant pool index)
 860 // recv_klass         the receiver klass
 861 
 862 
 863 void LinkResolver::resolve_static_call(CallInfo&amp; result, KlassHandle&amp; resolved_klass, Symbol* method_name,
 864                                        Symbol* method_signature, KlassHandle current_klass,
 865                                        bool check_access, bool initialize_class, TRAPS) {
 866   methodHandle resolved_method;
 867   linktime_resolve_static_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, check_access, CHECK);
 868   resolved_klass = KlassHandle(THREAD, resolved_method-&gt;method_holder());
 869 
 870   // Initialize klass (this should only happen if everything is ok)
 871   if (initialize_class &amp;&amp; resolved_klass-&gt;should_be_initialized()) {
 872     resolved_klass-&gt;initialize(CHECK);
 873     linktime_resolve_static_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, check_access, CHECK);
 874   }
 875 
 876   // setup result
 877   result.set_static(resolved_klass, resolved_method, CHECK);
 878 }
 879 
 880 // throws linktime exceptions
 881 void LinkResolver::linktime_resolve_static_method(methodHandle&amp; resolved_method, KlassHandle resolved_klass,
 882                                                   Symbol* method_name, Symbol* method_signature,
 883                                                   KlassHandle current_klass, bool check_access, TRAPS) {
 884 
 885   if (!resolved_klass-&gt;is_interface()) {
 886     resolve_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, check_access, false, CHECK);
 887   } else {
 888     resolve_interface_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, check_access, false, CHECK);
 889   }
 890   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name(), "should have been checked in verifier");
 891 
 892   // check if static
 893   if (!resolved_method-&gt;is_static()) {
 894     ResourceMark rm(THREAD);
 895     char buf[200];
 896     jio_snprintf(buf, sizeof(buf), "Expected static method %s", Method::name_and_sig_as_C_string(resolved_klass(),
 897                                                       resolved_method-&gt;name(),
 898                                                       resolved_method-&gt;signature()));
 899     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 900   }
 901 }
 902 
 903 
 904 void LinkResolver::resolve_special_call(CallInfo&amp; result, KlassHandle resolved_klass, Symbol* method_name,
 905                                         Symbol* method_signature, KlassHandle current_klass, bool check_access, TRAPS) {
 906   methodHandle resolved_method;
 907   linktime_resolve_special_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, check_access, CHECK);
 908   runtime_resolve_special_method(result, resolved_method, resolved_klass, current_klass, check_access, CHECK);
 909 }
 910 
 911 // throws linktime exceptions
 912 void LinkResolver::linktime_resolve_special_method(methodHandle&amp; resolved_method, KlassHandle resolved_klass,
 913                                                    Symbol* method_name, Symbol* method_signature,
 914                                                    KlassHandle current_klass, bool check_access, TRAPS) {
 915 
 916   // Invokespecial is called for multiple special reasons:
 917   // &lt;init&gt;
 918   // local private method invocation, for classes and interfaces
 919   // superclass.method, which can also resolve to a default method
 920   // and the selected method is recalculated relative to the direct superclass
 921   // superinterface.method, which explicitly does not check shadowing
 922 
 923   if (!resolved_klass-&gt;is_interface()) {
 924     resolve_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, check_access, false, CHECK);
 925   } else {
 926     resolve_interface_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, check_access, true, CHECK);
 927   }
 928 
 929   // check if method name is &lt;init&gt;, that it is found in same klass as static type
 930   if (resolved_method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
 931       resolved_method-&gt;method_holder() != resolved_klass()) {
 932     ResourceMark rm(THREAD);
 933     Exceptions::fthrow(
 934       THREAD_AND_LOCATION,
 935       vmSymbols::java_lang_NoSuchMethodError(),
 936       "%s: method %s%s not found",
 937       resolved_klass-&gt;external_name(),
 938       resolved_method-&gt;name()-&gt;as_C_string(),
 939       resolved_method-&gt;signature()-&gt;as_C_string()
 940     );
 941     return;
 942   }
 943 
 944   // check if invokespecial's interface method reference is in an indirect superinterface
 945   if (!current_klass.is_null() &amp;&amp; resolved_klass-&gt;is_interface()) {
 946     Klass *klass_to_check = !InstanceKlass::cast(current_klass())-&gt;is_anonymous() ?
 947                                   current_klass() :
 948                                   InstanceKlass::cast(current_klass())-&gt;host_klass();
 949     // As of the fix for 4486457 we disable verification for all of the
 950     // dynamically-generated bytecodes associated with the 1.4
 951     // reflection implementation, not just those associated with
 952     // sun/reflect/SerializationConstructorAccessor.
 953     bool is_reflect = JDK_Version::is_gte_jdk14x_version() &amp;&amp;
 954                       klass_to_check-&gt;is_subclass_of(
 955                         SystemDictionary::reflect_MagicAccessorImpl_klass());
 956 
 957     if (!is_reflect &amp;&amp;
 958         !InstanceKlass::cast(klass_to_check)-&gt;is_same_or_direct_interface(resolved_klass())) {
 959       ResourceMark rm(THREAD);
 960       char buf[200];
 961       jio_snprintf(buf, sizeof(buf),
 962                    "Interface method reference: %s, is in an indirect superinterface of %s",
 963                    Method::name_and_sig_as_C_string(resolved_klass(),
 964                                                          resolved_method-&gt;name(),
 965                                                          resolved_method-&gt;signature()),
 966                    current_klass-&gt;external_name());
 967       THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 968     }
 969   }
 970 
 971   // check if not static
 972   if (resolved_method-&gt;is_static()) {
 973     ResourceMark rm(THREAD);
 974     char buf[200];
 975     jio_snprintf(buf, sizeof(buf),
 976                  "Expecting non-static method %s",
 977                  Method::name_and_sig_as_C_string(resolved_klass(),
 978                                                          resolved_method-&gt;name(),
 979                                                          resolved_method-&gt;signature()));
 980     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
 981   }
 982 
 983   if (TraceItables &amp;&amp; Verbose) {
 984     ResourceMark rm(THREAD);
 985     tty-&gt;print("invokespecial resolved method: caller-class:%s, compile-time-class:%s, method:%s, method_holder:%s, access_flags: ",
 986                 (current_klass.is_null() ? "&lt;NULL&gt;" : current_klass-&gt;internal_name()),
 987                 (resolved_klass.is_null() ? "&lt;NULL&gt;" : resolved_klass-&gt;internal_name()),
 988                 Method::name_and_sig_as_C_string(resolved_klass(),
 989                                                  resolved_method-&gt;name(),
 990                                                  resolved_method-&gt;signature()),
 991                 resolved_method-&gt;method_holder()-&gt;internal_name()
 992                );
 993     resolved_method-&gt;access_flags().print_on(tty);
 994     if (resolved_method-&gt;is_default_method()) {
 995       tty-&gt;print("default ");
 996     }
 997     if (resolved_method-&gt;is_overpass()) {
 998       tty-&gt;print("overpass");
 999     }
1000     tty-&gt;cr();
1001   }
1002 }
1003 
1004 // throws runtime exceptions
1005 void LinkResolver::runtime_resolve_special_method(CallInfo&amp; result, methodHandle resolved_method, KlassHandle resolved_klass,
1006                                                   KlassHandle current_klass, bool check_access, TRAPS) {
1007 
1008   // resolved method is selected method unless we have an old-style lookup
1009   // for a superclass method
1010   // Invokespecial for a superinterface, resolved method is selected method,
1011   // no checks for shadowing
1012   methodHandle sel_method(THREAD, resolved_method());
1013 
1014   // check if this is an old-style super call and do a new lookup if so
1015   { KlassHandle method_klass  = KlassHandle(THREAD,
1016                                             resolved_method-&gt;method_holder());
1017 
1018     if (check_access &amp;&amp;
1019         // a) check if ACC_SUPER flag is set for the current class
1020         (current_klass-&gt;is_super() || !AllowNonVirtualCalls) &amp;&amp;
1021         // b) check if the class of the resolved_klass is a superclass
1022         // (not supertype in order to exclude interface classes) of the current class.
1023         // This check is not performed for super.invoke for interface methods
1024         // in super interfaces.
1025         current_klass-&gt;is_subclass_of(resolved_klass()) &amp;&amp;
1026         current_klass() != resolved_klass() &amp;&amp;
1027         // c) check if the method is not &lt;init&gt;
1028         resolved_method-&gt;name() != vmSymbols::object_initializer_name()) {
1029       // Lookup super method
1030       KlassHandle super_klass(THREAD, current_klass-&gt;super());
1031       lookup_instance_method_in_klasses(sel_method, super_klass,
1032                            resolved_method-&gt;name(),
1033                            resolved_method-&gt;signature(), CHECK);
1034       // check if found
1035       if (sel_method.is_null()) {
1036         ResourceMark rm(THREAD);
1037         THROW_MSG(vmSymbols::java_lang_AbstractMethodError(),
1038                   Method::name_and_sig_as_C_string(resolved_klass(),
1039                                             resolved_method-&gt;name(),
1040                                             resolved_method-&gt;signature()));
1041       }
1042     }
1043   }
1044 
1045   // check if not static
1046   if (sel_method-&gt;is_static()) {
1047     ResourceMark rm(THREAD);
1048     char buf[200];
1049     jio_snprintf(buf, sizeof(buf), "Expecting non-static method %s", Method::name_and_sig_as_C_string(resolved_klass(),
1050                                                                                                              resolved_method-&gt;name(),
1051                                                                                                              resolved_method-&gt;signature()));
1052     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
1053   }
1054 
1055   // check if abstract
1056   if (sel_method-&gt;is_abstract()) {
1057     ResourceMark rm(THREAD);
1058     THROW_MSG(vmSymbols::java_lang_AbstractMethodError(),
1059               Method::name_and_sig_as_C_string(resolved_klass(),
1060                                                       sel_method-&gt;name(),
1061                                                       sel_method-&gt;signature()));
1062   }
1063 
1064   if (TraceItables &amp;&amp; Verbose) {
1065     ResourceMark rm(THREAD);
1066     tty-&gt;print("invokespecial selected method: resolved-class:%s, method:%s, method_holder:%s, access_flags: ",
1067                  (resolved_klass.is_null() ? "&lt;NULL&gt;" : resolved_klass-&gt;internal_name()),
1068                  Method::name_and_sig_as_C_string(resolved_klass(),
1069                                                   sel_method-&gt;name(),
1070                                                   sel_method-&gt;signature()),
1071                  sel_method-&gt;method_holder()-&gt;internal_name()
1072                 );
1073     sel_method-&gt;access_flags().print_on(tty);
1074     if (sel_method-&gt;is_default_method()) {
1075       tty-&gt;print("default ");
1076     }
1077     if (sel_method-&gt;is_overpass()) {
1078       tty-&gt;print("overpass");
1079     }
1080     tty-&gt;cr();
1081   }
1082 
1083   // setup result
1084   result.set_static(resolved_klass, sel_method, CHECK);
1085 }
1086 
1087 void LinkResolver::resolve_virtual_call(CallInfo&amp; result, Handle recv, KlassHandle receiver_klass, KlassHandle resolved_klass,
1088                                         Symbol* method_name, Symbol* method_signature, KlassHandle current_klass,
1089                                         bool check_access, bool check_null_and_abstract, TRAPS) {
1090   methodHandle resolved_method;
1091   linktime_resolve_virtual_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, check_access, CHECK);
1092   runtime_resolve_virtual_method(result, resolved_method, resolved_klass, recv, receiver_klass, check_null_and_abstract, CHECK);
1093 }
1094 
1095 // throws linktime exceptions
1096 void LinkResolver::linktime_resolve_virtual_method(methodHandle &amp;resolved_method, KlassHandle resolved_klass,
1097                                                    Symbol* method_name, Symbol* method_signature,
1098                                                    KlassHandle current_klass, bool check_access, TRAPS) {
1099   // normal method resolution
1100   resolve_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, check_access, true, CHECK);
1101 
1102   assert(resolved_method-&gt;name() != vmSymbols::object_initializer_name(), "should have been checked in verifier");
1103   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name (), "should have been checked in verifier");
1104 
1105   // check if private interface method
1106   if (resolved_klass-&gt;is_interface() &amp;&amp; resolved_method-&gt;is_private()) {
1107     ResourceMark rm(THREAD);
1108     char buf[200];
1109     jio_snprintf(buf, sizeof(buf), "private interface method requires invokespecial, not invokevirtual: method %s, caller-class:%s",
1110                  Method::name_and_sig_as_C_string(resolved_klass(),
1111                                                   resolved_method-&gt;name(),
1112                                                   resolved_method-&gt;signature()),
1113                    (current_klass.is_null() ? "&lt;NULL&gt;" : current_klass-&gt;internal_name()));
1114     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
1115   }
1116 
1117   // check if not static
1118   if (resolved_method-&gt;is_static()) {
1119     ResourceMark rm(THREAD);
1120     char buf[200];
1121     jio_snprintf(buf, sizeof(buf), "Expecting non-static method %s", Method::name_and_sig_as_C_string(resolved_klass(),
1122                                                                                                              resolved_method-&gt;name(),
1123                                                                                                              resolved_method-&gt;signature()));
1124     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
1125   }
1126 
1127   if (PrintVtables &amp;&amp; Verbose) {
1128     ResourceMark rm(THREAD);
1129     tty-&gt;print("invokevirtual resolved method: caller-class:%s, compile-time-class:%s, method:%s, method_holder:%s, access_flags: ",
1130                    (current_klass.is_null() ? "&lt;NULL&gt;" : current_klass-&gt;internal_name()),
1131                    (resolved_klass.is_null() ? "&lt;NULL&gt;" : resolved_klass-&gt;internal_name()),
1132                    Method::name_and_sig_as_C_string(resolved_klass(),
1133                                                     resolved_method-&gt;name(),
1134                                                     resolved_method-&gt;signature()),
1135                    resolved_method-&gt;method_holder()-&gt;internal_name()
1136                   );
1137     resolved_method-&gt;access_flags().print_on(tty);
1138     if (resolved_method-&gt;is_default_method()) {
1139       tty-&gt;print("default ");
1140     }
1141     if (resolved_method-&gt;is_overpass()) {
1142       tty-&gt;print("overpass");
1143     }
1144     tty-&gt;cr();
1145   }
1146 }
1147 
1148 // throws runtime exceptions
1149 void LinkResolver::runtime_resolve_virtual_method(CallInfo&amp; result,
1150                                                   methodHandle resolved_method,
1151                                                   KlassHandle resolved_klass,
1152                                                   Handle recv,
1153                                                   KlassHandle recv_klass,
1154                                                   bool check_null_and_abstract,
1155                                                   TRAPS) {
1156 
1157   // setup default return values
1158   int vtable_index = Method::invalid_vtable_index;
1159   methodHandle selected_method;
1160 
1161   assert(recv.is_null() || recv-&gt;is_oop(), "receiver is not an oop");
1162 
1163   // runtime method resolution
1164   if (check_null_and_abstract &amp;&amp; recv.is_null()) { // check if receiver exists
1165     THROW(vmSymbols::java_lang_NullPointerException());
1166   }
1167 
1168   // Virtual methods cannot be resolved before its klass has been linked, for otherwise the Method*'s
1169   // has not been rewritten, and the vtable initialized. Make sure to do this after the nullcheck, since
1170   // a missing receiver might result in a bogus lookup.
1171   assert(resolved_method-&gt;method_holder()-&gt;is_linked(), "must be linked");
1172 
1173   // do lookup based on receiver klass using the vtable index
1174   if (resolved_method-&gt;method_holder()-&gt;is_interface()) { // miranda method
1175     vtable_index = vtable_index_of_interface_method(resolved_klass,
1176                            resolved_method);
1177     assert(vtable_index &gt;= 0 , "we should have valid vtable index at this point");
1178 
1179     InstanceKlass* inst = InstanceKlass::cast(recv_klass());
1180     selected_method = methodHandle(THREAD, inst-&gt;method_at_vtable(vtable_index));
1181   } else {
1182     // at this point we are sure that resolved_method is virtual and not
1183     // a miranda method; therefore, it must have a valid vtable index.
1184     assert(!resolved_method-&gt;has_itable_index(), "");
1185     vtable_index = resolved_method-&gt;vtable_index();
1186     // We could get a negative vtable_index for final methods,
1187     // because as an optimization they are they are never put in the vtable,
1188     // unless they override an existing method.
1189     // If we do get a negative, it means the resolved method is the the selected
1190     // method, and it can never be changed by an override.
1191     if (vtable_index == Method::nonvirtual_vtable_index) {
1192       assert(resolved_method-&gt;can_be_statically_bound(), "cannot override this method");
1193       selected_method = resolved_method;
1194     } else {
1195       // recv_klass might be an arrayKlassOop but all vtables start at
1196       // the same place. The cast is to avoid virtual call and assertion.
1197       InstanceKlass* inst = (InstanceKlass*)recv_klass();
1198       selected_method = methodHandle(THREAD, inst-&gt;method_at_vtable(vtable_index));
1199     }
1200   }
1201 
1202   // check if method exists
1203   if (selected_method.is_null()) {
1204     ResourceMark rm(THREAD);
1205     THROW_MSG(vmSymbols::java_lang_AbstractMethodError(),
1206               Method::name_and_sig_as_C_string(resolved_klass(),
1207                                                       resolved_method-&gt;name(),
1208                                                       resolved_method-&gt;signature()));
1209   }
1210 
1211   // check if abstract
1212   if (check_null_and_abstract &amp;&amp; selected_method-&gt;is_abstract()) {
1213     ResourceMark rm(THREAD);
1214     THROW_MSG(vmSymbols::java_lang_AbstractMethodError(),
1215               Method::name_and_sig_as_C_string(resolved_klass(),
1216                                                       selected_method-&gt;name(),
1217                                                       selected_method-&gt;signature()));
1218   }
1219 
1220   if (PrintVtables &amp;&amp; Verbose) {
1221     ResourceMark rm(THREAD);
1222     tty-&gt;print("invokevirtual selected method: receiver-class:%s, resolved-class:%s, method:%s, method_holder:%s, vtable_index:%d, access_flags: ",
1223                    (recv_klass.is_null() ? "&lt;NULL&gt;" : recv_klass-&gt;internal_name()),
1224                    (resolved_klass.is_null() ? "&lt;NULL&gt;" : resolved_klass-&gt;internal_name()),
1225                    Method::name_and_sig_as_C_string(resolved_klass(),
1226                                                     resolved_method-&gt;name(),
1227                                                     resolved_method-&gt;signature()),
1228                    selected_method-&gt;method_holder()-&gt;internal_name(),
1229                    vtable_index
1230                   );
1231     selected_method-&gt;access_flags().print_on(tty);
1232     if (selected_method-&gt;is_default_method()) {
1233       tty-&gt;print("default ");
1234     }
1235     if (selected_method-&gt;is_overpass()) {
1236       tty-&gt;print("overpass");
1237     }
1238     tty-&gt;cr();
1239   }
1240   // setup result
1241   result.set_virtual(resolved_klass, recv_klass, resolved_method, selected_method, vtable_index, CHECK);
1242 }
1243 
1244 void LinkResolver::resolve_interface_call(CallInfo&amp; result, Handle recv, KlassHandle recv_klass, KlassHandle resolved_klass,
1245                                           Symbol* method_name, Symbol* method_signature, KlassHandle current_klass,
1246                                           bool check_access, bool check_null_and_abstract, TRAPS) {
1247   methodHandle resolved_method;
1248   linktime_resolve_interface_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, check_access, CHECK);
1249   runtime_resolve_interface_method(result, resolved_method, resolved_klass, recv, recv_klass, check_null_and_abstract, CHECK);
1250 }
1251 
1252 // throws linktime exceptions
1253 void LinkResolver::linktime_resolve_interface_method(methodHandle&amp; resolved_method, KlassHandle resolved_klass, Symbol* method_name,
1254                                                      Symbol* method_signature, KlassHandle current_klass, bool check_access, TRAPS) {
1255   // normal interface method resolution
1256   resolve_interface_method(resolved_method, resolved_klass, method_name, method_signature, current_klass, check_access, true, CHECK);
1257 
1258   assert(resolved_method-&gt;name() != vmSymbols::object_initializer_name(), "should have been checked in verifier");
1259   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name (), "should have been checked in verifier");
1260 }
1261 
1262 // throws runtime exceptions
1263 void LinkResolver::runtime_resolve_interface_method(CallInfo&amp; result, methodHandle resolved_method, KlassHandle resolved_klass,
1264                                                     Handle recv, KlassHandle recv_klass, bool check_null_and_abstract, TRAPS) {
1265   // check if receiver exists
1266   if (check_null_and_abstract &amp;&amp; recv.is_null()) {
1267     THROW(vmSymbols::java_lang_NullPointerException());
1268   }
1269 
1270   // check if private interface method
1271   if (resolved_klass-&gt;is_interface() &amp;&amp; resolved_method-&gt;is_private()) {
1272     ResourceMark rm(THREAD);
1273     char buf[200];
1274     jio_snprintf(buf, sizeof(buf), "private interface method requires invokespecial, not invokeinterface: method %s",
1275                  Method::name_and_sig_as_C_string(resolved_klass(),
1276                                                   resolved_method-&gt;name(),
1277                                                   resolved_method-&gt;signature()));
1278     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
1279   }
1280 
1281   // check if receiver klass implements the resolved interface
1282   if (!recv_klass-&gt;is_subtype_of(resolved_klass())) {
1283     ResourceMark rm(THREAD);
1284     char buf[200];
1285     jio_snprintf(buf, sizeof(buf), "Class %s does not implement the requested interface %s",
1286                  recv_klass()-&gt;external_name(),
1287                  resolved_klass()-&gt;external_name());
1288     THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);
1289   }
1290 
1291   // do lookup based on receiver klass
1292   methodHandle sel_method;
1293   // This search must match the linktime preparation search for itable initialization
1294   // to correctly enforce loader constraints for interface method inheritance
1295   lookup_instance_method_in_klasses(sel_method, recv_klass,
1296             resolved_method-&gt;name(),
1297             resolved_method-&gt;signature(), CHECK);
1298   if (sel_method.is_null() &amp;&amp; !check_null_and_abstract) {
1299     // In theory this is a harmless placeholder value, but
1300     // in practice leaving in null affects the nsk default method tests.
1301     // This needs further study.
1302     sel_method = resolved_method;
1303   }
1304   // check if method exists
1305   if (sel_method.is_null()) {
1306     ResourceMark rm(THREAD);
1307     THROW_MSG(vmSymbols::java_lang_AbstractMethodError(),
1308               Method::name_and_sig_as_C_string(recv_klass(),
1309                                                       resolved_method-&gt;name(),
1310                                                       resolved_method-&gt;signature()));
1311   }
1312   // check access
1313   // Throw Illegal Access Error if sel_method is not public.
1314   if (!sel_method-&gt;is_public()) {
1315     ResourceMark rm(THREAD);
1316     THROW_MSG(vmSymbols::java_lang_IllegalAccessError(),
1317               Method::name_and_sig_as_C_string(recv_klass(),
1318                                                sel_method-&gt;name(),
1319                                                sel_method-&gt;signature()));
1320   }
1321   // check if abstract
1322   if (check_null_and_abstract &amp;&amp; sel_method-&gt;is_abstract()) {
1323     ResourceMark rm(THREAD);
1324     THROW_MSG(vmSymbols::java_lang_AbstractMethodError(),
1325               Method::name_and_sig_as_C_string(recv_klass(),
1326                                                       sel_method-&gt;name(),
1327                                                       sel_method-&gt;signature()));
1328   }
1329 
1330   if (TraceItables &amp;&amp; Verbose) {
1331     ResourceMark rm(THREAD);
1332     tty-&gt;print("invokeinterface selected method: receiver-class:%s, resolved-class:%s, method:%s, method_holder:%s, access_flags: ",
1333                    (recv_klass.is_null() ? "&lt;NULL&gt;" : recv_klass-&gt;internal_name()),
1334                    (resolved_klass.is_null() ? "&lt;NULL&gt;" : resolved_klass-&gt;internal_name()),
1335                    Method::name_and_sig_as_C_string(resolved_klass(),
1336                                                     resolved_method-&gt;name(),
1337                                                     resolved_method-&gt;signature()),
1338                    sel_method-&gt;method_holder()-&gt;internal_name()
1339                   );
1340     sel_method-&gt;access_flags().print_on(tty);
1341     if (sel_method-&gt;is_default_method()) {
1342       tty-&gt;print("default ");
1343     }
1344     if (sel_method-&gt;is_overpass()) {
1345       tty-&gt;print("overpass");
1346     }
1347     tty-&gt;cr();
1348   }
1349   // setup result
1350   if (!resolved_method-&gt;has_itable_index()) {
1351     int vtable_index = resolved_method-&gt;vtable_index();
1352     assert(vtable_index == sel_method-&gt;vtable_index(), "sanity check");
1353     result.set_virtual(resolved_klass, recv_klass, resolved_method, sel_method, vtable_index, CHECK);
1354   } else {
1355     int itable_index = resolved_method()-&gt;itable_index();
1356     result.set_interface(resolved_klass, recv_klass, resolved_method, sel_method, itable_index, CHECK);
1357   }
1358 }
1359 
1360 
1361 methodHandle LinkResolver::linktime_resolve_interface_method_or_null(
1362                                                  KlassHandle resolved_klass,
1363                                                  Symbol* method_name,
1364                                                  Symbol* method_signature,
1365                                                  KlassHandle current_klass,
1366                                                  bool check_access) {
1367   EXCEPTION_MARK;
1368   methodHandle method_result;
1369   linktime_resolve_interface_method(method_result, resolved_klass, method_name, method_signature, current_klass, check_access, THREAD);
1370   if (HAS_PENDING_EXCEPTION) {
1371     CLEAR_PENDING_EXCEPTION;
1372     return methodHandle();
1373   } else {
1374     return method_result;
1375   }
1376 }
1377 
1378 methodHandle LinkResolver::linktime_resolve_virtual_method_or_null(
1379                                                  KlassHandle resolved_klass,
1380                                                  Symbol* method_name,
1381                                                  Symbol* method_signature,
1382                                                  KlassHandle current_klass,
1383                                                  bool check_access) {
1384   EXCEPTION_MARK;
1385   methodHandle method_result;
1386   linktime_resolve_virtual_method(method_result, resolved_klass, method_name, method_signature, current_klass, check_access, THREAD);
1387   if (HAS_PENDING_EXCEPTION) {
1388     CLEAR_PENDING_EXCEPTION;
1389     return methodHandle();
1390   } else {
1391     return method_result;
1392   }
1393 }
1394 
1395 methodHandle LinkResolver::resolve_virtual_call_or_null(
1396                                                  KlassHandle receiver_klass,
1397                                                  KlassHandle resolved_klass,
1398                                                  Symbol* name,
1399                                                  Symbol* signature,
1400                                                  KlassHandle current_klass) {
1401   EXCEPTION_MARK;
1402   CallInfo info;
1403   resolve_virtual_call(info, Handle(), receiver_klass, resolved_klass, name, signature, current_klass, true, false, THREAD);
1404   if (HAS_PENDING_EXCEPTION) {
1405     CLEAR_PENDING_EXCEPTION;
1406     return methodHandle();
1407   }
1408   return info.selected_method();
1409 }
1410 
1411 methodHandle LinkResolver::resolve_interface_call_or_null(
1412                                                  KlassHandle receiver_klass,
1413                                                  KlassHandle resolved_klass,
1414                                                  Symbol* name,
1415                                                  Symbol* signature,
1416                                                  KlassHandle current_klass) {
1417   EXCEPTION_MARK;
1418   CallInfo info;
1419   resolve_interface_call(info, Handle(), receiver_klass, resolved_klass, name, signature, current_klass, true, false, THREAD);
1420   if (HAS_PENDING_EXCEPTION) {
1421     CLEAR_PENDING_EXCEPTION;
1422     return methodHandle();
1423   }
1424   return info.selected_method();
1425 }
1426 
1427 int LinkResolver::resolve_virtual_vtable_index(
1428                                                KlassHandle receiver_klass,
1429                                                KlassHandle resolved_klass,
1430                                                Symbol* name,
1431                                                Symbol* signature,
1432                                                KlassHandle current_klass) {
1433   EXCEPTION_MARK;
1434   CallInfo info;
1435   resolve_virtual_call(info, Handle(), receiver_klass, resolved_klass, name, signature, current_klass, true, false, THREAD);
1436   if (HAS_PENDING_EXCEPTION) {
1437     CLEAR_PENDING_EXCEPTION;
1438     return Method::invalid_vtable_index;
1439   }
1440   return info.vtable_index();
1441 }
1442 
1443 methodHandle LinkResolver::resolve_static_call_or_null(
1444                                                   KlassHandle resolved_klass,
1445                                                   Symbol* name,
1446                                                   Symbol* signature,
1447                                                   KlassHandle current_klass) {
1448   EXCEPTION_MARK;
1449   CallInfo info;
1450   resolve_static_call(info, resolved_klass, name, signature, current_klass, true, false, THREAD);
1451   if (HAS_PENDING_EXCEPTION) {
1452     CLEAR_PENDING_EXCEPTION;
1453     return methodHandle();
1454   }
1455   return info.selected_method();
1456 }
1457 
1458 methodHandle LinkResolver::resolve_special_call_or_null(KlassHandle resolved_klass, Symbol* name, Symbol* signature,
1459                                                         KlassHandle current_klass) {
1460   EXCEPTION_MARK;
1461   CallInfo info;
1462   resolve_special_call(info, resolved_klass, name, signature, current_klass, true, THREAD);
1463   if (HAS_PENDING_EXCEPTION) {
1464     CLEAR_PENDING_EXCEPTION;
1465     return methodHandle();
1466   }
1467   return info.selected_method();
1468 }
1469 
1470 
1471 
1472 //------------------------------------------------------------------------------------------------------------------------
1473 // ConstantPool entries
1474 
1475 void LinkResolver::resolve_invoke(CallInfo&amp; result, Handle recv, constantPoolHandle pool, int index, Bytecodes::Code byte, TRAPS) {
1476   switch (byte) {
1477     case Bytecodes::_invokestatic   : resolve_invokestatic   (result,       pool, index, CHECK); break;
1478     case Bytecodes::_invokespecial  : resolve_invokespecial  (result,       pool, index, CHECK); break;
1479     case Bytecodes::_invokevirtual  : resolve_invokevirtual  (result, recv, pool, index, CHECK); break;
1480     case Bytecodes::_invokehandle   : resolve_invokehandle   (result,       pool, index, CHECK); break;
1481     case Bytecodes::_invokedynamic  : resolve_invokedynamic  (result,       pool, index, CHECK); break;
1482     case Bytecodes::_invokeinterface: resolve_invokeinterface(result, recv, pool, index, CHECK); break;
1483   }
1484   return;
1485 }
1486 
1487 void LinkResolver::resolve_pool(KlassHandle&amp; resolved_klass, Symbol*&amp; method_name, Symbol*&amp; method_signature,
1488                                 KlassHandle&amp; current_klass, constantPoolHandle pool, int index, TRAPS) {
1489    // resolve klass
1490   resolve_klass(resolved_klass, pool, index, CHECK);
1491 
1492   // Get name, signature, and static klass
1493   method_name      = pool-&gt;name_ref_at(index);
1494   method_signature = pool-&gt;signature_ref_at(index);
1495   current_klass    = KlassHandle(THREAD, pool-&gt;pool_holder());
1496 }
1497 
1498 
1499 void LinkResolver::resolve_invokestatic(CallInfo&amp; result, constantPoolHandle pool, int index, TRAPS) {
1500   KlassHandle  resolved_klass;
1501   Symbol* method_name = NULL;
1502   Symbol* method_signature = NULL;
1503   KlassHandle  current_klass;
1504   resolve_pool(resolved_klass, method_name,  method_signature, current_klass, pool, index, CHECK);
1505   resolve_static_call(result, resolved_klass, method_name, method_signature, current_klass, true, true, CHECK);
1506 }
1507 
1508 
1509 void LinkResolver::resolve_invokespecial(CallInfo&amp; result, constantPoolHandle pool, int index, TRAPS) {
1510   KlassHandle  resolved_klass;
1511   Symbol* method_name = NULL;
1512   Symbol* method_signature = NULL;
1513   KlassHandle  current_klass;
1514   resolve_pool(resolved_klass, method_name,  method_signature, current_klass, pool, index, CHECK);
1515   resolve_special_call(result, resolved_klass, method_name, method_signature, current_klass, true, CHECK);
1516 }
1517 
1518 
1519 void LinkResolver::resolve_invokevirtual(CallInfo&amp; result, Handle recv,
1520                                           constantPoolHandle pool, int index,
1521                                           TRAPS) {
1522 
1523   KlassHandle  resolved_klass;
1524   Symbol* method_name = NULL;
1525   Symbol* method_signature = NULL;
1526   KlassHandle  current_klass;
1527   resolve_pool(resolved_klass, method_name,  method_signature, current_klass, pool, index, CHECK);
1528   KlassHandle recvrKlass (THREAD, recv.is_null() ? (Klass*)NULL : recv-&gt;klass());
1529   resolve_virtual_call(result, recv, recvrKlass, resolved_klass, method_name, method_signature, current_klass, true, true, CHECK);
1530 }
1531 
1532 
1533 void LinkResolver::resolve_invokeinterface(CallInfo&amp; result, Handle recv, constantPoolHandle pool, int index, TRAPS) {
1534   KlassHandle  resolved_klass;
1535   Symbol* method_name = NULL;
1536   Symbol* method_signature = NULL;
1537   KlassHandle  current_klass;
1538   resolve_pool(resolved_klass, method_name,  method_signature, current_klass, pool, index, CHECK);
1539   KlassHandle recvrKlass (THREAD, recv.is_null() ? (Klass*)NULL : recv-&gt;klass());
1540   resolve_interface_call(result, recv, recvrKlass, resolved_klass, method_name, method_signature, current_klass, true, true, CHECK);
1541 }
1542 
1543 
1544 void LinkResolver::resolve_invokehandle(CallInfo&amp; result, constantPoolHandle pool, int index, TRAPS) {
1545   assert(EnableInvokeDynamic, "");
1546   // This guy is reached from InterpreterRuntime::resolve_invokehandle.
1547   KlassHandle  resolved_klass;
1548   Symbol* method_name = NULL;
1549   Symbol* method_signature = NULL;
1550   KlassHandle  current_klass;
1551   resolve_pool(resolved_klass, method_name,  method_signature, current_klass, pool, index, CHECK);
1552   if (TraceMethodHandles) {
1553     ResourceMark rm(THREAD);
1554     tty-&gt;print_cr("resolve_invokehandle %s %s", method_name-&gt;as_C_string(), method_signature-&gt;as_C_string());
1555   }
1556   resolve_handle_call(result, resolved_klass, method_name, method_signature, current_klass, CHECK);
1557 }
1558 
1559 void LinkResolver::resolve_handle_call(CallInfo&amp; result, KlassHandle resolved_klass,
1560                                        Symbol* method_name, Symbol* method_signature,
1561                                        KlassHandle current_klass,
1562                                        TRAPS) {
1563   // JSR 292:  this must be an implicitly generated method MethodHandle.invokeExact(*...) or similar
1564   assert(resolved_klass() == SystemDictionary::MethodHandle_klass(), "");
1565   assert(MethodHandles::is_signature_polymorphic_name(method_name), "");
1566   methodHandle resolved_method;
1567   Handle       resolved_appendix;
1568   Handle       resolved_method_type;
1569   lookup_polymorphic_method(resolved_method, resolved_klass,
1570                             method_name, method_signature,
1571                             current_klass, &amp;resolved_appendix, &amp;resolved_method_type, CHECK);
1572   result.set_handle(resolved_method, resolved_appendix, resolved_method_type, CHECK);
1573 }
1574 
1575 
1576 void LinkResolver::resolve_invokedynamic(CallInfo&amp; result, constantPoolHandle pool, int index, TRAPS) {
1577   assert(EnableInvokeDynamic, "");
1578 
1579   //resolve_pool(&lt;resolved_klass&gt;, method_name, method_signature, current_klass, pool, index, CHECK);
1580   Symbol* method_name       = pool-&gt;name_ref_at(index);
1581   Symbol* method_signature  = pool-&gt;signature_ref_at(index);
1582   KlassHandle current_klass = KlassHandle(THREAD, pool-&gt;pool_holder());
1583 
1584   // Resolve the bootstrap specifier (BSM + optional arguments).
1585   Handle bootstrap_specifier;
1586   // Check if CallSite has been bound already:
1587   ConstantPoolCacheEntry* cpce = pool-&gt;invokedynamic_cp_cache_entry_at(index);
1588   if (cpce-&gt;is_f1_null()) {
1589     int pool_index = cpce-&gt;constant_pool_index();
1590     oop bsm_info = pool-&gt;resolve_bootstrap_specifier_at(pool_index, CHECK);
1591     assert(bsm_info != NULL, "");
1592     // FIXME: Cache this once per BootstrapMethods entry, not once per CONSTANT_InvokeDynamic.
1593     bootstrap_specifier = Handle(THREAD, bsm_info);
1594   }
1595   if (!cpce-&gt;is_f1_null()) {
1596     methodHandle method(     THREAD, cpce-&gt;f1_as_method());
1597     Handle       appendix(   THREAD, cpce-&gt;appendix_if_resolved(pool));
1598     Handle       method_type(THREAD, cpce-&gt;method_type_if_resolved(pool));
1599     result.set_handle(method, appendix, method_type, CHECK);
1600     return;
1601   }
1602 
1603   if (TraceMethodHandles) {
1604       ResourceMark rm(THREAD);
1605       tty-&gt;print_cr("resolve_invokedynamic #%d %s %s",
1606                   ConstantPool::decode_invokedynamic_index(index),
1607                   method_name-&gt;as_C_string(), method_signature-&gt;as_C_string());
1608     tty-&gt;print("  BSM info: "); bootstrap_specifier-&gt;print();
1609   }
1610 
1611   resolve_dynamic_call(result, bootstrap_specifier, method_name, method_signature, current_klass, CHECK);
1612 }
1613 
1614 void LinkResolver::resolve_dynamic_call(CallInfo&amp; result,
1615                                         Handle bootstrap_specifier,
1616                                         Symbol* method_name, Symbol* method_signature,
1617                                         KlassHandle current_klass,
1618                                         TRAPS) {
1619   // JSR 292:  this must resolve to an implicitly generated method MH.linkToCallSite(*...)
1620   // The appendix argument is likely to be a freshly-created CallSite.
1621   Handle       resolved_appendix;
1622   Handle       resolved_method_type;
1623   methodHandle resolved_method =
1624     SystemDictionary::find_dynamic_call_site_invoker(current_klass,
1625                                                      bootstrap_specifier,
1626                                                      method_name, method_signature,
1627                                                      &amp;resolved_appendix,
1628                                                      &amp;resolved_method_type,
1629                                                      THREAD);
1630   if (HAS_PENDING_EXCEPTION) {
1631     if (TraceMethodHandles) {
1632       tty-&gt;print_cr("invokedynamic throws BSME for "INTPTR_FORMAT, (void *)PENDING_EXCEPTION);
1633       PENDING_EXCEPTION-&gt;print();
1634     }
1635     if (PENDING_EXCEPTION-&gt;is_a(SystemDictionary::BootstrapMethodError_klass())) {
1636       // throw these guys, since they are already wrapped
1637       return;
1638     }
1639     if (!PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass())) {
1640       // intercept only LinkageErrors which might have failed to wrap
1641       return;
1642     }
1643     // See the "Linking Exceptions" section for the invokedynamic instruction in the JVMS.
1644     Handle nested_exception(THREAD, PENDING_EXCEPTION);
1645     CLEAR_PENDING_EXCEPTION;
1646     THROW_CAUSE(vmSymbols::java_lang_BootstrapMethodError(), nested_exception)
1647   }
1648   result.set_handle(resolved_method, resolved_appendix, resolved_method_type, CHECK);
1649 }
1650 
1651 //------------------------------------------------------------------------------------------------------------------------
1652 #ifndef PRODUCT
1653 
1654 void CallInfo::print() {
1655   ResourceMark rm;
1656   const char* kindstr = "unknown";
1657   switch (_call_kind) {
1658   case direct_call: kindstr = "direct"; break;
1659   case vtable_call: kindstr = "vtable"; break;
1660   case itable_call: kindstr = "itable"; break;
1661   }
1662   tty-&gt;print_cr("Call %s@%d %s", kindstr, _call_index,
1663                 _resolved_method.is_null() ? "(none)" : _resolved_method-&gt;name_and_sig_as_C_string());
1664 }
1665 
1666 #endif
</pre></body></html>
