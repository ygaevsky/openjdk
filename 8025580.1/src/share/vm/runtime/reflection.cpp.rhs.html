<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 #include "classfile/javaClasses.hpp"
  27 #include "classfile/symbolTable.hpp"
  28 #include "classfile/systemDictionary.hpp"
  29 #include "classfile/verifier.hpp"
  30 #include "classfile/vmSymbols.hpp"
  31 #include "interpreter/linkResolver.hpp"
  32 #include "memory/oopFactory.hpp"
  33 #include "memory/resourceArea.hpp"
  34 #include "memory/universe.inline.hpp"
  35 #include "oops/instanceKlass.hpp"
  36 #include "oops/objArrayKlass.hpp"
  37 #include "oops/objArrayOop.hpp"
  38 #include "prims/jvm.h"
  39 #include "prims/jvmtiExport.hpp"
  40 #include "runtime/arguments.hpp"
  41 #include "runtime/handles.inline.hpp"
  42 #include "runtime/javaCalls.hpp"
  43 #include "runtime/reflection.hpp"
  44 #include "runtime/reflectionUtils.hpp"
  45 #include "runtime/signature.hpp"
  46 #include "runtime/vframe.hpp"
  47 
  48 static void trace_class_resolution(Klass* to_class) {
  49   ResourceMark rm;
  50   int line_number = -1;
  51   const char * source_file = NULL;
  52   Klass* caller = NULL;
  53   JavaThread* jthread = JavaThread::current();
  54   if (jthread-&gt;has_last_Java_frame()) {
  55     vframeStream vfst(jthread);
  56     // skip over any frames belonging to java.lang.Class
  57     while (!vfst.at_end() &amp;&amp;
  58            vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class()) {
  59       vfst.next();
  60     }
  61     if (!vfst.at_end()) {
  62       // this frame is a likely suspect
  63       caller = vfst.method()-&gt;method_holder();
  64       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
  65       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
  66       if (s != NULL) {
  67         source_file = s-&gt;as_C_string();
  68       }
  69     }
  70   }
  71   if (caller != NULL) {
  72     const char * from = caller-&gt;external_name();
  73     const char * to = to_class-&gt;external_name();
  74     // print in a single call to reduce interleaving between threads
  75     if (source_file != NULL) {
  76       tty-&gt;print("RESOLVE %s %s %s:%d (reflection)\n", from, to, source_file, line_number);
  77     } else {
  78       tty-&gt;print("RESOLVE %s %s (reflection)\n", from, to);
  79     }
  80   }
  81 }
  82 
  83 
  84 oop Reflection::box(jvalue* value, BasicType type, TRAPS) {
  85   if (type == T_VOID) {
  86     return NULL;
  87   }
  88   if (type == T_OBJECT || type == T_ARRAY) {
  89     // regular objects are not boxed
  90     return (oop) value-&gt;l;
  91   }
  92   oop result = java_lang_boxing_object::create(type, value, CHECK_NULL);
  93   if (result == NULL) {
  94     THROW_(vmSymbols::java_lang_IllegalArgumentException(), result);
  95   }
  96   return result;
  97 }
  98 
  99 
 100 BasicType Reflection::unbox_for_primitive(oop box, jvalue* value, TRAPS) {
 101   if (box == NULL) {
 102     THROW_(vmSymbols::java_lang_IllegalArgumentException(), T_ILLEGAL);
 103   }
 104   return java_lang_boxing_object::get_value(box, value);
 105 }
 106 
 107 BasicType Reflection::unbox_for_regular_object(oop box, jvalue* value) {
 108   // Note:  box is really the unboxed oop.  It might even be a Short, etc.!
 109   value-&gt;l = (jobject) box;
 110   return T_OBJECT;
 111 }
 112 
 113 
 114 void Reflection::widen(jvalue* value, BasicType current_type, BasicType wide_type, TRAPS) {
 115   assert(wide_type != current_type, "widen should not be called with identical types");
 116   switch (wide_type) {
 117     case T_BOOLEAN:
 118     case T_BYTE:
 119     case T_CHAR:
 120       break;  // fail
 121     case T_SHORT:
 122       switch (current_type) {
 123         case T_BYTE:
 124           value-&gt;s = (jshort) value-&gt;b;
 125           return;
 126       }
 127       break;  // fail
 128     case T_INT:
 129       switch (current_type) {
 130         case T_BYTE:
 131           value-&gt;i = (jint) value-&gt;b;
 132           return;
 133         case T_CHAR:
 134           value-&gt;i = (jint) value-&gt;c;
 135           return;
 136         case T_SHORT:
 137           value-&gt;i = (jint) value-&gt;s;
 138           return;
 139       }
 140       break;  // fail
 141     case T_LONG:
 142       switch (current_type) {
 143         case T_BYTE:
 144           value-&gt;j = (jlong) value-&gt;b;
 145           return;
 146         case T_CHAR:
 147           value-&gt;j = (jlong) value-&gt;c;
 148           return;
 149         case T_SHORT:
 150           value-&gt;j = (jlong) value-&gt;s;
 151           return;
 152         case T_INT:
 153           value-&gt;j = (jlong) value-&gt;i;
 154           return;
 155       }
 156       break;  // fail
 157     case T_FLOAT:
 158       switch (current_type) {
 159         case T_BYTE:
 160           value-&gt;f = (jfloat) value-&gt;b;
 161           return;
 162         case T_CHAR:
 163           value-&gt;f = (jfloat) value-&gt;c;
 164           return;
 165         case T_SHORT:
 166           value-&gt;f = (jfloat) value-&gt;s;
 167           return;
 168         case T_INT:
 169           value-&gt;f = (jfloat) value-&gt;i;
 170           return;
 171         case T_LONG:
 172           value-&gt;f = (jfloat) value-&gt;j;
 173           return;
 174       }
 175       break;  // fail
 176     case T_DOUBLE:
 177       switch (current_type) {
 178         case T_BYTE:
 179           value-&gt;d = (jdouble) value-&gt;b;
 180           return;
 181         case T_CHAR:
 182           value-&gt;d = (jdouble) value-&gt;c;
 183           return;
 184         case T_SHORT:
 185           value-&gt;d = (jdouble) value-&gt;s;
 186           return;
 187         case T_INT:
 188           value-&gt;d = (jdouble) value-&gt;i;
 189           return;
 190         case T_FLOAT:
 191           value-&gt;d = (jdouble) value-&gt;f;
 192           return;
 193         case T_LONG:
 194           value-&gt;d = (jdouble) value-&gt;j;
 195           return;
 196       }
 197       break;  // fail
 198     default:
 199       break;  // fail
 200   }
 201   THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), "argument type mismatch");
 202 }
 203 
 204 
 205 BasicType Reflection::array_get(jvalue* value, arrayOop a, int index, TRAPS) {
 206   if (!a-&gt;is_within_bounds(index)) {
 207     THROW_(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), T_ILLEGAL);
 208   }
 209   if (a-&gt;is_objArray()) {
 210     value-&gt;l = (jobject) objArrayOop(a)-&gt;obj_at(index);
 211     return T_OBJECT;
 212   } else {
 213     assert(a-&gt;is_typeArray(), "just checking");
 214     BasicType type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
 215     switch (type) {
 216       case T_BOOLEAN:
 217         value-&gt;z = typeArrayOop(a)-&gt;bool_at(index);
 218         break;
 219       case T_CHAR:
 220         value-&gt;c = typeArrayOop(a)-&gt;char_at(index);
 221         break;
 222       case T_FLOAT:
 223         value-&gt;f = typeArrayOop(a)-&gt;float_at(index);
 224         break;
 225       case T_DOUBLE:
 226         value-&gt;d = typeArrayOop(a)-&gt;double_at(index);
 227         break;
 228       case T_BYTE:
 229         value-&gt;b = typeArrayOop(a)-&gt;byte_at(index);
 230         break;
 231       case T_SHORT:
 232         value-&gt;s = typeArrayOop(a)-&gt;short_at(index);
 233         break;
 234       case T_INT:
 235         value-&gt;i = typeArrayOop(a)-&gt;int_at(index);
 236         break;
 237       case T_LONG:
 238         value-&gt;j = typeArrayOop(a)-&gt;long_at(index);
 239         break;
 240       default:
 241         return T_ILLEGAL;
 242     }
 243     return type;
 244   }
 245 }
 246 
 247 
 248 void Reflection::array_set(jvalue* value, arrayOop a, int index, BasicType value_type, TRAPS) {
 249   if (!a-&gt;is_within_bounds(index)) {
 250     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
 251   }
 252   if (a-&gt;is_objArray()) {
 253     if (value_type == T_OBJECT) {
 254       oop obj = (oop) value-&gt;l;
 255       if (obj != NULL) {
 256         Klass* element_klass = ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass();
 257         if (!obj-&gt;is_a(element_klass)) {
 258           THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), "array element type mismatch");
 259         }
 260       }
 261       objArrayOop(a)-&gt;obj_at_put(index, obj);
 262     }
 263   } else {
 264     assert(a-&gt;is_typeArray(), "just checking");
 265     BasicType array_type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
 266     if (array_type != value_type) {
 267       // The widen operation can potentially throw an exception, but cannot block,
 268       // so typeArrayOop a is safe if the call succeeds.
 269       widen(value, value_type, array_type, CHECK);
 270     }
 271     switch (array_type) {
 272       case T_BOOLEAN:
 273         typeArrayOop(a)-&gt;bool_at_put(index, value-&gt;z);
 274         break;
 275       case T_CHAR:
 276         typeArrayOop(a)-&gt;char_at_put(index, value-&gt;c);
 277         break;
 278       case T_FLOAT:
 279         typeArrayOop(a)-&gt;float_at_put(index, value-&gt;f);
 280         break;
 281       case T_DOUBLE:
 282         typeArrayOop(a)-&gt;double_at_put(index, value-&gt;d);
 283         break;
 284       case T_BYTE:
 285         typeArrayOop(a)-&gt;byte_at_put(index, value-&gt;b);
 286         break;
 287       case T_SHORT:
 288         typeArrayOop(a)-&gt;short_at_put(index, value-&gt;s);
 289         break;
 290       case T_INT:
 291         typeArrayOop(a)-&gt;int_at_put(index, value-&gt;i);
 292         break;
 293       case T_LONG:
 294         typeArrayOop(a)-&gt;long_at_put(index, value-&gt;j);
 295         break;
 296       default:
 297         THROW(vmSymbols::java_lang_IllegalArgumentException());
 298     }
 299   }
 300 }
 301 
 302 
 303 Klass* Reflection::basic_type_mirror_to_arrayklass(oop basic_type_mirror, TRAPS) {
 304   assert(java_lang_Class::is_primitive(basic_type_mirror), "just checking");
 305   BasicType type = java_lang_Class::primitive_type(basic_type_mirror);
 306   if (type == T_VOID) {
 307     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 308   } else {
 309     return Universe::typeArrayKlassObj(type);
 310   }
 311 }
 312 
 313 
 314 oop Reflection:: basic_type_arrayklass_to_mirror(Klass* basic_type_arrayklass, TRAPS) {
 315   BasicType type = TypeArrayKlass::cast(basic_type_arrayklass)-&gt;element_type();
 316   return Universe::java_mirror(type);
 317 }
 318 
 319 
 320 arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) {
 321   if (element_mirror == NULL) {
 322     THROW_0(vmSymbols::java_lang_NullPointerException());
 323   }
 324   if (length &lt; 0) {
 325     THROW_0(vmSymbols::java_lang_NegativeArraySizeException());
 326   }
 327   if (java_lang_Class::is_primitive(element_mirror)) {
 328     Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
 329     return TypeArrayKlass::cast(tak)-&gt;allocate(length, THREAD);
 330   } else {
 331     Klass* k = java_lang_Class::as_Klass(element_mirror);
 332     if (k-&gt;oop_is_array() &amp;&amp; ArrayKlass::cast(k)-&gt;dimension() &gt;= MAX_DIM) {
 333       THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 334     }
 335     return oopFactory::new_objArray(k, length, THREAD);
 336   }
 337 }
 338 
 339 
 340 arrayOop Reflection::reflect_new_multi_array(oop element_mirror, typeArrayOop dim_array, TRAPS) {
 341   assert(dim_array-&gt;is_typeArray(), "just checking");
 342   assert(TypeArrayKlass::cast(dim_array-&gt;klass())-&gt;element_type() == T_INT, "just checking");
 343 
 344   if (element_mirror == NULL) {
 345     THROW_0(vmSymbols::java_lang_NullPointerException());
 346   }
 347 
 348   int len = dim_array-&gt;length();
 349   if (len &lt;= 0 || len &gt; MAX_DIM) {
 350     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 351   }
 352 
 353   jint dimensions[MAX_DIM];   // C array copy of intArrayOop
 354   for (int i = 0; i &lt; len; i++) {
 355     int d = dim_array-&gt;int_at(i);
 356     if (d &lt; 0) {
 357       THROW_0(vmSymbols::java_lang_NegativeArraySizeException());
 358     }
 359     dimensions[i] = d;
 360   }
 361 
 362   Klass* klass;
 363   int dim = len;
 364   if (java_lang_Class::is_primitive(element_mirror)) {
 365     klass = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
 366   } else {
 367     klass = java_lang_Class::as_Klass(element_mirror);
 368     if (klass-&gt;oop_is_array()) {
 369       int k_dim = ArrayKlass::cast(klass)-&gt;dimension();
 370       if (k_dim + len &gt; MAX_DIM) {
 371         THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 372       }
 373       dim += k_dim;
 374     }
 375   }
 376   klass = klass-&gt;array_klass(dim, CHECK_NULL);
 377   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(len, dimensions, CHECK_NULL);
 378   assert(obj-&gt;is_array(), "just checking");
 379   return arrayOop(obj);
 380 }
 381 
 382 
 383 oop Reflection::array_component_type(oop mirror, TRAPS) {
 384   if (java_lang_Class::is_primitive(mirror)) {
 385     return NULL;
 386   }
 387 
 388   Klass* klass = java_lang_Class::as_Klass(mirror);
 389   if (!klass-&gt;oop_is_array()) {
 390     return NULL;
 391   }
 392 
 393   oop result = ArrayKlass::cast(klass)-&gt;component_mirror();
 394 #ifdef ASSERT
 395   oop result2 = NULL;
 396   if (ArrayKlass::cast(klass)-&gt;dimension() == 1) {
 397     if (klass-&gt;oop_is_typeArray()) {
 398       result2 = basic_type_arrayklass_to_mirror(klass, CHECK_NULL);
 399     } else {
 400       result2 = ObjArrayKlass::cast(klass)-&gt;element_klass()-&gt;java_mirror();
 401     }
 402   } else {
 403     Klass* lower_dim = ArrayKlass::cast(klass)-&gt;lower_dimension();
 404     assert(lower_dim-&gt;oop_is_array(), "just checking");
 405     result2 = lower_dim-&gt;java_mirror();
 406   }
 407   assert(result == result2, "results must be consistent");
 408 #endif //ASSERT
 409   return result;
 410 }
 411 
 412 
 413 bool Reflection::reflect_check_access(Klass* field_class, AccessFlags acc, Klass* target_class, bool is_method_invoke, TRAPS) {
 414   // field_class  : declaring class
 415   // acc          : declared field access
 416   // target_class : for protected
 417 
 418   // Check if field or method is accessible to client.  Throw an
 419   // IllegalAccessException and return false if not.
 420 
 421   // The "client" is the class associated with the nearest real frame
 422   // getCallerClass already skips Method.invoke frames, so pass 0 in
 423   // that case (same as classic).
 424   ResourceMark rm(THREAD);
 425   assert(THREAD-&gt;is_Java_thread(), "sanity check");
 426   Klass* client_class = ((JavaThread *)THREAD)-&gt;security_get_caller_class(is_method_invoke ? 0 : 1);
 427 
 428   if (client_class != field_class) {
 429     if (!verify_class_access(client_class, field_class, false)
 430         || !verify_field_access(client_class,
 431                                 field_class,
 432                                 field_class,
 433                                 acc,
 434                                 false)) {
 435       THROW_(vmSymbols::java_lang_IllegalAccessException(), false);
 436     }
 437   }
 438 
 439   // Additional test for protected members: JLS 6.6.2
 440 
 441   if (acc.is_protected()) {
 442     if (target_class != client_class) {
 443       if (!is_same_class_package(client_class, field_class)) {
 444         if (!target_class-&gt;is_subclass_of(client_class)) {
 445           THROW_(vmSymbols::java_lang_IllegalAccessException(), false);
 446         }
 447       }
 448     }
 449   }
 450 
 451   // Passed all tests
 452   return true;
 453 }
 454 
 455 
 456 bool Reflection::verify_class_access(Klass* current_class, Klass* new_class, bool classloader_only) {
 457   // Verify that current_class can access new_class.  If the classloader_only
 458   // flag is set, we automatically allow any accesses in which current_class
 459   // doesn't have a classloader.
 460   if ((current_class == NULL) ||
 461       (current_class == new_class) ||
 462       (new_class-&gt;is_public()) ||
 463       is_same_class_package(current_class, new_class)) {
 464     return true;
 465   }
 466   // New (1.4) reflection implementation. Allow all accesses from
 467   // sun/reflect/MagicAccessorImpl subclasses to succeed trivially.
 468   if (   JDK_Version::is_gte_jdk14x_version()
<a name="1" id="anc1"></a>
 469       &amp;&amp; current_class-&gt;is_subclass_of(SystemDictionary::reflect_MagicAccessorImpl_klass())) {
 470     return true;
 471   }
 472 
 473   return can_relax_access_check_for(current_class, new_class, classloader_only);
 474 }
 475 
 476 static bool under_host_klass(InstanceKlass* ik, Klass* host_klass) {
 477   DEBUG_ONLY(int inf_loop_check = 1000 * 1000 * 1000);
 478   for (;;) {
 479     Klass* hc = (Klass*) ik-&gt;host_klass();
 480     if (hc == NULL)        return false;
 481     if (hc == host_klass)  return true;
 482     ik = InstanceKlass::cast(hc);
 483 
 484     // There's no way to make a host class loop short of patching memory.
 485     // Therefore there cannot be a loop here unless there's another bug.
 486     // Still, let's check for it.
 487     assert(--inf_loop_check &gt; 0, "no host_klass loop");
 488   }
 489 }
 490 
 491 bool Reflection::can_relax_access_check_for(
 492     Klass* accessor, Klass* accessee, bool classloader_only) {
 493   InstanceKlass* accessor_ik = InstanceKlass::cast(accessor);
 494   InstanceKlass* accessee_ik  = InstanceKlass::cast(accessee);
 495 
 496   // If either is on the other's host_klass chain, access is OK,
 497   // because one is inside the other.
 498   if (under_host_klass(accessor_ik, accessee) ||
 499       under_host_klass(accessee_ik, accessor))
 500     return true;
 501 
 502   if ((RelaxAccessControlCheck &amp;&amp;
 503         accessor_ik-&gt;major_version() &lt; Verifier::NO_RELAX_ACCESS_CTRL_CHECK_VERSION &amp;&amp;
 504         accessee_ik-&gt;major_version() &lt; Verifier::NO_RELAX_ACCESS_CTRL_CHECK_VERSION) ||
 505       (accessor_ik-&gt;major_version() &lt; Verifier::STRICTER_ACCESS_CTRL_CHECK_VERSION &amp;&amp;
 506        accessee_ik-&gt;major_version() &lt; Verifier::STRICTER_ACCESS_CTRL_CHECK_VERSION)) {
 507     return classloader_only &amp;&amp;
 508       Verifier::relax_verify_for(accessor_ik-&gt;class_loader()) &amp;&amp;
 509       accessor_ik-&gt;protection_domain() == accessee_ik-&gt;protection_domain() &amp;&amp;
 510       accessor_ik-&gt;class_loader() == accessee_ik-&gt;class_loader();
 511   } else {
 512     return false;
 513   }
 514 }
 515 
 516 bool Reflection::verify_field_access(Klass* current_class,
 517                                      Klass* resolved_class,
 518                                      Klass* field_class,
 519                                      AccessFlags access,
 520                                      bool classloader_only,
 521                                      bool protected_restriction) {
 522   // Verify that current_class can access a field of field_class, where that
 523   // field's access bits are "access".  We assume that we've already verified
 524   // that current_class can access field_class.
 525   //
 526   // If the classloader_only flag is set, we automatically allow any accesses
 527   // in which current_class doesn't have a classloader.
 528   //
 529   // "resolved_class" is the runtime type of "field_class". Sometimes we don't
 530   // need this distinction (e.g. if all we have is the runtime type, or during
 531   // class file parsing when we only care about the static type); in that case
 532   // callers should ensure that resolved_class == field_class.
 533   //
 534   if ((current_class == NULL) ||
 535       (current_class == field_class) ||
 536       access.is_public()) {
 537     return true;
 538   }
 539 
 540   Klass* host_class = current_class;
 541   while (host_class-&gt;oop_is_instance() &amp;&amp;
 542          InstanceKlass::cast(host_class)-&gt;is_anonymous()) {
 543     Klass* next_host_class = InstanceKlass::cast(host_class)-&gt;host_klass();
 544     if (next_host_class == NULL)  break;
 545     host_class = next_host_class;
 546   }
 547   if (host_class == field_class) {
 548     return true;
 549   }
 550 
 551   if (access.is_protected()) {
 552     if (!protected_restriction) {
 553       // See if current_class (or outermost host class) is a subclass of field_class
 554       if (host_class-&gt;is_subclass_of(field_class)) {
 555         if (access.is_static() || // static fields are ok, see 6622385
 556             current_class == resolved_class ||
 557             field_class == resolved_class ||
 558             host_class-&gt;is_subclass_of(resolved_class) ||
 559             resolved_class-&gt;is_subclass_of(host_class)) {
 560           return true;
 561         }
 562       }
 563     }
 564   }
 565 
 566   if (!access.is_private() &amp;&amp; is_same_class_package(current_class, field_class)) {
 567     return true;
 568   }
 569 
 570   // New (1.4) reflection implementation. Allow all accesses from
 571   // sun/reflect/MagicAccessorImpl subclasses to succeed trivially.
 572   if (   JDK_Version::is_gte_jdk14x_version()
<a name="2" id="anc2"></a>
 573       &amp;&amp; current_class-&gt;is_subclass_of(SystemDictionary::reflect_MagicAccessorImpl_klass())) {
 574     return true;
 575   }
 576 
 577   return can_relax_access_check_for(
 578     current_class, field_class, classloader_only);
 579 }
 580 
 581 
 582 bool Reflection::is_same_class_package(Klass* class1, Klass* class2) {
 583   return InstanceKlass::cast(class1)-&gt;is_same_class_package(class2);
 584 }
 585 
 586 bool Reflection::is_same_package_member(Klass* class1, Klass* class2, TRAPS) {
 587   return InstanceKlass::cast(class1)-&gt;is_same_package_member(class2, THREAD);
 588 }
 589 
 590 
 591 // Checks that the 'outer' klass has declared 'inner' as being an inner klass. If not,
 592 // throw an incompatible class change exception
 593 // If inner_is_member, require the inner to be a member of the outer.
 594 // If !inner_is_member, require the inner to be anonymous (a non-member).
 595 // Caller is responsible for figuring out in advance which case must be true.
 596 void Reflection::check_for_inner_class(instanceKlassHandle outer, instanceKlassHandle inner,
 597                                        bool inner_is_member, TRAPS) {
 598   InnerClassesIterator iter(outer);
 599   constantPoolHandle cp   (THREAD, outer-&gt;constants());
 600   for (; !iter.done(); iter.next()) {
 601      int ioff = iter.inner_class_info_index();
 602      int ooff = iter.outer_class_info_index();
 603 
 604      if (inner_is_member &amp;&amp; ioff != 0 &amp;&amp; ooff != 0) {
 605         Klass* o = cp-&gt;klass_at(ooff, CHECK);
 606         if (o == outer()) {
 607           Klass* i = cp-&gt;klass_at(ioff, CHECK);
 608           if (i == inner()) {
 609             return;
 610           }
 611         }
 612      }
 613      if (!inner_is_member &amp;&amp; ioff != 0 &amp;&amp; ooff == 0 &amp;&amp;
 614          cp-&gt;klass_name_at_matches(inner, ioff)) {
 615         Klass* i = cp-&gt;klass_at(ioff, CHECK);
 616         if (i == inner()) {
 617           return;
 618         }
 619      }
 620   }
 621 
 622   // 'inner' not declared as an inner klass in outer
 623   ResourceMark rm(THREAD);
 624   Exceptions::fthrow(
 625     THREAD_AND_LOCATION,
 626     vmSymbols::java_lang_IncompatibleClassChangeError(),
 627     "%s and %s disagree on InnerClasses attribute",
 628     outer-&gt;external_name(),
 629     inner-&gt;external_name()
 630   );
 631 }
 632 
 633 // Utility method converting a single SignatureStream element into java.lang.Class instance
 634 
 635 oop get_mirror_from_signature(methodHandle method, SignatureStream* ss, TRAPS) {
 636   switch (ss-&gt;type()) {
 637     default:
 638       assert(ss-&gt;type() != T_VOID || ss-&gt;at_return_type(), "T_VOID should only appear as return type");
 639       return java_lang_Class::primitive_mirror(ss-&gt;type());
 640     case T_OBJECT:
 641     case T_ARRAY:
 642       Symbol* name        = ss-&gt;as_symbol(CHECK_NULL);
 643       oop loader            = method-&gt;method_holder()-&gt;class_loader();
 644       oop protection_domain = method-&gt;method_holder()-&gt;protection_domain();
 645       Klass* k = SystemDictionary::resolve_or_fail(
 646                                        name,
 647                                        Handle(THREAD, loader),
 648                                        Handle(THREAD, protection_domain),
 649                                        true, CHECK_NULL);
 650       if (TraceClassResolution) {
 651         trace_class_resolution(k);
 652       }
 653       return k-&gt;java_mirror();
 654   };
 655 }
 656 
 657 
 658 objArrayHandle Reflection::get_parameter_types(methodHandle method, int parameter_count, oop* return_type, TRAPS) {
 659   // Allocate array holding parameter types (java.lang.Class instances)
 660   objArrayOop m = oopFactory::new_objArray(SystemDictionary::Class_klass(), parameter_count, CHECK_(objArrayHandle()));
 661   objArrayHandle mirrors (THREAD, m);
 662   int index = 0;
 663   // Collect parameter types
 664   ResourceMark rm(THREAD);
 665   Symbol*  signature  = method-&gt;signature();
 666   SignatureStream ss(signature);
 667   while (!ss.at_return_type()) {
 668     oop mirror = get_mirror_from_signature(method, &amp;ss, CHECK_(objArrayHandle()));
 669     mirrors-&gt;obj_at_put(index++, mirror);
 670     ss.next();
 671   }
 672   assert(index == parameter_count, "invalid parameter count");
 673   if (return_type != NULL) {
 674     // Collect return type as well
 675     assert(ss.at_return_type(), "return type should be present");
 676     *return_type = get_mirror_from_signature(method, &amp;ss, CHECK_(objArrayHandle()));
 677   }
 678   return mirrors;
 679 }
 680 
 681 objArrayHandle Reflection::get_exception_types(methodHandle method, TRAPS) {
 682   return method-&gt;resolved_checked_exceptions(CHECK_(objArrayHandle()));
 683 }
 684 
 685 
 686 Handle Reflection::new_type(Symbol* signature, KlassHandle k, TRAPS) {
 687   // Basic types
 688   BasicType type = vmSymbols::signature_type(signature);
 689   if (type != T_OBJECT) {
 690     return Handle(THREAD, Universe::java_mirror(type));
 691   }
 692 
 693   oop loader = InstanceKlass::cast(k())-&gt;class_loader();
 694   oop protection_domain = k()-&gt;protection_domain();
 695   Klass* result = SystemDictionary::resolve_or_fail(signature,
 696                                     Handle(THREAD, loader),
 697                                     Handle(THREAD, protection_domain),
 698                                     true, CHECK_(Handle()));
 699 
 700   if (TraceClassResolution) {
 701     trace_class_resolution(result);
 702   }
 703 
 704   oop nt = result-&gt;java_mirror();
 705   return Handle(THREAD, nt);
 706 }
 707 
 708 
<a name="3" id="anc3"></a><span class="changed"> 709 oop Reflection::new_method(methodHandle method, bool for_constant_pool_access, TRAPS) {</span>
 710   // In jdk1.2.x, getMethods on an interface erroneously includes &lt;clinit&gt;, thus the complicated assert.
 711   // Also allow sun.reflect.ConstantPool to refer to &lt;clinit&gt; methods as java.lang.reflect.Methods.
 712   assert(!method()-&gt;is_initializer() ||
 713          (for_constant_pool_access &amp;&amp; method()-&gt;is_static()) ||
 714          (method()-&gt;name() == vmSymbols::class_initializer_name()
 715     &amp;&amp; method()-&gt;method_holder()-&gt;is_interface() &amp;&amp; JDK_Version::is_jdk12x_version()), "should call new_constructor instead");
 716   instanceKlassHandle holder (THREAD, method-&gt;method_holder());
 717   int slot = method-&gt;method_idnum();
 718 
 719   Symbol*  signature  = method-&gt;signature();
 720   int parameter_count = ArgumentCount(signature).size();
 721   oop return_type_oop = NULL;
 722   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, &amp;return_type_oop, CHECK_NULL);
 723   if (parameter_types.is_null() || return_type_oop == NULL) return NULL;
 724 
 725   Handle return_type(THREAD, return_type_oop);
 726 
 727   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 728 
 729   if (exception_types.is_null()) return NULL;
 730 
 731   Symbol*  method_name = method-&gt;name();
<a name="4" id="anc4"></a>


 732   oop name_oop = StringTable::intern(method_name, CHECK_NULL);
<a name="5" id="anc5"></a><span class="changed"> 733   Handle name = Handle(THREAD, name_oop);</span>



 734   if (name == NULL) return NULL;
 735 
 736   int modifiers = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
 737 
 738   Handle mh = java_lang_reflect_Method::create(CHECK_NULL);
 739 
 740   java_lang_reflect_Method::set_clazz(mh(), holder-&gt;java_mirror());
 741   java_lang_reflect_Method::set_slot(mh(), slot);
 742   java_lang_reflect_Method::set_name(mh(), name());
 743   java_lang_reflect_Method::set_return_type(mh(), return_type());
 744   java_lang_reflect_Method::set_parameter_types(mh(), parameter_types());
 745   java_lang_reflect_Method::set_exception_types(mh(), exception_types());
 746   java_lang_reflect_Method::set_modifiers(mh(), modifiers);
 747   java_lang_reflect_Method::set_override(mh(), false);
 748   if (java_lang_reflect_Method::has_signature_field() &amp;&amp;
 749       method-&gt;generic_signature() != NULL) {
 750     Symbol*  gs = method-&gt;generic_signature();
 751     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 752     java_lang_reflect_Method::set_signature(mh(), sig());
 753   }
 754   if (java_lang_reflect_Method::has_annotations_field()) {
 755     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotations(), CHECK_NULL);
 756     java_lang_reflect_Method::set_annotations(mh(), an_oop);
 757   }
 758   if (java_lang_reflect_Method::has_parameter_annotations_field()) {
 759     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 760     java_lang_reflect_Method::set_parameter_annotations(mh(), an_oop);
 761   }
 762   if (java_lang_reflect_Method::has_annotation_default_field()) {
 763     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotation_default(), CHECK_NULL);
 764     java_lang_reflect_Method::set_annotation_default(mh(), an_oop);
 765   }
 766   if (java_lang_reflect_Method::has_type_annotations_field()) {
 767     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;type_annotations(), CHECK_NULL);
 768     java_lang_reflect_Method::set_type_annotations(mh(), an_oop);
 769   }
 770   return mh();
 771 }
 772 
 773 
 774 oop Reflection::new_constructor(methodHandle method, TRAPS) {
 775   assert(method()-&gt;is_initializer(), "should call new_method instead");
 776 
 777   instanceKlassHandle  holder (THREAD, method-&gt;method_holder());
 778   int slot = method-&gt;method_idnum();
 779 
 780   Symbol*  signature  = method-&gt;signature();
 781   int parameter_count = ArgumentCount(signature).size();
 782   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, NULL, CHECK_NULL);
 783   if (parameter_types.is_null()) return NULL;
 784 
 785   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 786   if (exception_types.is_null()) return NULL;
 787 
 788   int modifiers = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
 789 
 790   Handle ch = java_lang_reflect_Constructor::create(CHECK_NULL);
 791 
 792   java_lang_reflect_Constructor::set_clazz(ch(), holder-&gt;java_mirror());
 793   java_lang_reflect_Constructor::set_slot(ch(), slot);
 794   java_lang_reflect_Constructor::set_parameter_types(ch(), parameter_types());
 795   java_lang_reflect_Constructor::set_exception_types(ch(), exception_types());
 796   java_lang_reflect_Constructor::set_modifiers(ch(), modifiers);
 797   java_lang_reflect_Constructor::set_override(ch(), false);
 798   if (java_lang_reflect_Constructor::has_signature_field() &amp;&amp;
 799       method-&gt;generic_signature() != NULL) {
 800     Symbol*  gs = method-&gt;generic_signature();
 801     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 802     java_lang_reflect_Constructor::set_signature(ch(), sig());
 803   }
 804   if (java_lang_reflect_Constructor::has_annotations_field()) {
 805     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotations(), CHECK_NULL);
 806     java_lang_reflect_Constructor::set_annotations(ch(), an_oop);
 807   }
 808   if (java_lang_reflect_Constructor::has_parameter_annotations_field()) {
 809     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 810     java_lang_reflect_Constructor::set_parameter_annotations(ch(), an_oop);
 811   }
 812   if (java_lang_reflect_Constructor::has_type_annotations_field()) {
 813     typeArrayOop an_oop = Annotations::make_java_array(method-&gt;type_annotations(), CHECK_NULL);
 814     java_lang_reflect_Constructor::set_type_annotations(ch(), an_oop);
 815   }
 816   return ch();
 817 }
 818 
 819 
<a name="6" id="anc6"></a><span class="changed"> 820 oop Reflection::new_field(fieldDescriptor* fd, TRAPS) {</span>
 821   Symbol*  field_name = fd-&gt;name();
<a name="7" id="anc7"></a>


 822   oop name_oop = StringTable::intern(field_name, CHECK_NULL);
<a name="8" id="anc8"></a><span class="changed"> 823   Handle name = Handle(THREAD, name_oop);</span>



 824   Symbol*  signature  = fd-&gt;signature();
 825   instanceKlassHandle  holder    (THREAD, fd-&gt;field_holder());
 826   Handle type = new_type(signature, holder, CHECK_NULL);
 827   Handle rh  = java_lang_reflect_Field::create(CHECK_NULL);
 828 
 829   java_lang_reflect_Field::set_clazz(rh(), fd-&gt;field_holder()-&gt;java_mirror());
 830   java_lang_reflect_Field::set_slot(rh(), fd-&gt;index());
 831   java_lang_reflect_Field::set_name(rh(), name());
 832   java_lang_reflect_Field::set_type(rh(), type());
 833   // Note the ACC_ANNOTATION bit, which is a per-class access flag, is never set here.
 834   java_lang_reflect_Field::set_modifiers(rh(), fd-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS);
 835   java_lang_reflect_Field::set_override(rh(), false);
 836   if (java_lang_reflect_Field::has_signature_field() &amp;&amp;
 837       fd-&gt;has_generic_signature()) {
 838     Symbol*  gs = fd-&gt;generic_signature();
 839     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 840     java_lang_reflect_Field::set_signature(rh(), sig());
 841   }
 842   if (java_lang_reflect_Field::has_annotations_field()) {
 843     typeArrayOop an_oop = Annotations::make_java_array(fd-&gt;annotations(), CHECK_NULL);
 844     java_lang_reflect_Field::set_annotations(rh(), an_oop);
 845   }
 846   if (java_lang_reflect_Field::has_type_annotations_field()) {
 847     typeArrayOop an_oop = Annotations::make_java_array(fd-&gt;type_annotations(), CHECK_NULL);
 848     java_lang_reflect_Field::set_type_annotations(rh(), an_oop);
 849   }
 850   return rh();
 851 }
 852 
 853 oop Reflection::new_parameter(Handle method, int index, Symbol* sym,
 854                               int flags, TRAPS) {
 855   Handle name;
 856 
 857   // A null symbol here translates to the empty string
 858   if(NULL != sym) {
 859     name = java_lang_String::create_from_symbol(sym, CHECK_NULL);
 860   } else {
 861     name = java_lang_String::create_from_str("", CHECK_NULL);
 862   }
 863 
 864   Handle rh = java_lang_reflect_Parameter::create(CHECK_NULL);
 865   java_lang_reflect_Parameter::set_name(rh(), name());
 866   java_lang_reflect_Parameter::set_modifiers(rh(), flags);
 867   java_lang_reflect_Parameter::set_executable(rh(), method());
 868   java_lang_reflect_Parameter::set_index(rh(), index);
 869   return rh();
 870 }
 871 
 872 
 873 methodHandle Reflection::resolve_interface_call(instanceKlassHandle klass, methodHandle method,
 874                                                 KlassHandle recv_klass, Handle receiver, TRAPS) {
 875   assert(!method.is_null() , "method should not be null");
 876 
 877   CallInfo info;
 878   Symbol*  signature  = method-&gt;signature();
 879   Symbol*  name       = method-&gt;name();
 880   LinkResolver::resolve_interface_call(info, receiver, recv_klass, klass,
 881                                        name, signature,
 882                                        KlassHandle(), false, true,
 883                                        CHECK_(methodHandle()));
 884   return info.selected_method();
 885 }
 886 
 887 
 888 oop Reflection::invoke(instanceKlassHandle klass, methodHandle reflected_method,
 889                        Handle receiver, bool override, objArrayHandle ptypes,
 890                        BasicType rtype, objArrayHandle args, bool is_method_invoke, TRAPS) {
 891   ResourceMark rm(THREAD);
 892 
 893   methodHandle method;      // actual method to invoke
 894   KlassHandle target_klass; // target klass, receiver's klass for non-static
 895 
 896   // Ensure klass is initialized
 897   klass-&gt;initialize(CHECK_NULL);
 898 
 899   bool is_static = reflected_method-&gt;is_static();
 900   if (is_static) {
 901     // ignore receiver argument
 902     method = reflected_method;
 903     target_klass = klass;
 904   } else {
 905     // check for null receiver
 906     if (receiver.is_null()) {
 907       THROW_0(vmSymbols::java_lang_NullPointerException());
 908     }
 909     // Check class of receiver against class declaring method
 910     if (!receiver-&gt;is_a(klass())) {
 911       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "object is not an instance of declaring class");
 912     }
 913     // target klass is receiver's klass
 914     target_klass = KlassHandle(THREAD, receiver-&gt;klass());
 915     // no need to resolve if method is private or &lt;init&gt;
 916     if (reflected_method-&gt;is_private() || reflected_method-&gt;name() == vmSymbols::object_initializer_name()) {
 917       method = reflected_method;
 918     } else {
 919       // resolve based on the receiver
 920       if (reflected_method-&gt;method_holder()-&gt;is_interface()) {
 921         // resolve interface call
<a name="9" id="anc9"></a><span class="changed"> 922         //</span>

 923         // Match resolution errors with those thrown due to reflection inlining
 924         // Linktime resolution &amp; IllegalAccessCheck already done by Class.getMethod()
 925         method = resolve_interface_call(klass, reflected_method, target_klass, receiver, THREAD);
 926         if (HAS_PENDING_EXCEPTION) {
 927         // Method resolution threw an exception; wrap it in an InvocationTargetException
 928           oop resolution_exception = PENDING_EXCEPTION;
 929           CLEAR_PENDING_EXCEPTION;
 930           // JVMTI has already reported the pending exception
 931           // JVMTI internal flag reset is needed in order to report InvocationTargetException
 932           if (THREAD-&gt;is_Java_thread()) {
 933             JvmtiExport::clear_detected_exception((JavaThread*) THREAD);
 934           }
 935           JavaCallArguments args(Handle(THREAD, resolution_exception));
 936           THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
 937               vmSymbols::throwable_void_signature(),
 938               &amp;args);
 939         }
 940       }  else {
<a name="10" id="anc10"></a>


 941         // if the method can be overridden, we resolve using the vtable index.
 942         assert(!reflected_method-&gt;has_itable_index(), "");
 943         int index = reflected_method-&gt;vtable_index();
 944         method = reflected_method;
 945         if (index != Method::nonvirtual_vtable_index) {
 946           // target_klass might be an arrayKlassOop but all vtables start at
 947           // the same place. The cast is to avoid virtual call and assertion.
 948           InstanceKlass* inst = (InstanceKlass*)target_klass();
 949           method = methodHandle(THREAD, inst-&gt;method_at_vtable(index));
 950         }
 951         if (!method.is_null()) {
 952           // Check for abstract methods as well
 953           if (method-&gt;is_abstract()) {
 954             // new default: 6531596
<a name="11" id="anc11"></a>
 955             ResourceMark rm(THREAD);
 956             Handle h_origexception = Exceptions::new_exception(THREAD,
 957                    vmSymbols::java_lang_AbstractMethodError(),
 958                    Method::name_and_sig_as_C_string(target_klass(),
 959                    method-&gt;name(),
 960                    method-&gt;signature()));
 961             JavaCallArguments args(h_origexception);
 962             THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
 963               vmSymbols::throwable_void_signature(),
 964               &amp;args);
<a name="12" id="anc12"></a>






 965           }
 966         }
 967       }
 968     }
 969   }
 970 
 971   // I believe this is a ShouldNotGetHere case which requires
 972   // an internal vtable bug. If you ever get this please let Karen know.
 973   if (method.is_null()) {
 974     ResourceMark rm(THREAD);
 975     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(),
 976                 Method::name_and_sig_as_C_string(klass(),
 977                                                         reflected_method-&gt;name(),
 978                                                         reflected_method-&gt;signature()));
 979   }
 980 
 981   // In the JDK 1.4 reflection implementation, the security check is
 982   // done at the Java level
<a name="13" id="anc13"></a><span class="changed"> 983   if (!JDK_Version::is_gte_jdk14x_version()) {</span>
 984 
 985   // Access checking (unless overridden by Method)
 986   if (!override) {
 987     if (!(klass-&gt;is_public() &amp;&amp; reflected_method-&gt;is_public())) {
 988       bool access = Reflection::reflect_check_access(klass(), reflected_method-&gt;access_flags(), target_klass(), is_method_invoke, CHECK_NULL);
 989       if (!access) {
 990         return NULL; // exception
 991       }
 992     }
 993   }
 994 
<a name="14" id="anc14"></a><span class="changed"> 995   } // !Universe::is_gte_jdk14x_version()</span>
 996 
 997   assert(ptypes-&gt;is_objArray(), "just checking");
 998   int args_len = args.is_null() ? 0 : args-&gt;length();
 999   // Check number of arguments
1000   if (ptypes-&gt;length() != args_len) {
1001     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "wrong number of arguments");
1002   }
1003 
1004   // Create object to contain parameters for the JavaCall
1005   JavaCallArguments java_args(method-&gt;size_of_parameters());
1006 
1007   if (!is_static) {
1008     java_args.push_oop(receiver);
1009   }
1010 
1011   for (int i = 0; i &lt; args_len; i++) {
1012     oop type_mirror = ptypes-&gt;obj_at(i);
1013     oop arg = args-&gt;obj_at(i);
1014     if (java_lang_Class::is_primitive(type_mirror)) {
1015       jvalue value;
1016       BasicType ptype = basic_type_mirror_to_basic_type(type_mirror, CHECK_NULL);
1017       BasicType atype = unbox_for_primitive(arg, &amp;value, CHECK_NULL);
1018       if (ptype != atype) {
1019         widen(&amp;value, atype, ptype, CHECK_NULL);
1020       }
1021       switch (ptype) {
1022         case T_BOOLEAN:     java_args.push_int(value.z);    break;
1023         case T_CHAR:        java_args.push_int(value.c);    break;
1024         case T_BYTE:        java_args.push_int(value.b);    break;
1025         case T_SHORT:       java_args.push_int(value.s);    break;
1026         case T_INT:         java_args.push_int(value.i);    break;
1027         case T_LONG:        java_args.push_long(value.j);   break;
1028         case T_FLOAT:       java_args.push_float(value.f);  break;
1029         case T_DOUBLE:      java_args.push_double(value.d); break;
1030         default:
1031           THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "argument type mismatch");
1032       }
1033     } else {
1034       if (arg != NULL) {
1035         Klass* k = java_lang_Class::as_Klass(type_mirror);
1036         if (!arg-&gt;is_a(k)) {
1037           THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "argument type mismatch");
1038         }
1039       }
1040       Handle arg_handle(THREAD, arg);         // Create handle for argument
1041       java_args.push_oop(arg_handle); // Push handle
1042     }
1043   }
1044 
1045   assert(java_args.size_of_parameters() == method-&gt;size_of_parameters(), "just checking");
1046 
1047   // All oops (including receiver) is passed in as Handles. An potential oop is returned as an
1048   // oop (i.e., NOT as an handle)
1049   JavaValue result(rtype);
1050   JavaCalls::call(&amp;result, method, &amp;java_args, THREAD);
1051 
1052   if (HAS_PENDING_EXCEPTION) {
1053     // Method threw an exception; wrap it in an InvocationTargetException
1054     oop target_exception = PENDING_EXCEPTION;
1055     CLEAR_PENDING_EXCEPTION;
1056     // JVMTI has already reported the pending exception
1057     // JVMTI internal flag reset is needed in order to report InvocationTargetException
1058     if (THREAD-&gt;is_Java_thread()) {
1059       JvmtiExport::clear_detected_exception((JavaThread*) THREAD);
1060     }
1061 
1062     JavaCallArguments args(Handle(THREAD, target_exception));
1063     THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1064                 vmSymbols::throwable_void_signature(),
1065                 &amp;args);
1066   } else {
1067     if (rtype == T_BOOLEAN || rtype == T_BYTE || rtype == T_CHAR || rtype == T_SHORT)
1068       narrow((jvalue*) result.get_value_addr(), rtype, CHECK_NULL);
1069     return box((jvalue*) result.get_value_addr(), rtype, CHECK_NULL);
1070   }
1071 }
1072 
1073 
1074 void Reflection::narrow(jvalue* value, BasicType narrow_type, TRAPS) {
1075   switch (narrow_type) {
1076     case T_BOOLEAN:
1077      value-&gt;z = (jboolean) value-&gt;i;
1078      return;
1079     case T_BYTE:
1080      value-&gt;b = (jbyte) value-&gt;i;
1081      return;
1082     case T_CHAR:
1083      value-&gt;c = (jchar) value-&gt;i;
1084      return;
1085     case T_SHORT:
1086      value-&gt;s = (jshort) value-&gt;i;
1087      return;
1088     default:
1089       break; // fail
1090    }
1091   THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), "argument type mismatch");
1092 }
1093 
1094 
1095 BasicType Reflection::basic_type_mirror_to_basic_type(oop basic_type_mirror, TRAPS) {
1096   assert(java_lang_Class::is_primitive(basic_type_mirror), "just checking");
1097   return java_lang_Class::primitive_type(basic_type_mirror);
1098 }
1099 
1100 // This would be nicer if, say, java.lang.reflect.Method was a subclass
1101 // of java.lang.reflect.Constructor
1102 
1103 oop Reflection::invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS) {
1104   oop mirror             = java_lang_reflect_Method::clazz(method_mirror);
1105   int slot               = java_lang_reflect_Method::slot(method_mirror);
1106   bool override          = java_lang_reflect_Method::override(method_mirror) != 0;
1107   objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)));
1108 
1109   oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);
1110   BasicType rtype;
1111   if (java_lang_Class::is_primitive(return_type_mirror)) {
1112     rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);
1113   } else {
1114     rtype = T_OBJECT;
1115   }
1116 
1117   instanceKlassHandle klass(THREAD, java_lang_Class::as_Klass(mirror));
1118   Method* m = klass-&gt;method_with_idnum(slot);
1119   if (m == NULL) {
1120     THROW_MSG_0(vmSymbols::java_lang_InternalError(), "invoke");
1121   }
1122   methodHandle method(THREAD, m);
1123 
1124   return invoke(klass, method, receiver, override, ptypes, rtype, args, true, THREAD);
1125 }
1126 
1127 
1128 oop Reflection::invoke_constructor(oop constructor_mirror, objArrayHandle args, TRAPS) {
1129   oop mirror             = java_lang_reflect_Constructor::clazz(constructor_mirror);
1130   int slot               = java_lang_reflect_Constructor::slot(constructor_mirror);
1131   bool override          = java_lang_reflect_Constructor::override(constructor_mirror) != 0;
1132   objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Constructor::parameter_types(constructor_mirror)));
1133 
1134   instanceKlassHandle klass(THREAD, java_lang_Class::as_Klass(mirror));
1135   Method* m = klass-&gt;method_with_idnum(slot);
1136   if (m == NULL) {
1137     THROW_MSG_0(vmSymbols::java_lang_InternalError(), "invoke");
1138   }
1139   methodHandle method(THREAD, m);
1140   assert(method-&gt;name() == vmSymbols::object_initializer_name(), "invalid constructor");
1141 
1142   // Make sure klass gets initialize
1143   klass-&gt;initialize(CHECK_NULL);
1144 
1145   // Create new instance (the receiver)
1146   klass-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1147   Handle receiver = klass-&gt;allocate_instance_handle(CHECK_NULL);
1148 
1149   // Ignore result from call and return receiver
1150   invoke(klass, method, receiver, override, ptypes, T_VOID, args, false, CHECK_NULL);
1151   return receiver();
1152 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="15" type="hidden" /></form></body></html>
